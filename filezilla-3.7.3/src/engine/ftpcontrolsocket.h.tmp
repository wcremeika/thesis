
#__FILE__ _"C:\Users\Billy\Dropbox\Thesis\Projects\filezilla-3.7.3\src\engine\ftpcontrolsocket.h" 0
                              
                              

                           
#__FILE__ _"C:\Users\Billy\Dropbox\Thesis\Projects\filezilla-3.7.3\src\engine\logging_private.h" 0
                             
                             

class CLogging
{
public:
	CLogging(CFileZillaEnginePrivate *pEngine);
	virtual ~CLogging();

	void LogMessage(MessageType nMessageType, const wxChar *msgFormat, ...) const;
	void LogMessageRaw(MessageType nMessageType, const wxChar *msg) const;
	void LogMessage(wxString sourceFile, int nSourceLine, void *pInstance, MessageType nMessageType, const wxChar *msgFormat, ...) const;

private:
	CFileZillaEnginePrivate *m_pEngine;

	void InitLogFile() const;
	void LogToFile(MessageType nMessageType, const wxString& msg) const;

	static bool m_logfile_initialized;
                
	                       
     
	static int m_log_fd;
      
	static wxString m_prefixes[MessageTypeCount];
	static unsigned int m_pid;
	static int m_max_size;
	static wxString m_file;

	static int m_refcount;
};

      

#__FILE__ _"C:\Users\Billy\Dropbox\Thesis\Projects\filezilla-3.7.3\src\engine\ftpcontrolsocket.h" 4
                         
#__FILE__ _"C:\Users\Billy\Dropbox\Thesis\Projects\filezilla-3.7.3\src\engine\ControlSocket.h" 0
                           
                           

                  
#__FILE__ _"C:\Users\Billy\Dropbox\Thesis\Projects\filezilla-3.7.3\src\include\socket.h" 0
                    
                    

// IPv6 capable, non-blocking socket class for use with wxWidgets.
// Error codes are the same as used by the POSIX socket functions,
// see 'man 2 socket', 'man 2 connect', ...

class CSocketEventHandler;
class CSocketEventSource;
class CSocketEvent
{
public:
	enum EventType
	{
		hostaddress,

		// This is a nonfatal condition. It
		// means there are additional addresses to try.
		connection_next,
		connection,
		read,
		write,
		close
	};

	CSocketEvent(CSocketEventHandler* pSocketEventHandler, CSocketEventSource* pSource, enum EventType type, const wxChar* data);
	CSocketEvent(CSocketEventHandler* pSocketEventHandler, CSocketEventSource* pSource, enum EventType type, int error = 0);
	~CSocketEvent();

	CSocketEventSource* GetSocketEventSource() const { return m_pSource; }
	enum EventType GetType() const { return m_type; }
	CSocketEventHandler* GetSocketEventHandler() const { return m_pSocketEventHandler; }

	wxString GetData() const;
	int GetError() const { return m_error; }

protected:
	CSocketEventSource* m_pSource;
	const enum EventType m_type;
	wxChar *m_data;
	int m_error;
	CSocketEventHandler* m_pSocketEventHandler;

	friend class CSocketEventDispatcher;
};

class CSocketEventDispatcher : protected wxEvtHandler
{
public:
	void SendEvent(CSocketEvent* evt);
	void RemovePending(const CSocketEventHandler* pHandler);
	void RemovePending(const CSocketEventSource* pSource);
	void UpdatePending(const CSocketEventHandler* pOldHandler, const CSocketEventSource* pOldSource, CSocketEventHandler* pNewHandler, CSocketEventSource* pNewSource);

	static CSocketEventDispatcher& Get();

private:
	CSocketEventDispatcher();
	~CSocketEventDispatcher();

	virtual bool ProcessEvent(wxEvent& event);

	std::list<CSocketEvent*> m_pending_events;

	wxCriticalSection m_sync;

	static CSocketEventDispatcher m_dispatcher;

	bool m_inside_loop;
};

class CSocketEventHandler
{
public:
	CSocketEventHandler() {};
	virtual ~CSocketEventHandler();

	virtual void OnSocketEvent(CSocketEvent& event) = 0;
};

class CSocketEventSource
{
public:
	virtual ~CSocketEventSource();
};

class CCallback
{
public:
	virtual void cb() {}
};

class CSocketThread;
class CSocket : public CSocketEventSource
{
	friend class CSocketThread;
public:
	CSocket(CSocketEventHandler* pEvtHandler);
	virtual ~CSocket();

	enum SocketState
	{
		// How the socket is initially
		none,

		// Only in listening and connecting states you can get a connection event.
		// After sending the event, socket is in connected state
		listening,
		connecting,

		// Only in this state you can get send or receive events
		connected,

		// Graceful shutdown, you get close event once done
		closing,
		closed
	};
	enum SocketState GetState();

	enum address_family
	{
		unspec, // AF_UNSPEC
		ipv4,   // AF_INET
		ipv6    // AF_INET6
	};

	// Connects to the given host, given as name, IPv4 or IPv6 address.
	// Returns 0 on success, else an error code. Note: EINPROGRESS is
	// not really an error. On success, you should still wait for the
	// connection event.
	// If host is a name that can be resolved, a hostaddress socket event gets sent.
	// Once connections got established, a connection event gets sent. If
	// connection could not be established, a close event gets sent.
	int Connect(wxString host, unsigned int port, enum address_family family = unspec);

	// After receiving a send or receive event, you can call these functions
	// as long as their return value is positive.
	int Read(void *buffer, unsigned int size, int& error);
	int Peek(void *buffer, unsigned int size, int& error);
	int Write(const void *buffer, unsigned int size, int& error);

	int Close();

	// Returns empty string on error
	wxString GetLocalIP(bool strip_zone_index = false) const;
	wxString GetPeerIP(bool strip_zone_index = false) const;

	// -1 on error
	int GetLocalPort(int& error);
	int GetRemotePort(int& error);

	// If connected, either ipv4 or ipv6, unspec otherwise
	enum address_family GetAddressFamily() const;

	static wxString GetErrorString(int error);
	static wxString GetErrorDescription(int error);

	// Can only be called if the state is none
	void SetEventHandler(CSocketEventHandler* pEvtHandler);
	CSocketEventHandler* GetEventHandler() { return m_pEvtHandler; }

	static bool Cleanup(bool force);

	static wxString AddressToString(const struct sockaddr* addr, int addr_len, bool with_port = true, bool strip_zone_index = false);

	int Listen(enum address_family family, int port = 0);
	CSocket* Accept(int& error);

	enum Flags
	{
		flag_nodelay = 0x01,
		flag_keepalive = 0x02
	};

	void SetFlags(int flags);

	// If called on listen socket, sizes will be inherited by
	// accepted sockets
	void SetBufferSizes(int size_read, int size_write);

	void SetSynchronousReadCallback(CCallback* cb);

protected:
	static int DoSetFlags(int fd, int flags, int flags_mask);
	static int DoSetBufferSizes(int fd, int size_read, int size_write);
	static int SetNonblocking(int fd);

	void DetachThread();

	CSocketEventHandler* m_pEvtHandler;

	int m_fd;

	enum SocketState m_state;

	CSocketThread* m_pSocketThread;

	wxString m_host;
	unsigned int m_port;
	int m_family;

	int m_flags;

	int m_buffer_sizes[2];

	CCallback* m_synchronous_read_cb;
};

                

               
                          
      
                   
                                  
      
                    
                                    
      
                  
                                
      
               
                          
      
                       
                                          
      
                
                            
      
                    
                                    
      
                
                            
      
                 
                              
      
                   
                                  
      
                    
                                    
      
                
                            
      
                 
                              
      
                  
                                
      
                 
                              
      
                
                            
      
                    
                                    
      
                  
                                
      

                  
                                  
       //__WXMSW__

       //__SOCKET_H__

#__FILE__ _"C:\Users\Billy\Dropbox\Thesis\Projects\filezilla-3.7.3\src\engine\ControlSocket.h" 6
                           
#__FILE__ _"C:\Users\Billy\Dropbox\Thesis\Projects\filezilla-3.7.3\src\engine\logging_private.h" 0
                             
                             

              
 
       
	                                           
	                    

	                                                                              
	                                                                      
	                                                                                                                                     

        
	                                   

	                         
	                                                                    

	                                  
                
	                       
     
	                    
      
	                                             
	                          
	                      
	                       

	                      
  

      

#__FILE__ _"C:\Users\Billy\Dropbox\Thesis\Projects\filezilla-3.7.3\src\engine\ControlSocket.h" 7
                   
#__FILE__ _"C:\Users\Billy\Dropbox\Thesis\Projects\filezilla-3.7.3\src\engine\backend.h" 0
                     
                     

                       
#__FILE__ _"C:\Users\Billy\Dropbox\Thesis\Projects\filezilla-3.7.3\src\engine\ratelimiter.h" 0
                         
                         

class COptionsBase;

class CRateLimiterObject;

// This class implements a simple rate limiter based on the Token Bucket algorithm.
class CRateLimiter : protected wxEvtHandler
{
public:
	static CRateLimiter* Create(COptionsBase *pOptions);
	static CRateLimiter* Get();
	void Free();

	enum rate_direction
	{
		inbound,
		outbound
	};

	void AddObject(CRateLimiterObject* pObject);
	void RemoveObject(CRateLimiterObject* pObject);

protected:
	wxLongLong GetLimit(enum rate_direction direction) const;

	int GetBucketSize() const;

	CRateLimiter(COptionsBase* pOptions);
	virtual ~CRateLimiter();

	std::list<CRateLimiterObject*> m_objectList;
	std::list<CRateLimiterObject*> m_wakeupList[2];

	wxTimer m_timer;

	static CRateLimiter *m_pTheRateLimiter;
	unsigned int m_usageCount;

	wxLongLong m_tokenDebt[2];

	COptionsBase* m_pOptions;

	void WakeupWaitingObjects();

	DECLARE_EVENT_TABLE()
	void OnTimer(wxTimerEvent& event);
};

class CRateLimiterObject
{
	friend class CRateLimiter;

public:
	CRateLimiterObject();
	virtual ~CRateLimiterObject() {}
	wxLongLong GetAvailableBytes(enum CRateLimiter::rate_direction direction) const { return m_bytesAvailable[direction]; }

	bool IsWaiting(enum CRateLimiter::rate_direction direction) const;

protected:
	void UpdateUsage(enum CRateLimiter::rate_direction direction, int usedBytes);
	void Wait(enum CRateLimiter::rate_direction direction);

	virtual void OnRateAvailable(enum CRateLimiter::rate_direction) {}

private:
	bool m_waiting[2];
	wxLongLong m_bytesAvailable[2];
};

       //__RATELIMITER_H__

#__FILE__ _"C:\Users\Billy\Dropbox\Thesis\Projects\filezilla-3.7.3\src\engine\backend.h" 6
                  
#__FILE__ _"C:\Users\Billy\Dropbox\Thesis\Projects\filezilla-3.7.3\src\include\socket.h" 0
                    
                    

                                                                  
                                                                  
                                           

                          
                         
                  
 
       
	              
	 
		            

		                                   
		                                               
		                
		           
		     
		      
		     
	  

	                                                                                                                             
	                                                                                                                        
	                

	                                                                      
	                                                 
	                                                                                    

	                         
	                                        

          
	                              
	                            
	               
	            
	                                           

	                                    
  

                                                     
 
       
	                                  
	                                                        
	                                                      
	                                                                                                                                                                   

	                                     

        
	                         
	                          

	                                          

	                                          

	                         

	                                           

	                   
  

                         
 
       
	                         
	                               

	                                                    
  

                        
 
       
	                              
  

               
 
       
	                    
  

                    
                                         
 
	                           
       
	                                          
	                   

	                
	 
		                              
		     

		                                                                          
		                                                        
		          
		           

		                                                        
		          

		                                                   
		        
		      
	  
	                            

	                   
	 
		                    
		                  
		                   
	  

	                                                                   
	                                                                 
	                                                                 
	                    
	                                                                                
	                                                                     
	                                                                
	                                                                                   

	                                                                        
	                                             
	                                                      
	                                                      
	                                                             

	            

	                                
	                                                         
	                                                        

	              
	                             
	                              

	                                                      
	                                             

	                                          
	                                               

	                                          
	                                                       
	                                                                

	                                

	                                                                                                                                 

	                                                     
	                            

	          
	 
		                    
		                     
	  

	                         

	                                                         
	                   
	                                                   

	                                               

          
	                                                         
	                                                                   
	                                  

	                    

	                                   

	         

	                         

	                               

	                
	                    
	             

	            

	                      

	                                 
  

                

               
                          
      
                   
                                  
      
                    
                                    
      
                  
                                
      
               
                          
      
                       
                                          
      
                
                            
      
                    
                                    
      
                
                            
      
                 
                              
      
                   
                                  
      
                    
                                    
      
                
                            
      
                 
                              
      
                  
                                
      
                 
                              
      
                
                            
      
                    
                                    
      
                  
                                
      

                  
                                  
                  

       //__SOCKET_H__

#__FILE__ _"C:\Users\Billy\Dropbox\Thesis\Projects\filezilla-3.7.3\src\engine\backend.h" 7

class CBackend : public CRateLimiterObject
{
public:
	CBackend(CSocketEventHandler* pEvtHandler);
	virtual ~CBackend() {}

	virtual int Read(void *buffer, unsigned int size, int& error) = 0;
	virtual int Peek(void *buffer, unsigned int size, int& error) = 0;
	virtual int Write(const void *buffer, unsigned int size, int& error) = 0;

	virtual void OnRateAvailable(enum CRateLimiter::rate_direction direction) = 0;

protected:
	CSocketEventHandler* const m_pEvtHandler;
};

class CSocket;
class CSocketBackend : public CBackend, public CSocketEventSource
{
public:
	CSocketBackend(CSocketEventHandler* pEvtHandler, CSocket* pSocket);
	virtual ~CSocketBackend();
	// Backend definitions
	virtual int Read(void *buffer, unsigned int size, int& error);
	virtual int Peek(void *buffer, unsigned int size, int& error);
	virtual int Write(const void *buffer, unsigned int size, int& error);

protected:
	virtual void OnRateAvailable(enum CRateLimiter::rate_direction direction);

	CSocket* m_pSocket;
};

       //__BACKEND_H__

#__FILE__ _"C:\Users\Billy\Dropbox\Thesis\Projects\filezilla-3.7.3\src\engine\ControlSocket.h" 8

class COpData
{
public:
	COpData(enum Command op_Id);
	virtual ~COpData();

	int opState;
	const enum Command opId;

	bool waitForAsyncRequest;
	bool holdsLock;

	COpData *pNextOpData;
};

class CConnectOpData : public COpData
{
public:
	CConnectOpData()
		: COpData(cmd_connect),
		port(0)
	{
	}

	wxString host;
	unsigned int port;
};

class CFileTransferOpData : public COpData
{
public:
	CFileTransferOpData(bool is_download, const wxString& local_file, const wxString& remote_file, const CServerPath& remote_path);
	virtual ~CFileTransferOpData();
	// Transfer data
	wxString localFile, remoteFile;
	CServerPath remotePath;
	const bool download;

	wxDateTime fileTime;
	wxFileOffset localFileSize;
	wxFileOffset remoteFileSize;

	bool tryAbsolutePath;
	bool resume;

	CFileTransferCommand::t_transferSettings transferSettings;

	// Set to true when sending the command which
	// starts the actual transfer
	bool transferInitiated;
};

class CMkdirOpData : public COpData
{
public:
	CMkdirOpData()
		: COpData(cmd_mkdir)
	{
	}

	virtual ~CMkdirOpData()
	{
	}

	CServerPath path;
	CServerPath currentPath;
	CServerPath commonParent;
	std::list<wxString> segments;
};

class CChangeDirOpData : public COpData
{
public:
	CChangeDirOpData()
		: COpData(cmd_cwd)
	{
		tryMkdOnFail = false;
		link_discovery = false;
	}

	virtual ~CChangeDirOpData()
	{
	}

	CServerPath path;
	wxString subDir;
	bool tryMkdOnFail;
	CServerPath target;

	bool link_discovery;
};

enum TransferEndReason
{
	none,
	successful,
	timeout,
	transfer_failure,					// Error during transfer, like lost connection. Retry automatically
	transfer_failure_critical,			// Error during transfer like lack of diskspace. Needs user interaction
	pre_transfer_command_failure,		// If a command fails prior to sending the transfer command
	transfer_command_failure_immediate,	// Used if server does not send the 150 reply after the transfer command
	transfer_command_failure,			// Used if the transfer command fails, but after receiving a 150 first
	failure,							// Other unspecific failure
	failed_resumetest
};

class CTransferStatus;
class CControlSocket: public wxEvtHandler, public CLogging
{
public:
	CControlSocket(CFileZillaEnginePrivate *pEngine);
	virtual ~CControlSocket();

	virtual int Connect(const CServer &server) = 0;
	virtual int Disconnect();
	virtual void Cancel();
	virtual int List(CServerPath path = CServerPath(), wxString subDir = _T(""), int flags = 0);
	virtual int FileTransfer(const wxString localFile, const CServerPath &remotePath,
							 const wxString &remoteFile, bool download,
							 const CFileTransferCommand::t_transferSettings& transferSettings);
	virtual int RawCommand(const wxString& command = _T(""));
	virtual int Delete(const CServerPath& path, const std::list<wxString>& files);
	virtual int RemoveDir(const CServerPath& path = CServerPath(), const wxString& subDir = _T(""));
	virtual int Mkdir(const CServerPath& path);
	virtual int Rename(const CRenameCommand& command);
	virtual int Chmod(const CChmodCommand& command);
	virtual bool Connected() = 0;

	// If m_pCurrentOpData is zero, this function returns the current command
	// from the engine.
	enum Command GetCurrentCommandId() const;

	virtual void TransferEnd() {}

	void SendAsyncRequest(CAsyncRequestNotification* pNotification);
	virtual bool SetAsyncRequestReply(CAsyncRequestNotification *pNotification) = 0;
	bool SetFileExistsAction(CFileExistsNotification *pFileExistsNotification);

	void InitTransferStatus(wxFileOffset totalSize, wxFileOffset startOffset, bool list);
	void SetTransferStatusStartTime();
	void UpdateTransferStatus(wxFileOffset transferredBytes);
	void ResetTransferStatus();
	bool GetTransferStatus(CTransferStatus &status, bool &changed);
	void SetTransferStatusMadeProgress();

	const CServer* GetCurrentServer() const;

	// Conversion function which convert between local and server charset.
	wxString ConvToLocal(const char* buffer);
	wxChar* ConvToLocalBuffer(const char* buffer);
	wxChar* ConvToLocalBuffer(const char* buffer, wxMBConv& conv);
	wxCharBuffer ConvToServer(const wxString& str, bool force_utf8 = false);

	// ---
	// The following two functions control the timeout behaviour:
	// ---

	// Call this if data could be sent or retrieved
	void SetAlive();

	// Set to true if waiting for data
	void SetWait(bool waiting);

	CFileZillaEnginePrivate* GetEngine() { return m_pEngine; }

	// Only called from the engine, see there for description
	void InvalidateCurrentWorkingDir(const CServerPath& path);

protected:
	wxTimeSpan GetTimezoneOffset();

	virtual int DoClose(int nErrorCode = FZ_REPLY_DISCONNECTED);
	bool m_closed;

	virtual int ResetOperation(int nErrorCode);

	virtual int SendNextCommand();

	void LogTransferResultMessage(int nErrorCode, CFileTransferOpData *pData);

	// Called by ResetOperation if there's a queued operation
	virtual int ParseSubcommandResult(int prevResult);

	wxString ConvertDomainName(wxString domain);

	int CheckOverwriteFile();

	void CreateLocalDir(const wxString &local_file);

	bool ParsePwdReply(wxString reply, bool unquoted = false, const CServerPath& defaultPath = CServerPath());

	COpData *m_pCurOpData;
	int m_nOpState;
	CFileZillaEnginePrivate *m_pEngine;
	CServer *m_pCurrentServer;

	CServerPath m_CurrentPath;

	CTransferStatus *m_pTransferStatus;
	int m_transferStatusSendState;

	wxCSConv *m_pCSConv;
	bool m_useUTF8;

	// Timeout data
	wxTimer m_timer;
	wxStopWatch m_stopWatch;

	// -------------------------
	// Begin cache locking stuff
	// -------------------------

	enum locking_reason
	{
		lock_unknown = -1,
		lock_list,
		lock_mkdir
	};

	// Tries to obtain lock. Returns true on success.
	// On failure, caller has to pass control.
	// SendNextCommand will be called once the lock gets available
	// and engine could obtain it.
	// Lock is recursive. Lock counter increases on suboperations.
	bool TryLockCache(enum locking_reason reason, const CServerPath& directory);
	bool IsLocked(enum locking_reason reason, const CServerPath& directory);

	// Unlocks the cache. Can be called if not holding the lock
	// Doesn't need reason as one engine can at most hold one lock
	void UnlockCache();

	// Called from the fzOBTAINLOCK event.
	// Returns reason != unknown iff engine is the first waiting engine
	// and obtains the lock.
	// On failure, the engine was not waiting for a lock.
	enum locking_reason ObtainLockFromEvent();

	bool IsWaitingForLock();

                  
	                                          
	       
      
	struct t_lockInfo
	{
		CControlSocket* pControlSocket;
		CServerPath directory;
		enum locking_reason reason;
		bool waiting;
		int lockcount;
	};
	static std::list<t_lockInfo> m_lockInfoList;
                  
	          
      

	const std::list<t_lockInfo>::iterator GetLockStatus();

	// -----------------------
	// End cache locking stuff
	// -----------------------

	bool m_invalidateCurrentPath;

	DECLARE_EVENT_TABLE()
	void OnTimer(wxTimerEvent& event);
	void OnObtainLock(wxCommandEvent& event);
};

class CProxySocket;
class CRealControlSocket : public CControlSocket, public CSocketEventHandler
{
public:
	CRealControlSocket(CFileZillaEnginePrivate *pEngine);
	virtual ~CRealControlSocket();

	virtual int Connect(const CServer &server);
	virtual int ContinueConnect();

	virtual bool Connected() { return m_pSocket->GetState() == CSocket::connected; }

protected:
	virtual int DoClose(int nErrorCode = FZ_REPLY_DISCONNECTED);
	void ResetSocket();

	virtual void OnSocketEvent(CSocketEvent &event);
	virtual void OnConnect();
	virtual void OnReceive();
	virtual void OnSend();
	virtual void OnClose(int error);

	virtual bool Send(const char *buffer, int len);

	CSocket* m_pSocket;

	CBackend* m_pBackend;
	CProxySocket* m_pProxyBackend;

	char *m_pSendBuffer;
	int m_nSendBufferLen;
};

      

#__FILE__ _"C:\Users\Billy\Dropbox\Thesis\Projects\filezilla-3.7.3\src\engine\ftpcontrolsocket.h" 5
                              
#__FILE__ _"C:\Users\Billy\Dropbox\Thesis\Projects\filezilla-3.7.3\src\include\externalipresolver.h" 0
                                
                                

                  
#__FILE__ _"C:\Users\Billy\Dropbox\Thesis\Projects\filezilla-3.7.3\src\include\socket.h" 0
                    
                    

                                                                  
                                                                  
                                           

                          
                         
                  
 
       
	              
	 
		            

		                                   
		                                               
		                
		           
		     
		      
		     
	  

	                                                                                                                             
	                                                                                                                        
	                

	                                                                      
	                                                 
	                                                                                    

	                         
	                                        

          
	                              
	                            
	               
	            
	                                           

	                                    
  

                                                     
 
       
	                                  
	                                                        
	                                                      
	                                                                                                                                                                   

	                                     

        
	                         
	                          

	                                          

	                                          

	                         

	                                           

	                   
  

                         
 
       
	                         
	                               

	                                                    
  

                        
 
       
	                              
  

               
 
       
	                    
  

                    
                                         
 
	                           
       
	                                          
	                   

	                
	 
		                              
		     

		                                                                          
		                                                        
		          
		           

		                                                        
		          

		                                                   
		        
		      
	  
	                            

	                   
	 
		                    
		                  
		                   
	  

	                                                                   
	                                                                 
	                                                                 
	                    
	                                                                                
	                                                                     
	                                                                
	                                                                                   

	                                                                        
	                                             
	                                                      
	                                                      
	                                                             

	            

	                                
	                                                         
	                                                        

	              
	                             
	                              

	                                                      
	                                             

	                                          
	                                               

	                                          
	                                                       
	                                                                

	                                

	                                                                                                                                 

	                                                     
	                            

	          
	 
		                    
		                     
	  

	                         

	                                                         
	                   
	                                                   

	                                               

          
	                                                         
	                                                                   
	                                  

	                    

	                                   

	         

	                         

	                               

	                
	                    
	             

	            

	                      

	                                 
  

                

               
                          
      
                   
                                  
      
                    
                                    
      
                  
                                
      
               
                          
      
                       
                                          
      
                
                            
      
                    
                                    
      
                
                            
      
                 
                              
      
                   
                                  
      
                    
                                    
      
                
                            
      
                 
                              
      
                  
                                
      
                 
                              
      
                
                            
      
                    
                                    
      
                  
                                
      

                  
                                  
                  

       //__SOCKET_H__

#__FILE__ _"C:\Users\Billy\Dropbox\Thesis\Projects\filezilla-3.7.3\src\include\externalipresolver.h" 6

class fzExternalIPResolveEvent : public wxEvent
{
public:
	fzExternalIPResolveEvent(int id = wxID_ANY);
	virtual wxEvent *Clone() const;
};

typedef void (wxEvtHandler::*fzExternalIPResolveEventFunction)(fzExternalIPResolveEvent&);

extern const wxEventType fzEVT_EXTERNALIPRESOLVE;
                                         	                                     		                                 		                                                                                                     		                                 	  






class CExternalIPResolver : public CSocketEventHandler
{
public:
	CExternalIPResolver(wxEvtHandler* handler, int id = wxID_ANY);
	virtual ~CExternalIPResolver();

	bool Done() const { return m_done; }
	bool Successful() const { return m_ip != _T(""); }
	wxString GetIP() const { return m_ip; }

	void GetExternalIP(const wxString& address, enum CSocket::address_family protocol, bool force = false);

protected:

	void Close(bool successful);

	wxString m_address;
	enum CSocket::address_family m_protocol;
	unsigned long m_port;
	wxEvtHandler* m_handler;
	int m_id;

	bool m_done;

	static wxString m_ip;
	static bool m_checked;

	wxString m_data;

	CSocket *m_pSocket;

	void OnSocketEvent(CSocketEvent& event);

	void OnConnect(int error);
	void OnClose();
	void OnReceive();
	void OnHeader();
	void OnData(char* buffer, unsigned int len);
	void OnChunkedData();
	void OnSend();

	char* m_pSendBuffer;
	unsigned int m_sendBufferPos;

	char* m_pRecvBuffer;
	unsigned int m_recvBufferPos;

	static const unsigned int m_recvBufferLen = 4096;

	// HTTP data
	void ResetHttpData(bool resetRedirectCount);
	bool m_gotHeader;
	int m_responseCode;
	wxString m_responseString;
	wxString m_location;
	int m_redirectCount;

	enum transferEncodings
	{
		identity,
		chunked,
		unknown
	};

	enum transferEncodings m_transferEncoding;

	struct t_chunkData
	{
		bool getTrailer;
		bool terminateChunk;
		wxLongLong size;
	} m_chunkData;

	bool m_finished;
};

       //__EXTERNALIPRESOLVER_H__

#__FILE__ _"C:\Users\Billy\Dropbox\Thesis\Projects\filezilla-3.7.3\src\engine\ftpcontrolsocket.h" 6
               
#__FILE__ _"C:\Users\Billy\Dropbox\Thesis\Projects\filezilla-3.7.3\src\engine\rtt.h" 0
                     
                     

                  
#__FILE__ _"C:\Users\Billy\Dropbox\Thesis\Projects\filezilla-3.7.3\src\include\socket.h" 0
                    
                    

                                                                  
                                                                  
                                           

                          
                         
                  
 
       
	              
	 
		            

		                                   
		                                               
		                
		           
		     
		      
		     
	  

	                                                                                                                             
	                                                                                                                        
	                

	                                                                      
	                                                 
	                                                                                    

	                         
	                                        

          
	                              
	                            
	               
	            
	                                           

	                                    
  

                                                     
 
       
	                                  
	                                                        
	                                                      
	                                                                                                                                                                   

	                                     

        
	                         
	                          

	                                          

	                                          

	                         

	                                           

	                   
  

                         
 
       
	                         
	                               

	                                                    
  

                        
 
       
	                              
  

               
 
       
	                    
  

                    
                                         
 
	                           
       
	                                          
	                   

	                
	 
		                              
		     

		                                                                          
		                                                        
		          
		           

		                                                        
		          

		                                                   
		        
		      
	  
	                            

	                   
	 
		                    
		                  
		                   
	  

	                                                                   
	                                                                 
	                                                                 
	                    
	                                                                                
	                                                                     
	                                                                
	                                                                                   

	                                                                        
	                                             
	                                                      
	                                                      
	                                                             

	            

	                                
	                                                         
	                                                        

	              
	                             
	                              

	                                                      
	                                             

	                                          
	                                               

	                                          
	                                                       
	                                                                

	                                

	                                                                                                                                 

	                                                     
	                            

	          
	 
		                    
		                     
	  

	                         

	                                                         
	                   
	                                                   

	                                               

          
	                                                         
	                                                                   
	                                  

	                    

	                                   

	         

	                         

	                               

	                
	                    
	             

	            

	                      

	                                 
  

                

               
                          
      
                   
                                  
      
                    
                                    
      
                  
                                
      
               
                          
      
                       
                                          
      
                
                            
      
                    
                                    
      
                
                            
      
                 
                              
      
                   
                                  
      
                    
                                    
      
                
                            
      
                 
                              
      
                  
                                
      
                 
                              
      
                
                            
      
                    
                                    
      
                  
                                
      

                  
                                  
                  

       //__SOCKET_H__

#__FILE__ _"C:\Users\Billy\Dropbox\Thesis\Projects\filezilla-3.7.3\src\engine\rtt.h" 6

class CLatencyMeasurement : public CCallback
{
public:
	CLatencyMeasurement();

	// Returns false if measurement cannot be started due to
	// a measurement already running
	bool Start();

	// Returns fals if there was no measurement running
	bool Stop();

	// In ms, returns -1 if no data is available.
	int GetLatency() const;

	void Reset();

	virtual void cb();

protected:
	wxDateTime m_start;

	wxLongLong m_summed_latency;
	int m_measurements;

	mutable wxCriticalSection m_sync;
};

      
#__FILE__ _"C:\Users\Billy\Dropbox\Thesis\Projects\filezilla-3.7.3\src\engine\ftpcontrolsocket.h" 7

                           
                       

class CTransferSocket;
class CFtpTransferOpData;
class CRawTransferOpData;
class CTlsSocket;

class CFtpControlSocket : public CRealControlSocket
{
	friend class CTransferSocket;
public:
	CFtpControlSocket(CFileZillaEnginePrivate *pEngine);
	virtual ~CFtpControlSocket();
	virtual void TransferEnd();

	virtual bool SetAsyncRequestReply(CAsyncRequestNotification *pNotification);

protected:

	virtual int ResetOperation(int nErrorCode);

	virtual int Connect(const CServer &server);
	virtual int List(CServerPath path = CServerPath(), wxString subDir = _T(""), int flags = 0);
	int ListParseResponse();
	int ListSubcommandResult(int prevResult);
	int ListSend();
	int ListCheckTimezoneDetection(CDirectoryListing& listing);

	int ChangeDir(CServerPath path = CServerPath(), wxString subDir = _T(""), bool link_discovery = false);
	int ChangeDirParseResponse();
	int ChangeDirSubcommandResult(int prevResult);
	int ChangeDirSend();

	virtual int FileTransfer(const wxString localFile, const CServerPath &remotePath,
							 const wxString &remoteFile, bool download,
							 const CFileTransferCommand::t_transferSettings& transferSettings);
	int FileTransferParseResponse();
	int FileTransferSubcommandResult(int prevResult);
	int FileTransferSend();
	int FileTransferTestResumeCapability();

	virtual int RawCommand(const wxString& command);
	int RawCommandSend();
	int RawCommandParseResponse();

	virtual int Delete(const CServerPath& path, const std::list<wxString>& files);
	int DeleteSubcommandResult(int prevResult);
	int DeleteSend();
	int DeleteParseResponse();

	virtual int RemoveDir(const CServerPath& path, const wxString& subDir);
	int RemoveDirSubcommandResult(int prevResult);
	int RemoveDirSend();
	int RemoveDirParseResponse();

	virtual int Mkdir(const CServerPath& path);
	virtual int MkdirParseResponse();
	virtual int MkdirSend();

	virtual int Rename(const CRenameCommand& command);
	virtual int RenameParseResponse();
	virtual int RenameSubcommandResult(int prevResult);
	virtual int RenameSend();

	virtual int Chmod(const CChmodCommand& command);
	virtual int ChmodParseResponse();
	virtual int ChmodSubcommandResult(int prevResult);
	virtual int ChmodSend();

	virtual int Transfer(const wxString& cmd, CFtpTransferOpData* oldData);
	virtual int TransferParseResponse();
	virtual int TransferSend();

	virtual void OnConnect();
	virtual void OnReceive();

	virtual bool Send(wxString str, bool maskArgs = false, bool measureRTT = true);

	// Parse the latest reply line from the server
	void ParseLine(wxString line);

	// Parse the actual response and delegate it to the handlers.
	// It's the last line in a multi-line response.
	void ParseResponse();

	virtual int SendNextCommand();
	virtual int ParseSubcommandResult(int prevResult);

	int GetReplyCode() const;

	int Logon();
	int LogonParseResponse();
	int LogonSend();

	bool ParsePasvResponse(CRawTransferOpData* pData);
	bool ParseEpsvResponse(CRawTransferOpData* pData);

	// Some servers are broken. Instead of an empty listing, some MVS servers
	// for example they return "550 no members found"
	// Other servers return "550 No files found."
	bool IsMisleadingListResponse() const;

	int GetExternalIPAddress(wxString& address);

	// Checks if listing2 is a subset of listing1. Compares only filenames.
	bool CheckInclusion(const CDirectoryListing& listing1, const CDirectoryListing& listing2);

	void StartKeepaliveTimer();

	bool GetLoginSequence(const CServer& server);

	wxString m_Response;
	wxString m_MultilineResponseCode;
	std::list<wxString> m_MultilineResponseLines;

	CTransferSocket *m_pTransferSocket;

	// Some servers keep track of the offset specified by REST between sessions
	// So we always sent a REST 0 for a normal transfer following a restarted one
	bool m_sentRestartOffset;

	char m_receiveBuffer[4096];
	int m_bufferLen;
	int m_repliesToSkip; // Set to the amount of pending replies if cancelling an action

	int m_pendingReplies;

	CExternalIPResolver* m_pIPResolver;

	CTlsSocket* m_pTlsSocket;
	bool m_protectDataChannel;

	int m_lastTypeBinary;

	int m_pendingTransferEndEvents;

	// Used by keepalive code so that we're not using keep alive
	// till the end of time. Stop after a couple of minutes.
	wxDateTime m_lastCommandCompletionTime;

	wxTimer m_idleTimer;

	CLatencyMeasurement m_rtt;

	DECLARE_EVENT_TABLE()
	void OnExternalIPAddress(fzExternalIPResolveEvent& event);
	void OnIdleTimer(wxTimerEvent& event);
};

class CIOThread;

class CFtpTransferOpData
{
public:
	CFtpTransferOpData();
	virtual ~CFtpTransferOpData() {}

	enum TransferEndReason transferEndReason;
	bool tranferCommandSent;

	wxLongLong resumeOffset;
	bool binary;
};

class CFtpFileTransferOpData : public CFileTransferOpData, public CFtpTransferOpData
{
public:
	CFtpFileTransferOpData(bool is_download, const wxString& local_file, const wxString& remote_file, const CServerPath& remote_path);
	virtual ~CFtpFileTransferOpData();

	CIOThread *pIOThread;
	bool fileDidExist;
};

class CRawTransferOpData : public COpData
{
public:
	CRawTransferOpData();
	wxString cmd;

	CFtpTransferOpData* pOldData;

	bool bPasv;
	bool bTriedPasv;
	bool bTriedActive;

	wxString host;
	int port;
};

      
