
#__FILE__ _"C:\Users\Billy\Dropbox\Thesis\Projects\filezilla-3.7.3\src\include\wx\list.h" 0
/////////////////////////////////////////////////////////////////////////////
// Name:        wx/list.h
// Purpose:     wxList, wxStringList classes
// Author:      Julian Smart
// Modified by: VZ at 16/11/98: WX_DECLARE_LIST() and typesafe lists added
// Created:     29/01/98
// Copyright:   (c) 1998 Julian Smart
// Licence:     wxWindows licence
/////////////////////////////////////////////////////////////////////////////

/*
  All this is quite ugly but serves two purposes:
    1. Be almost 100% compatible with old, untyped, wxList class
    2. Ensure compile-time type checking for the linked lists

  The idea is to have one base class (wxListBase) working with "void *" data,
  but to hide these untyped functions - i.e. make them protected, so they
  can only be used from derived classes which have inline member functions
  working with right types. This achieves the 2nd goal. As for the first one,
  we provide a special derivation of wxListBase called wxList which looks just
  like the old class.
*/

                   
                   

// -----------------------------------------------------------------------------
// headers
// -----------------------------------------------------------------------------

                   
                     
                     
                     

                        
                             
                        
                       
                   
                            
      

// ----------------------------------------------------------------------------
// types
// ----------------------------------------------------------------------------

class WXDLLIMPEXP_FWD_BASE wxObjectListNode;
typedef wxObjectListNode wxNode;

                        

                            

                                                                                                       

                                                                                                                   


                                                                                              

                                                                                                  


                                                                                         


                                                           

                 
                         
 
       
                                                             
                                             
                                           
        
                              
  

                                                                  
                                              

                                                                  

                                                             
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              





















                                      
                    
                                                                           
                                                                  
                                

                  

  
                                                                              
                                                                             
                                                                             

                                    
          
                              
                                 
             
                                                                   
              
                  
             
                      
             
           

                                                                       
                                    


                                                                       
                                                                          
                                                                               
                                                                              
                     
   

                                    
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         




















































































































































































                                                                                                                                       

                                                                                                                      


                                                                                                                                                        

                                                                                                                               


                                                                                                                                               

                                                                                                                                             


                                                    
                                  
                                                                       

                                                               
                                                               

      // if !wxUSE_STD_CONTAINERS


// undef it to get rid of old, deprecated functions
                            

// -----------------------------------------------------------------------------
// key stuff: a list may be optionally keyed on integer or string key
// -----------------------------------------------------------------------------

union wxListKeyValue
{
    long integer;
    wxString *string;
};

// a struct which may contain both types of keys
//
// implementation note: on one hand, this class allows to have only one function
// for any keyed operation instead of 2 almost equivalent. OTOH, it's needed to
// resolve ambiguity which we would otherwise have with wxStringList::Find() and
// wxList::Find(const char *).
class WXDLLIMPEXP_BASE wxListKey
{
public:
    // implicit ctors
    wxListKey() : m_keyType(wxKEY_NONE)
        { }
    wxListKey(long i) : m_keyType(wxKEY_INTEGER)
        { m_key.integer = i; }
    wxListKey(const wxString& s) : m_keyType(wxKEY_STRING)
        { m_key.string = new wxString(s); }
    wxListKey(const char *s) : m_keyType(wxKEY_STRING)
        { m_key.string = new wxString(s); }
    wxListKey(const wchar_t *s) : m_keyType(wxKEY_STRING)
        { m_key.string = new wxString(s); }

    // accessors
    wxKeyType GetKeyType() const { return m_keyType; }
    const wxString GetString() const
        { wxASSERT( m_keyType == wxKEY_STRING ); return *m_key.string; }
    long GetNumber() const
        { wxASSERT( m_keyType == wxKEY_INTEGER ); return m_key.integer; }

    // comparison
    // Note: implementation moved to list.cpp to prevent BC++ inline
    // expansion warning.
    bool operator==(wxListKeyValue value) const ;

    // dtor
    ~wxListKey()
    {
        if ( m_keyType == wxKEY_STRING )
            delete m_key.string;
    }

private:
    wxKeyType m_keyType;
    wxListKeyValue m_key;
};

// -----------------------------------------------------------------------------
// wxNodeBase class is a (base for) node in a double linked list
// -----------------------------------------------------------------------------

extern WXDLLIMPEXP_DATA_BASE(wxListKey) wxDefaultListKey;

class WXDLLIMPEXP_FWD_BASE wxListBase;

class WXDLLIMPEXP_BASE wxNodeBase
{
friend class wxListBase;
public:
    // ctor
    wxNodeBase(wxListBase *list = NULL,
               wxNodeBase *previous = NULL,
               wxNodeBase *next = NULL,
               void *data = NULL,
               const wxListKey& key = wxDefaultListKey);

    virtual ~wxNodeBase();

    // FIXME no check is done that the list is really keyed on strings
    wxString GetKeyString() const { return *m_key.string; }
    long GetKeyInteger() const { return m_key.integer; }

    // Necessary for some existing code
    void SetKeyString(const wxString& s) { m_key.string = new wxString(s); }
    void SetKeyInteger(long i) { m_key.integer = i; }

                           
    // compatibility methods, use Get* instead.
    wxDEPRECATED( wxNode *Next() const );
    wxDEPRECATED( wxNode *Previous() const );
    wxDEPRECATED( wxObject *Data() const );
       // wxLIST_COMPATIBILITY

protected:
    // all these are going to be "overloaded" in the derived classes
    wxNodeBase *GetNext() const { return m_next; }
    wxNodeBase *GetPrevious() const { return m_previous; }

    void *GetData() const { return m_data; }
    void SetData(void *data) { m_data = data; }

    // get 0-based index of this node within the list or wxNOT_FOUND
    int IndexOf() const;

    virtual void DeleteData() { }
public:
    // for wxList::iterator
    void** GetDataPtr() const { return &(const_cast<wxNodeBase*>(this)->m_data); }
private:
    // optional key stuff
    wxListKeyValue m_key;

    void        *m_data;        // user data
    wxNodeBase  *m_next,        // next and previous nodes in the list
                *m_previous;

    wxListBase  *m_list;        // list we belong to

    wxDECLARE_NO_COPY_CLASS(wxNodeBase);
};

// -----------------------------------------------------------------------------
// a double-linked list class
// -----------------------------------------------------------------------------

class WXDLLIMPEXP_FWD_BASE wxList;

class WXDLLIMPEXP_BASE wxListBase
{
friend class wxNodeBase; // should be able to call DetachNode()
friend class wxHashTableBase;   // should be able to call untyped Find()

public:
    // default ctor & dtor
    wxListBase(wxKeyType keyType = wxKEY_NONE)
        { Init(keyType); }
    virtual ~wxListBase();

    // accessors
        // count of items in the list
    size_t GetCount() const { return m_count; }

        // return true if this list is empty
    bool IsEmpty() const { return m_count == 0; }

    // operations

        // delete all nodes
    void Clear();

        // instruct it to destroy user data when deleting nodes
    void DeleteContents(bool destroy) { m_destroy = destroy; }

       // query if to delete
    bool GetDeleteContents() const
        { return m_destroy; }

      // get the keytype
    wxKeyType GetKeyType() const
        { return m_keyType; }

      // set the keytype (required by the serial code)
    void SetKeyType(wxKeyType keyType)
        { wxASSERT( m_count==0 ); m_keyType = keyType; }

                           
    // compatibility methods from old wxList
    wxDEPRECATED( int Number() const );             // use GetCount instead.
    wxDEPRECATED( wxNode *First() const );          // use GetFirst
    wxDEPRECATED( wxNode *Last() const );           // use GetLast
    wxDEPRECATED( wxNode *Nth(size_t n) const );    // use Item

    // kludge for typesafe list migration in core classes.
    wxDEPRECATED( operator wxList&() const );
       // wxLIST_COMPATIBILITY

protected:

    // all methods here are "overloaded" in derived classes to provide compile
    // time type checking

    // create a node for the list of this type
    virtual wxNodeBase *CreateNode(wxNodeBase *prev, wxNodeBase *next,
                                   void *data,
                                   const wxListKey& key = wxDefaultListKey) = 0;


    // ctors
        // from an array
    wxListBase(size_t count, void *elements[]);
        // from a sequence of objects
    wxListBase(void *object, ... /* terminate with NULL */);

protected:
    void Assign(const wxListBase& list)
        { Clear(); DoCopy(list); }

        // get list head/tail
    wxNodeBase *GetFirst() const { return m_nodeFirst; }
    wxNodeBase *GetLast() const { return m_nodeLast; }

        // by (0-based) index
    wxNodeBase *Item(size_t index) const;

        // get the list item's data
    void *operator[](size_t n) const
    {
        wxNodeBase *node = Item(n);

        return node ? node->GetData() : NULL;
    }

    // operations
        // append to end of list
    wxNodeBase *Prepend(void *object)
        { return (wxNodeBase *)wxListBase::Insert(object); }
        // append to beginning of list
    wxNodeBase *Append(void *object);
        // insert a new item at the beginning of the list
    wxNodeBase *Insert(void *object)
        { return Insert(static_cast<wxNodeBase *>(NULL), object); }
        // insert a new item at the given position
    wxNodeBase *Insert(size_t pos, void *object)
        { return pos == GetCount() ? Append(object)
                                   : Insert(Item(pos), object); }
        // insert before given node or at front of list if prev == NULL
    wxNodeBase *Insert(wxNodeBase *prev, void *object);

        // keyed append
    wxNodeBase *Append(long key, void *object);
    wxNodeBase *Append(const wxString& key, void *object);

        // removes node from the list but doesn't delete it (returns pointer
        // to the node or NULL if it wasn't found in the list)
    wxNodeBase *DetachNode(wxNodeBase *node);
        // delete element from list, returns false if node not found
    bool DeleteNode(wxNodeBase *node);
        // finds object pointer and deletes node (and object if DeleteContents
        // is on), returns false if object not found
    bool DeleteObject(void *object);

    // search (all return NULL if item not found)
        // by data
    wxNodeBase *Find(const void *object) const;

        // by key
    wxNodeBase *Find(const wxListKey& key) const;

    // get 0-based index of object or wxNOT_FOUND
    int IndexOf( void *object ) const;

    // this function allows the sorting of arbitrary lists by giving
    // a function to compare two list elements. The list is sorted in place.
    void Sort(const wxSortCompareFunction compfunc);

    // functions for iterating over the list
    void *FirstThat(wxListIterateFunction func);
    void ForEach(wxListIterateFunction func);
    void *LastThat(wxListIterateFunction func);

    // for STL interface, "last" points to one after the last node
    // of the controlled sequence (NULL for the end of the list)
    void Reverse();
    void DeleteNodes(wxNodeBase* first, wxNodeBase* last);
private:

        // common part of all ctors
    void Init(wxKeyType keyType = wxKEY_NONE);

    // helpers
        // common part of copy ctor and assignment operator
    void DoCopy(const wxListBase& list);
        // common part of all Append()s
    wxNodeBase *AppendCommon(wxNodeBase *node);
        // free node's data and node itself
    void DoDeleteNode(wxNodeBase *node);

    size_t m_count;             // number of elements in the list
    bool m_destroy;             // destroy user data when deleting list items?
    wxNodeBase *m_nodeFirst,    // pointers to the head and tail of the list
               *m_nodeLast;

    wxKeyType m_keyType;        // type of our keys (may be wxKEY_NONE)
};

// -----------------------------------------------------------------------------
// macros for definition of "template" list type
// -----------------------------------------------------------------------------

// and now some heavy magic...

// declare a list type named 'name' and containing elements of type 'T *'
// (as a by product of macro expansion you also get wx##name##Node
// wxNode-derived type)
//
// implementation details:
//  1. We define _WX_LIST_ITEM_TYPE_##name typedef to save in it the item type
//     for the list of given type - this allows us to pass only the list name
//     to WX_DEFINE_LIST() even if it needs both the name and the type
//
//  2. We redefine all non-type-safe wxList functions with type-safe versions
//     which don't take any space (everything is inline), but bring compile
//     time error checking.
//
//  3. The macro which is usually used (WX_DECLARE_LIST) is defined in terms of
//     a more generic WX_DECLARE_LIST_2 macro which, in turn, uses the most
//     generic WX_DECLARE_LIST_3 one. The last macro adds a sometimes
//     interesting capability to store polymorphic objects in the list and is
//     particularly useful with, for example, "wxWindow *" list where the
//     wxWindowBase pointers are put into the list, but wxWindow pointers are
//     retrieved from it.
//
//  4. final hack is that WX_DECLARE_LIST_3 is defined in terms of
//     WX_DECLARE_LIST_4 to allow defining classes without operator->() as
//     it results in compiler warnings when this operator doesn't make sense
//     (i.e. stored elements are not pointers)

// common part of WX_DECLARE_LIST_3 and WX_DECLARE_LIST_PTR_3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             
















































































































































































































































































































































































































































                                                                                                                                                                                                                      


                          

                                                                                                                                                         

                                                                                                                                                 


                                                                                                                                                         

                                                                                                                                                                 


                                                                                                                                                                                                                               


                                                                                                                                                                                                                                       



                                                                                                                                                                                                                 



                                                                                                                                                        


                                                                                                                                                                                                                                                        



                                                                                                                                                                                                                                       


                                                                                                                                                                                                                                               



// this macro must be inserted in your program after
//      #include "wx/listimpl.cpp"
                                                                       

                                                               
                                                               

       // !wxUSE_STD_CONTAINERS

// ============================================================================
// now we can define classes 100% compatible with the old ones
// ============================================================================

// ----------------------------------------------------------------------------
// commonly used list classes
// ----------------------------------------------------------------------------

                                 

// inline compatibility functions

                         

// ----------------------------------------------------------------------------
// wxNodeBase deprecated methods
// ----------------------------------------------------------------------------

inline wxNode *wxNodeBase::Next() const { return (wxNode *)GetNext(); }
inline wxNode *wxNodeBase::Previous() const { return (wxNode *)GetPrevious(); }
inline wxObject *wxNodeBase::Data() const { return (wxObject *)GetData(); }

// ----------------------------------------------------------------------------
// wxListBase deprecated methods
// ----------------------------------------------------------------------------

inline int wxListBase::Number() const { return (int)GetCount(); }
inline wxNode *wxListBase::First() const { return (wxNode *)GetFirst(); }
inline wxNode *wxListBase::Last() const { return (wxNode *)GetLast(); }
inline wxNode *wxListBase::Nth(size_t n) const { return (wxNode *)Item(n); }
inline wxListBase::operator wxList&() const { return *(wxList*)this; }

      

// define this to make a lot of noise about use of the old wxList classes.
//#define wxWARN_COMPAT_LIST_USE

// ----------------------------------------------------------------------------
// wxList compatibility class: in fact, it's a list of wxObjects
// ----------------------------------------------------------------------------

typedef int (*wxSortFuncFor_wxObjectList)(const wxObject **, const wxObject **);                                                                                            class WXDLLIMPEXP_BASE wxObjectListNode : public wxNodeBase                                       {                                                                           public:                                                                         wxObjectListNode(wxListBase *list = NULL,                                                    wxObjectListNode *previous = NULL,                                                  wxObjectListNode *next = NULL,                                                      wxObject *data = NULL,                                                             const wxListKey& key = wxDefaultListKey)                               : wxNodeBase(list, previous, next, data, key) { }                                                                                                   wxObjectListNode *GetNext() const                                                       { return (wxObjectListNode *)wxNodeBase::GetNext(); }                           wxObjectListNode *GetPrevious() const                                                   { return (wxObjectListNode *)wxNodeBase::GetPrevious(); }                                                                                                   wxObject *GetData() const                                                              { return (wxObject *)wxNodeBase::GetData(); }                                  void SetData(wxObject *data)                                                           { wxNodeBase::SetData(data); }                                                                                                                  protected:                                                                      virtual void DeleteData();                                                                                                                              DECLARE_NO_COPY_CLASS(wxObjectListNode)                                         };                                                                                                                                                      class WXDLLIMPEXP_BASE wxObjectList : public wxListBase                                           {                                                                           public:                                                                         typedef wxObjectListNode Node;                                                      class WXDLLIMPEXP_BASE compatibility_iterator                                             {                                                                           public:                                                                         compatibility_iterator(Node *ptr = NULL) : m_ptr(ptr) { }                                                                                               Node *operator->() const { return m_ptr; }                                  operator Node *() const { return m_ptr; }                                                                                                           private:                                                                        Node *m_ptr;                                                            };                                                                                                                                                      wxObjectList(wxKeyType keyType = wxKEY_NONE) : wxListBase(keyType)                      { }                                                                     wxObjectList(const wxObjectList& list) : wxListBase(list.GetKeyType())                          { Assign(list); }                                                       wxObjectList(size_t count, wxObject *elements[])                                               : wxListBase(count, (void **)elements) { }                                                                                                          wxObjectList& operator=(const wxObjectList& list)                                               { if (&list != this) Assign(list); return *this; }                                                                                                  wxObjectListNode *GetFirst() const                                                      { return (wxObjectListNode *)wxListBase::GetFirst(); }                          wxObjectListNode *GetLast() const                                                       { return (wxObjectListNode *)wxListBase::GetLast(); }                                                                                                       wxObjectListNode *Item(size_t index) const                                              { return (wxObjectListNode *)wxListBase::Item(index); }                                                                                                     wxObject *operator[](size_t index) const                                           {                                                                               wxObjectListNode *node = Item(index);                                               return node ? (wxObject*)(node->GetData()) : NULL;                             }                                                                                                                                                       wxObjectListNode *Append(wxObject *object)                                                 { return (wxObjectListNode *)wxListBase::Append(object); }                      wxObjectListNode *Insert(wxObject *object)                                                 { return (wxObjectListNode *)Insert(static_cast<wxObjectListNode *>(NULL),                                              object); }                                  wxObjectListNode *Insert(size_t pos, wxObject *object)                                     { return (wxObjectListNode *)wxListBase::Insert(pos, object); }                 wxObjectListNode *Insert(wxObjectListNode *prev, wxObject *object)                                 { return (wxObjectListNode *)wxListBase::Insert(prev, object); }                                                                                            wxObjectListNode *Append(long key, void *object)                                        { return (wxObjectListNode *)wxListBase::Append(key, object); }                 wxObjectListNode *Append(const wxChar *key, void *object)                               { return (wxObjectListNode *)wxListBase::Append(key, object); }                                                                                             wxObjectListNode *DetachNode(wxObjectListNode *node)                                            { return (wxObjectListNode *)wxListBase::DetachNode(node); }                    bool DeleteNode(wxObjectListNode *node)                                                 { return wxListBase::DeleteNode(node); }                                bool DeleteObject(wxObject *object)                                                { return wxListBase::DeleteObject(object); }                            void Erase(wxObjectListNode *it)                                                        { DeleteNode(it); }                                                                                                                                 wxObjectListNode *Find(const wxObject *object) const                                       { return (wxObjectListNode *)wxListBase::Find(object); }                                                                                                    virtual wxObjectListNode *Find(const wxListKey& key) const                              { return (wxObjectListNode *)wxListBase::Find(key); }                                                                                                       bool Member(const wxObject *object) const                                          { return Find(object) != NULL; }                                                                                                                    int IndexOf(wxObject *object) const                                                { return wxListBase::IndexOf(object); }                                                                                                             void Sort(wxSortCompareFunction func)                                           { wxListBase::Sort(func); }                                             void Sort(wxSortFuncFor_wxObjectList func)                                            { Sort((wxSortCompareFunction)func); }                                                                                                          protected:                                                                      virtual wxNodeBase *CreateNode(wxNodeBase *prev, wxNodeBase *next,                                 void *data,                                                                 const wxListKey& key = wxDefaultListKey)                 {                                                                               return new wxObjectListNode(this,                                                                       (wxObjectListNode *)prev, (wxObjectListNode *)next,                                         (wxObject *)data, key);                                    }                                                                                                                             public:                                                                         typedef size_t size_type;                                                   typedef int difference_type;                                                typedef wxObject* value_type;                                                      typedef wxObject* base_value_type;                                             typedef value_type& reference;                                              typedef const value_type& const_reference;                                  typedef base_value_type& base_reference;                                    typedef const base_value_type& const_base_reference;                                                                                                    class WXDLLIMPEXP_BASE iterator                                                           {                                                                               typedef wxObjectList list;                                                      public:                                                                         typedef wxObjectListNode Node;                                                      typedef iterator itor;                                                      typedef wxObject* value_type;                                                      typedef value_type* ptr_type;                                               typedef value_type& reference;                                                                                                                          Node* m_node;                                                               Node* m_init;                                                           public:                                                                         typedef reference reference_type;                                           typedef ptr_type pointer_type;                                                                                                                          iterator(Node* node, Node* init) : m_node(node), m_init(init) {}            iterator() : m_node(NULL), m_init(NULL) { }                                 reference_type operator*() const                                                { return *(pointer_type)m_node->GetDataPtr(); }                                                                                                itor& operator++()                                                          {                                                                               wxASSERT_MSG( m_node, wxT("uninitialized iterator") );                      m_node = m_node->GetNext();                                                 return *this;                                                           }                                                                           const itor operator++(int)                                                  {                                                                               itor tmp = *this;                                                           wxASSERT_MSG( m_node, wxT("uninitialized iterator") );                      m_node = m_node->GetNext();                                                 return tmp;                                                             }                                                                           itor& operator--()                                                          {                                                                               m_node = m_node ? m_node->GetPrevious() : m_init;                           return *this;                                                           }                                                                           const itor operator--(int)                                                  {                                                                               itor tmp = *this;                                                           m_node = m_node ? m_node->GetPrevious() : m_init;                           return tmp;                                                             }                                                                           bool operator!=(const itor& it) const                                           { return it.m_node != m_node; }                                         bool operator==(const itor& it) const                                           { return it.m_node == m_node; }                                     };                                                                          class WXDLLIMPEXP_BASE const_iterator                                                     {                                                                               typedef wxObjectList list;                                                      public:                                                                         typedef wxObjectListNode Node;                                                      typedef wxObject* value_type;                                                      typedef const value_type& const_reference;                                  typedef const_iterator itor;                                                typedef value_type* ptr_type;                                                                                                                           Node* m_node;                                                               Node* m_init;                                                           public:                                                                         typedef const_reference reference_type;                                     typedef const ptr_type pointer_type;                                                                                                                    const_iterator(Node* node, Node* init)                                          : m_node(node), m_init(init) { }                                        const_iterator() : m_node(NULL), m_init(NULL) { }                           const_iterator(const iterator& it)                                              : m_node(it.m_node), m_init(it.m_init) { }                              reference_type operator*() const                                                { return *(pointer_type)m_node->GetDataPtr(); }                                                                                                itor& operator++()                                                          {                                                                               wxASSERT_MSG( m_node, wxT("uninitialized iterator") );                      m_node = m_node->GetNext();                                                 return *this;                                                           }                                                                           const itor operator++(int)                                                  {                                                                               itor tmp = *this;                                                           wxASSERT_MSG( m_node, wxT("uninitialized iterator") );                      m_node = m_node->GetNext();                                                 return tmp;                                                             }                                                                           itor& operator--()                                                          {                                                                               m_node = m_node ? m_node->GetPrevious() : m_init;                           return *this;                                                           }                                                                           const itor operator--(int)                                                  {                                                                               itor tmp = *this;                                                           m_node = m_node ? m_node->GetPrevious() : m_init;                           return tmp;                                                             }                                                                           bool operator!=(const itor& it) const                                           { return it.m_node != m_node; }                                         bool operator==(const itor& it) const                                           { return it.m_node == m_node; }                                     };                                                                          class WXDLLIMPEXP_BASE reverse_iterator                                                   {                                                                               typedef wxObjectList list;                                                      public:                                                                         typedef wxObjectListNode Node;                                                      typedef wxObject* value_type;                                                      typedef reverse_iterator itor;                                              typedef value_type* ptr_type;                                               typedef value_type& reference;                                                                                                                          Node* m_node;                                                               Node* m_init;                                                           public:                                                                         typedef reference reference_type;                                           typedef ptr_type pointer_type;                                                                                                                          reverse_iterator(Node* node, Node* init)                                        : m_node(node), m_init(init) { }                                        reverse_iterator() : m_node(NULL), m_init(NULL) { }                         reference_type operator*() const                                                { return *(pointer_type)m_node->GetDataPtr(); }                                                                                                itor& operator++()                                                              { m_node = m_node->GetPrevious(); return *this; }                       const itor operator++(int)                                                  { itor tmp = *this; m_node = m_node->GetPrevious(); return tmp; }            itor& operator--()                                                          { m_node = m_node ? m_node->GetNext() : m_init; return *this; }             const itor operator--(int)                                                  {                                                                               itor tmp = *this;                                                           m_node = m_node ? m_node->GetNext() : m_init;                               return tmp;                                                             }                                                                           bool operator!=(const itor& it) const                                           { return it.m_node != m_node; }                                         bool operator==(const itor& it) const                                           { return it.m_node == m_node; }                                     };                                                                          class WXDLLIMPEXP_BASE const_reverse_iterator                                             {                                                                               typedef wxObjectList list;                                                      public:                                                                         typedef wxObjectListNode Node;                                                      typedef wxObject* value_type;                                                      typedef const_reverse_iterator itor;                                        typedef value_type* ptr_type;                                               typedef const value_type& const_reference;                                                                                                              Node* m_node;                                                               Node* m_init;                                                           public:                                                                         typedef const_reference reference_type;                                     typedef const ptr_type pointer_type;                                                                                                                    const_reverse_iterator(Node* node, Node* init)                                  : m_node(node), m_init(init) { }                                        const_reverse_iterator() : m_node(NULL), m_init(NULL) { }                   const_reverse_iterator(const reverse_iterator& it)                              : m_node(it.m_node), m_init(it.m_init) { }                              reference_type operator*() const                                                { return *(pointer_type)m_node->GetDataPtr(); }                                                                                                itor& operator++()                                                              { m_node = m_node->GetPrevious(); return *this; }                       const itor operator++(int)                                                  { itor tmp = *this; m_node = m_node->GetPrevious(); return tmp; }            itor& operator--()                                                              { m_node = m_node ? m_node->GetNext() : m_init; return *this;}            const itor operator--(int)                                                  {                                                                               itor tmp = *this;                                                           m_node = m_node ? m_node->GetNext() : m_init;                               return tmp;                                                             }                                                                           bool operator!=(const itor& it) const                                           { return it.m_node != m_node; }                                         bool operator==(const itor& it) const                                           { return it.m_node == m_node; }                                     };                                                                                                                                                      wxEXPLICIT wxObjectList(size_type n, const_reference v = value_type())                  { assign(n, v); }                                                       wxObjectList(const const_iterator& first, const const_iterator& last)                   { assign(first, last); }                                                iterator begin() { return iterator(GetFirst(), GetLast()); }                const_iterator begin() const                                                    { return const_iterator(GetFirst(), GetLast()); }                       iterator end() { return iterator(NULL, GetLast()); }                        const_iterator end() const { return const_iterator(NULL, GetLast()); }        reverse_iterator rbegin()                                                       { return reverse_iterator(GetLast(), GetFirst()); }                     const_reverse_iterator rbegin() const                                           { return const_reverse_iterator(GetLast(), GetFirst()); }               reverse_iterator rend() { return reverse_iterator(NULL, GetFirst()); }        const_reverse_iterator rend() const                                             { return const_reverse_iterator(NULL, GetFirst()); }                    void resize(size_type n, value_type v = value_type())                       {                                                                               while (n < size())                                                              pop_back();                                                             while (n > size())                                                              push_back(v);                                                        }                                                                           size_type size() const { return GetCount(); }                               size_type max_size() const { return INT_MAX; }                              bool empty() const { return IsEmpty(); }                                    reference front() { return *begin(); }                                      const_reference front() const { return *begin(); }                          reference back() { iterator tmp = end(); return *--tmp; }                   const_reference back() const { const_iterator tmp = end(); return *--tmp; }        void push_front(const_reference v = value_type())                               { Insert(GetFirst(), (const_base_reference)v); }                        void pop_front() { DeleteNode(GetFirst()); }                                void push_back(const_reference v = value_type())                                { Append((const_base_reference)v); }                                    void pop_back() { DeleteNode(GetLast()); }                                  void assign(const_iterator first, const const_iterator& last)               {                                                                               clear();                                                                    for(; first != last; ++first)                                                   Append((const_base_reference)*first);                               }                                                                           void assign(size_type n, const_reference v = value_type())                  {                                                                               clear();                                                                    for(size_type i = 0; i < n; ++i)                                                Append((const_base_reference)v);                                    }                                                                           iterator insert(const iterator& it, const_reference v)                      {                                                                               if ( it == end() )                                                          {                                                                               Append((const_base_reference)v);                                                                                                                      iterator itins(end());                                                      return --itins;                                                         }                                                                           else                                                                        {                                                                               Insert(it.m_node, (const_base_reference)v);                                 iterator itins(it);                                                         return --itins;                                                         }                                                                       }                                                                           void insert(const iterator& it, size_type n, const_reference v)             {                                                                               for(size_type i = 0; i < n; ++i)                                                insert(it, v);                                                      }                                                                           void insert(const iterator& it,                                                         const_iterator first, const const_iterator& last)               {                                                                               for(; first != last; ++first)                                                   insert(it, *first);                                                 }                                                                           iterator erase(const iterator& it)                                          {                                                                               iterator next = iterator(it.m_node->GetNext(), GetLast());                  DeleteNode(it.m_node); return next;                                     }                                                                           iterator erase(const iterator& first, const iterator& last)                 {                                                                               iterator next = last;                                                       if ( next != end() )                                                            ++next;                                                                 DeleteNodes(first.m_node, last.m_node);                                     return next;                                                            }                                                                           void clear() { Clear(); }                                                   void splice(const iterator& it, wxObjectList& l, const iterator& first, const iterator& last)            { insert(it, first, last); l.erase(first, last); }                      void splice(const iterator& it, wxObjectList& l)                                        { splice(it, l, l.begin(), l.end() ); }                                 void splice(const iterator& it, wxObjectList& l, const iterator& first)             {                                                                               if ( it != first )                                                          {                                                                               insert(it, *first);                                                         l.erase(first);                                                         }                                                                       }                                                                           void remove(const_reference v)                                                  { DeleteObject((const_base_reference)v); }                              void reverse()                                                                  { Reverse(); }                                                                                                                            };

class WXDLLIMPEXP_BASE wxList : public wxObjectList
{
public:
                                                            
                
                                         
                           
    wxList(int key_type = wxKEY_NONE);
      

    // this destructor is required for Darwin
   ~wxList() { }

                         
    wxList& operator=(const wxList& list)
        { if (&list != this) Assign(list); return *this; }

    // compatibility methods
    void Sort(wxSortCompareFunction compfunc) { wxListBase::Sort(compfunc); }
       // !wxUSE_STD_CONTAINERS

                    
    template<typename T>
    wxVector<T> AsVector() const
    {
        wxVector<T> vector(size());
        size_t i = 0;

        for ( const_iterator it = begin(); it != end(); ++it )
        {
            vector[i++] = static_cast<T>(*it);
        }

        return vector;
    }
       // !__VISUALC6__

};

                         

// -----------------------------------------------------------------------------
// wxStringList class for compatibility with the old code
// -----------------------------------------------------------------------------
typedef int (*wxSortFuncFor_wxStringListBase)(const wxChar **, const wxChar **);                                                                                            class WXDLLIMPEXP_BASE wxStringListNode : public wxNodeBase                                       {                                                                           public:                                                                         wxStringListNode(wxListBase *list = NULL,                                                    wxStringListNode *previous = NULL,                                                  wxStringListNode *next = NULL,                                                      wxChar *data = NULL,                                                             const wxListKey& key = wxDefaultListKey)                               : wxNodeBase(list, previous, next, data, key) { }                                                                                                   wxStringListNode *GetNext() const                                                       { return (wxStringListNode *)wxNodeBase::GetNext(); }                           wxStringListNode *GetPrevious() const                                                   { return (wxStringListNode *)wxNodeBase::GetPrevious(); }                                                                                                   wxChar *GetData() const                                                              { return (wxChar *)wxNodeBase::GetData(); }                                  void SetData(wxChar *data)                                                           { wxNodeBase::SetData(data); }                                                                                                                  protected:                                                                      virtual void DeleteData();                                                                                                                              DECLARE_NO_COPY_CLASS(wxStringListNode)                                         };                                                                                                                                                      class WXDLLIMPEXP_BASE wxStringListBase : public wxListBase                                           {                                                                           public:                                                                         typedef wxStringListNode Node;                                                      class WXDLLIMPEXP_BASE compatibility_iterator                                             {                                                                           public:                                                                         compatibility_iterator(Node *ptr = NULL) : m_ptr(ptr) { }                                                                                               Node *operator->() const { return m_ptr; }                                  operator Node *() const { return m_ptr; }                                                                                                           private:                                                                        Node *m_ptr;                                                            };                                                                                                                                                      wxStringListBase(wxKeyType keyType = wxKEY_NONE) : wxListBase(keyType)                      { }                                                                     wxStringListBase(const wxStringListBase& list) : wxListBase(list.GetKeyType())                          { Assign(list); }                                                       wxStringListBase(size_t count, wxChar *elements[])                                               : wxListBase(count, (void **)elements) { }                                                                                                          wxStringListBase& operator=(const wxStringListBase& list)                                               { if (&list != this) Assign(list); return *this; }                                                                                                  wxStringListNode *GetFirst() const                                                      { return (wxStringListNode *)wxListBase::GetFirst(); }                          wxStringListNode *GetLast() const                                                       { return (wxStringListNode *)wxListBase::GetLast(); }                                                                                                       wxStringListNode *Item(size_t index) const                                              { return (wxStringListNode *)wxListBase::Item(index); }                                                                                                     wxChar *operator[](size_t index) const                                           {                                                                               wxStringListNode *node = Item(index);                                               return node ? (wxChar*)(node->GetData()) : NULL;                             }                                                                                                                                                       wxStringListNode *Append(wxChar *object)                                                 { return (wxStringListNode *)wxListBase::Append(object); }                      wxStringListNode *Insert(wxChar *object)                                                 { return (wxStringListNode *)Insert(static_cast<wxStringListNode *>(NULL),                                              object); }                                  wxStringListNode *Insert(size_t pos, wxChar *object)                                     { return (wxStringListNode *)wxListBase::Insert(pos, object); }                 wxStringListNode *Insert(wxStringListNode *prev, wxChar *object)                                 { return (wxStringListNode *)wxListBase::Insert(prev, object); }                                                                                            wxStringListNode *Append(long key, void *object)                                        { return (wxStringListNode *)wxListBase::Append(key, object); }                 wxStringListNode *Append(const wxChar *key, void *object)                               { return (wxStringListNode *)wxListBase::Append(key, object); }                                                                                             wxStringListNode *DetachNode(wxStringListNode *node)                                            { return (wxStringListNode *)wxListBase::DetachNode(node); }                    bool DeleteNode(wxStringListNode *node)                                                 { return wxListBase::DeleteNode(node); }                                bool DeleteObject(wxChar *object)                                                { return wxListBase::DeleteObject(object); }                            void Erase(wxStringListNode *it)                                                        { DeleteNode(it); }                                                                                                                                 wxStringListNode *Find(const wxChar *object) const                                       { return (wxStringListNode *)wxListBase::Find(object); }                                                                                                    virtual wxStringListNode *Find(const wxListKey& key) const                              { return (wxStringListNode *)wxListBase::Find(key); }                                                                                                       bool Member(const wxChar *object) const                                          { return Find(object) != NULL; }                                                                                                                    int IndexOf(wxChar *object) const                                                { return wxListBase::IndexOf(object); }                                                                                                             void Sort(wxSortCompareFunction func)                                           { wxListBase::Sort(func); }                                             void Sort(wxSortFuncFor_wxStringListBase func)                                            { Sort((wxSortCompareFunction)func); }                                                                                                          protected:                                                                      virtual wxNodeBase *CreateNode(wxNodeBase *prev, wxNodeBase *next,                                 void *data,                                                                 const wxListKey& key = wxDefaultListKey)                 {                                                                               return new wxStringListNode(this,                                                                       (wxStringListNode *)prev, (wxStringListNode *)next,                                         (wxChar *)data, key);                                    }                                                                                                                             public:                                                                         typedef size_t size_type;                                                   typedef int difference_type;                                                typedef wxChar* value_type;                                                      typedef wxChar* base_value_type;                                             typedef value_type& reference;                                              typedef const value_type& const_reference;                                  typedef base_value_type& base_reference;                                    typedef const base_value_type& const_base_reference;                                                                                                    class WXDLLIMPEXP_BASE iterator                                                           {                                                                               typedef wxStringListBase list;                                                      public:                                                                         typedef wxStringListNode Node;                                                      typedef iterator itor;                                                      typedef wxChar* value_type;                                                      typedef value_type* ptr_type;                                               typedef value_type& reference;                                                                                                                          Node* m_node;                                                               Node* m_init;                                                           public:                                                                         typedef reference reference_type;                                           typedef ptr_type pointer_type;                                                                                                                          iterator(Node* node, Node* init) : m_node(node), m_init(init) {}            iterator() : m_node(NULL), m_init(NULL) { }                                 reference_type operator*() const                                                { return *(pointer_type)m_node->GetDataPtr(); }                                                                                                itor& operator++()                                                          {                                                                               wxASSERT_MSG( m_node, wxT("uninitialized iterator") );                      m_node = m_node->GetNext();                                                 return *this;                                                           }                                                                           const itor operator++(int)                                                  {                                                                               itor tmp = *this;                                                           wxASSERT_MSG( m_node, wxT("uninitialized iterator") );                      m_node = m_node->GetNext();                                                 return tmp;                                                             }                                                                           itor& operator--()                                                          {                                                                               m_node = m_node ? m_node->GetPrevious() : m_init;                           return *this;                                                           }                                                                           const itor operator--(int)                                                  {                                                                               itor tmp = *this;                                                           m_node = m_node ? m_node->GetPrevious() : m_init;                           return tmp;                                                             }                                                                           bool operator!=(const itor& it) const                                           { return it.m_node != m_node; }                                         bool operator==(const itor& it) const                                           { return it.m_node == m_node; }                                     };                                                                          class WXDLLIMPEXP_BASE const_iterator                                                     {                                                                               typedef wxStringListBase list;                                                      public:                                                                         typedef wxStringListNode Node;                                                      typedef wxChar* value_type;                                                      typedef const value_type& const_reference;                                  typedef const_iterator itor;                                                typedef value_type* ptr_type;                                                                                                                           Node* m_node;                                                               Node* m_init;                                                           public:                                                                         typedef const_reference reference_type;                                     typedef const ptr_type pointer_type;                                                                                                                    const_iterator(Node* node, Node* init)                                          : m_node(node), m_init(init) { }                                        const_iterator() : m_node(NULL), m_init(NULL) { }                           const_iterator(const iterator& it)                                              : m_node(it.m_node), m_init(it.m_init) { }                              reference_type operator*() const                                                { return *(pointer_type)m_node->GetDataPtr(); }                                                                                                itor& operator++()                                                          {                                                                               wxASSERT_MSG( m_node, wxT("uninitialized iterator") );                      m_node = m_node->GetNext();                                                 return *this;                                                           }                                                                           const itor operator++(int)                                                  {                                                                               itor tmp = *this;                                                           wxASSERT_MSG( m_node, wxT("uninitialized iterator") );                      m_node = m_node->GetNext();                                                 return tmp;                                                             }                                                                           itor& operator--()                                                          {                                                                               m_node = m_node ? m_node->GetPrevious() : m_init;                           return *this;                                                           }                                                                           const itor operator--(int)                                                  {                                                                               itor tmp = *this;                                                           m_node = m_node ? m_node->GetPrevious() : m_init;                           return tmp;                                                             }                                                                           bool operator!=(const itor& it) const                                           { return it.m_node != m_node; }                                         bool operator==(const itor& it) const                                           { return it.m_node == m_node; }                                     };                                                                          class WXDLLIMPEXP_BASE reverse_iterator                                                   {                                                                               typedef wxStringListBase list;                                                      public:                                                                         typedef wxStringListNode Node;                                                      typedef wxChar* value_type;                                                      typedef reverse_iterator itor;                                              typedef value_type* ptr_type;                                               typedef value_type& reference;                                                                                                                          Node* m_node;                                                               Node* m_init;                                                           public:                                                                         typedef reference reference_type;                                           typedef ptr_type pointer_type;                                                                                                                          reverse_iterator(Node* node, Node* init)                                        : m_node(node), m_init(init) { }                                        reverse_iterator() : m_node(NULL), m_init(NULL) { }                         reference_type operator*() const                                                { return *(pointer_type)m_node->GetDataPtr(); }                                                                                                itor& operator++()                                                              { m_node = m_node->GetPrevious(); return *this; }                       const itor operator++(int)                                                  { itor tmp = *this; m_node = m_node->GetPrevious(); return tmp; }            itor& operator--()                                                          { m_node = m_node ? m_node->GetNext() : m_init; return *this; }             const itor operator--(int)                                                  {                                                                               itor tmp = *this;                                                           m_node = m_node ? m_node->GetNext() : m_init;                               return tmp;                                                             }                                                                           bool operator!=(const itor& it) const                                           { return it.m_node != m_node; }                                         bool operator==(const itor& it) const                                           { return it.m_node == m_node; }                                     };                                                                          class WXDLLIMPEXP_BASE const_reverse_iterator                                             {                                                                               typedef wxStringListBase list;                                                      public:                                                                         typedef wxStringListNode Node;                                                      typedef wxChar* value_type;                                                      typedef const_reverse_iterator itor;                                        typedef value_type* ptr_type;                                               typedef const value_type& const_reference;                                                                                                              Node* m_node;                                                               Node* m_init;                                                           public:                                                                         typedef const_reference reference_type;                                     typedef const ptr_type pointer_type;                                                                                                                    const_reverse_iterator(Node* node, Node* init)                                  : m_node(node), m_init(init) { }                                        const_reverse_iterator() : m_node(NULL), m_init(NULL) { }                   const_reverse_iterator(const reverse_iterator& it)                              : m_node(it.m_node), m_init(it.m_init) { }                              reference_type operator*() const                                                { return *(pointer_type)m_node->GetDataPtr(); }                                                                                                itor& operator++()                                                              { m_node = m_node->GetPrevious(); return *this; }                       const itor operator++(int)                                                  { itor tmp = *this; m_node = m_node->GetPrevious(); return tmp; }            itor& operator--()                                                              { m_node = m_node ? m_node->GetNext() : m_init; return *this;}            const itor operator--(int)                                                  {                                                                               itor tmp = *this;                                                           m_node = m_node ? m_node->GetNext() : m_init;                               return tmp;                                                             }                                                                           bool operator!=(const itor& it) const                                           { return it.m_node != m_node; }                                         bool operator==(const itor& it) const                                           { return it.m_node == m_node; }                                     };                                                                                                                                                      wxEXPLICIT wxStringListBase(size_type n, const_reference v = value_type())                  { assign(n, v); }                                                       wxStringListBase(const const_iterator& first, const const_iterator& last)                   { assign(first, last); }                                                iterator begin() { return iterator(GetFirst(), GetLast()); }                const_iterator begin() const                                                    { return const_iterator(GetFirst(), GetLast()); }                       iterator end() { return iterator(NULL, GetLast()); }                        const_iterator end() const { return const_iterator(NULL, GetLast()); }        reverse_iterator rbegin()                                                       { return reverse_iterator(GetLast(), GetFirst()); }                     const_reverse_iterator rbegin() const                                           { return const_reverse_iterator(GetLast(), GetFirst()); }               reverse_iterator rend() { return reverse_iterator(NULL, GetFirst()); }        const_reverse_iterator rend() const                                             { return const_reverse_iterator(NULL, GetFirst()); }                    void resize(size_type n, value_type v = value_type())                       {                                                                               while (n < size())                                                              pop_back();                                                             while (n > size())                                                              push_back(v);                                                        }                                                                           size_type size() const { return GetCount(); }                               size_type max_size() const { return INT_MAX; }                              bool empty() const { return IsEmpty(); }                                    reference front() { return *begin(); }                                      const_reference front() const { return *begin(); }                          reference back() { iterator tmp = end(); return *--tmp; }                   const_reference back() const { const_iterator tmp = end(); return *--tmp; }        void push_front(const_reference v = value_type())                               { Insert(GetFirst(), (const_base_reference)v); }                        void pop_front() { DeleteNode(GetFirst()); }                                void push_back(const_reference v = value_type())                                { Append((const_base_reference)v); }                                    void pop_back() { DeleteNode(GetLast()); }                                  void assign(const_iterator first, const const_iterator& last)               {                                                                               clear();                                                                    for(; first != last; ++first)                                                   Append((const_base_reference)*first);                               }                                                                           void assign(size_type n, const_reference v = value_type())                  {                                                                               clear();                                                                    for(size_type i = 0; i < n; ++i)                                                Append((const_base_reference)v);                                    }                                                                           iterator insert(const iterator& it, const_reference v)                      {                                                                               if ( it == end() )                                                          {                                                                               Append((const_base_reference)v);                                                                                                                      iterator itins(end());                                                      return --itins;                                                         }                                                                           else                                                                        {                                                                               Insert(it.m_node, (const_base_reference)v);                                 iterator itins(it);                                                         return --itins;                                                         }                                                                       }                                                                           void insert(const iterator& it, size_type n, const_reference v)             {                                                                               for(size_type i = 0; i < n; ++i)                                                insert(it, v);                                                      }                                                                           void insert(const iterator& it,                                                         const_iterator first, const const_iterator& last)               {                                                                               for(; first != last; ++first)                                                   insert(it, *first);                                                 }                                                                           iterator erase(const iterator& it)                                          {                                                                               iterator next = iterator(it.m_node->GetNext(), GetLast());                  DeleteNode(it.m_node); return next;                                     }                                                                           iterator erase(const iterator& first, const iterator& last)                 {                                                                               iterator next = last;                                                       if ( next != end() )                                                            ++next;                                                                 DeleteNodes(first.m_node, last.m_node);                                     return next;                                                            }                                                                           void clear() { Clear(); }                                                   void splice(const iterator& it, wxStringListBase& l, const iterator& first, const iterator& last)            { insert(it, first, last); l.erase(first, last); }                      void splice(const iterator& it, wxStringListBase& l)                                        { splice(it, l, l.begin(), l.end() ); }                                 void splice(const iterator& it, wxStringListBase& l, const iterator& first)             {                                                                               if ( it != first )                                                          {                                                                               insert(it, *first);                                                         l.erase(first);                                                         }                                                                       }                                                                           void remove(const_reference v)                                                  { DeleteObject((const_base_reference)v); }                              void reverse()                                                                  { Reverse(); }                                                                                                                            };

class WXDLLIMPEXP_BASE wxStringList : public wxStringListBase
{
public:
    // ctors and such
        // default
                             
                   
                                                                        
     
    wxStringList();
    wxStringList(const wxChar *first ...); // FIXME-UTF8
      

        // copying the string list: the strings are copied, too (extremely
        // inefficient!)
    wxStringList(const wxStringList& other) : wxStringListBase() { DeleteContents(true); DoCopy(other); }
    wxStringList& operator=(const wxStringList& other)
    {
        if (&other != this)
        {
            Clear();
            DoCopy(other);
        }
        return *this;
    }

    // operations
        // makes a copy of the string
    wxNode *Add(const wxChar *s);

        // Append to beginning of list
    wxNode *Prepend(const wxChar *s);

    bool Delete(const wxChar *s);

    wxChar **ListToArray(bool new_copies = false) const;
    bool Member(const wxChar *s) const;

    // alphabetic sort
    void Sort();

private:
    void DoCopy(const wxStringList&); // common part of copy ctor and operator=
};

                                

                                                                       

                                                             
 
       
                                            
                                                                               
                                            
                                                                               
                                                        
     
                         
                   
                                                  
     
                                               
                                           
                                                   
                                             
  

       // wxUSE_STD_CONTAINERS

       // wxLIST_COMPATIBILITY

// delete all list elements
//
// NB: the class declaration of the list elements must be visible from the
//     place where you use this macro, otherwise the proper destructor may not
//     be called (a decent compiler should give a warning about it, but don't
//     count on it)!
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   







// append all element of one list to another one
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     









       // _WX_LISTH__
