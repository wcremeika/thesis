
#__FILE__ _"C:\Users\Billy\Dropbox\Thesis\Projects\pwsafe-3.32-src\src\core\pugixml\pugixml.cpp" 0
/**
 * pugixml parser - version 1.2
 * --------------------------------------------------------
 * Copyright (C) 2006-2012, by Arseny Kapoulkine (arseny.kapoulkine@gmail.com)
 * Report bugs and download new versions at http://pugixml.org/
 *
 * This library is distributed under the MIT License. See notice at the end
 * of this file.
 *
 * This work is based on the pugxml parser, which is:
 * Copyright (C) 2003, by Kristen Wegner (kristen@tima.net)
 */

                          
                          

                     
#__FILE__ _"C:\Users\Billy\Dropbox\Thesis\Projects\pwsafe-3.32-src\src\core\pugixml\pugixml.hpp" 0
/**
 * pugixml parser - version 1.2
 * --------------------------------------------------------
 * Copyright (C) 2006-2012, by Arseny Kapoulkine (arseny.kapoulkine@gmail.com)
 * Report bugs and download new versions at http://pugixml.org/
 *
 * This library is distributed under the MIT License. See notice at the end
 * of this file.
 *
 * This work is based on the pugxml parser, which is:
 * Copyright (C) 2003, by Kristen Wegner (kristen@tima.net)
 */

                       
// Define version macro; evaluates to major * 100 + minor so that it's safe to use in less-than comparisons
                           
      

// Include user configuration file (this can define various configuration macros)
                        
#__FILE__ _"C:\Users\Billy\Dropbox\Thesis\Projects\pwsafe-3.32-src\src\core\pugixml\pugiconfig.hpp" 0
/**
 * pugixml parser - version 1.2
 * --------------------------------------------------------
 * Copyright (C) 2006-2012, by Arseny Kapoulkine (arseny.kapoulkine@gmail.com)
 * Report bugs and download new versions at http://pugixml.org/
 *
 * This library is distributed under the MIT License. See notice at the end
 * of this file.
 *
 * This work is based on the pugxml parser, which is:
 * Copyright (C) 2003, by Kristen Wegner (kristen@tima.net)
 */

/*
 *
 * Modified by DK for PasswordSafe
 * The ONLY changes are for this configuration:
 *  a. To place the definition of PUGIXML_WCHAR_MODE within a ifdef depending on UNICODE
 *  b. Disable XPath as we do not need it.
 *
 * NO changes made to the package's source files pugixml.cpp and pugixml.hpp
 *
 * The pugixml source corresponds to V1.2 @ rev. 916 - latest release as of 2012-05-02.
 * Official release of V1.2 @ rev. 914 on 2012-05-01.
 *
 */

                             
                             

// Uncomment this to enable wchar_t mode
              
                          
      

// Uncomment this to disable XPath
                        

// Uncomment this to disable STL
// #define PUGIXML_NO_STL

// Uncomment this to disable exceptions
// #define PUGIXML_NO_EXCEPTIONS

// Set this to control attributes for public classes/functions, i.e.:
// #define PUGIXML_API __declspec(dllexport) // to export all public symbols from DLL
// #define PUGIXML_CLASS __declspec(dllimport) // to import all classes from DLL
// #define PUGIXML_FUNCTION __fastcall // to set calling conventions to all public functions to fastcall
// In absence of PUGIXML_CLASS/PUGIXML_FUNCTION definitions PUGIXML_API is used instead

// Uncomment this to switch to header-only version
// #define PUGIXML_HEADER_ONLY
// #include "pugixml.cpp"

// Tune these constants to adjust memory-related behavior
// #define PUGIXML_MEMORY_PAGE_SIZE 32768
// #define PUGIXML_MEMORY_OUTPUT_STACK 10240
// #define PUGIXML_MEMORY_XPATH_PAGE_SIZE 4096

      

/**
 * Copyright (c) 2006-2012 Arseny Kapoulkine
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#__FILE__ _"C:\Users\Billy\Dropbox\Thesis\Projects\pwsafe-3.32-src\src\core\pugixml\pugixml.hpp" 24

                          
                          

// Include stddef.h for size_t and ptrdiff_t
                  

// Include exception header for XPath
                                                                 
                    
      

// Include STL headers
                      
                  
                
                
      

// Macro for deprecated features
                          
                     
                                                      
                                           
                                                 
     
                          
      
      

// If no API is defined, assume default
                   
                   
      

// If no API for classes is defined, assume default
                     
                                 
      

// If no API for functions is defined, assume default
                        
                                    
      

// Character interface macros
                         
                              
                            
     
                         
                         
      

namespace pugi
{
	// Character type used for all internal storage and operations; depends on PUGIXML_WCHAR_MODE
	typedef char char_t;

                      
	// String type used for operations that work with STL string; depends on PUGIXML_WCHAR_MODE
	typedef std::basic_string<char, std::char_traits<char>, std::allocator<char> > string_t;
      
}

// The PugiXML namespace
namespace pugi
{
	// Tree node types
	enum xml_node_type
	{
		node_null,			// Empty (null) node handle
		node_document,		// A document tree's absolute root
		node_element,		// Element tag, i.e. '<node/>'
		node_pcdata,		// Plain character data, i.e. 'text'
		node_cdata,			// Character data, i.e. '<![CDATA[text]]>'
		node_comment,		// Comment tag, i.e. '<!-- text -->'
		node_pi,			// Processing instruction, i.e. '<?name?>'
		node_declaration,	// Document declaration, i.e. '<?xml version="1.0"?>'
		node_doctype		// Document type declaration, i.e. '<!DOCTYPE doc>'
	};

	// Parsing options

	// Minimal parsing mode (equivalent to turning all other flags off).
	// Only elements and PCDATA sections are added to the DOM tree, no text conversions are performed.
	const unsigned int parse_minimal = 0x0000;

	// This flag determines if processing instructions (node_pi) are added to the DOM tree. This flag is off by default.
	const unsigned int parse_pi = 0x0001;

	// This flag determines if comments (node_comment) are added to the DOM tree. This flag is off by default.
	const unsigned int parse_comments = 0x0002;

	// This flag determines if CDATA sections (node_cdata) are added to the DOM tree. This flag is on by default.
	const unsigned int parse_cdata = 0x0004;

	// This flag determines if plain character data (node_pcdata) that consist only of whitespace are added to the DOM tree.
	// This flag is off by default; turning it on usually results in slower parsing and more memory consumption.
	const unsigned int parse_ws_pcdata = 0x0008;

	// This flag determines if character and entity references are expanded during parsing. This flag is on by default.
	const unsigned int parse_escapes = 0x0010;

	// This flag determines if EOL characters are normalized (converted to #xA) during parsing. This flag is on by default.
	const unsigned int parse_eol = 0x0020;
	
	// This flag determines if attribute values are normalized using CDATA normalization rules during parsing. This flag is on by default.
	const unsigned int parse_wconv_attribute = 0x0040;

	// This flag determines if attribute values are normalized using NMTOKENS normalization rules during parsing. This flag is off by default.
	const unsigned int parse_wnorm_attribute = 0x0080;
	
	// This flag determines if document declaration (node_declaration) is added to the DOM tree. This flag is off by default.
	const unsigned int parse_declaration = 0x0100;

	// This flag determines if document type declaration (node_doctype) is added to the DOM tree. This flag is off by default.
	const unsigned int parse_doctype = 0x0200;

	// This flag determines if plain character data (node_pcdata) that is the only child of the parent node and that consists only
	// of whitespace is added to the DOM tree.
	// This flag is off by default; turning it on may result in slower parsing and more memory consumption.
	const unsigned int parse_ws_pcdata_single = 0x0400;

	// The default parsing mode.
	// Elements, PCDATA and CDATA sections are added to the DOM tree, character/reference entities are expanded,
	// End-of-Line characters are normalized, attribute values are normalized using CDATA normalization rules.
	const unsigned int parse_default = parse_cdata | parse_escapes | parse_wconv_attribute | parse_eol;

	// The full parsing mode.
	// Nodes of all types are added to the DOM tree, character/reference entities are expanded,
	// End-of-Line characters are normalized, attribute values are normalized using CDATA normalization rules.
	const unsigned int parse_full = parse_default | parse_pi | parse_comments | parse_declaration | parse_doctype;

	// These flags determine the encoding of input data for XML document
	enum xml_encoding
	{
		encoding_auto,		// Auto-detect input encoding using BOM or < / <? detection; use UTF8 if BOM is not found
		encoding_utf8,		// UTF8 encoding
		encoding_utf16_le,	// Little-endian UTF16
		encoding_utf16_be,	// Big-endian UTF16
		encoding_utf16,		// UTF16 with native endianness
		encoding_utf32_le,	// Little-endian UTF32
		encoding_utf32_be,	// Big-endian UTF32
		encoding_utf32,		// UTF32 with native endianness
		encoding_wchar,		// The same encoding wchar_t has (either UTF16 or UTF32)
		encoding_latin1
	};

	// Formatting flags
	
	// Indent the nodes that are written to output stream with as many indentation strings as deep the node is in DOM tree. This flag is on by default.
	const unsigned int format_indent = 0x01;
	
	// Write encoding-specific BOM to the output stream. This flag is off by default.
	const unsigned int format_write_bom = 0x02;

	// Use raw output mode (no indentation and no line breaks are written). This flag is off by default.
	const unsigned int format_raw = 0x04;
	
	// Omit default XML declaration even if there is no declaration in the document. This flag is off by default.
	const unsigned int format_no_declaration = 0x08;

	// Don't escape attribute values and PCDATA contents. This flag is off by default.
	const unsigned int format_no_escapes = 0x10;

	// Open file using text mode in xml_document::save_file. This enables special character (i.e. new-line) conversions on some systems. This flag is off by default.
	const unsigned int format_save_file_text = 0x20;

	// The default set of formatting flags.
	// Nodes are indented depending on their depth in DOM tree, a default declaration is output if document has none.
	const unsigned int format_default = format_indent;
		
	// Forward declarations
	struct xml_attribute_struct;
	struct xml_node_struct;

	class xml_node_iterator;
	class xml_attribute_iterator;
	class xml_named_node_iterator;

	class xml_tree_walker;

	class xml_node;

	class xml_text;
	
	                        
	                 
	                     
	                  
	                         
	      

	// Range-based for loop support
	template <typename It> class xml_object_range
	{
	public:
		typedef It const_iterator;

		xml_object_range(It b, It e): _begin(b), _end(e)
		{
		}

		It begin() const { return _begin; }
		It end() const { return _end; }

	private:
		It _begin, _end;
	};

	// Writer interface for node printing (see xml_node::print)
	class  xml_writer
	{
	public:
		virtual ~xml_writer() {}

		// Write memory chunk into stream/file/whatever
		virtual void write(const void* data, size_t size) = 0;
	};

	// xml_writer implementation for FILE*
	class  xml_writer_file: public xml_writer
	{
	public:
		// Construct writer from a FILE* object; void* is used to avoid header dependencies on stdio
		xml_writer_file(void* file);

		virtual void write(const void* data, size_t size);

	private:
		void* file;
	};

	                      
	// xml_writer implementation for streams
	class  xml_writer_stream: public xml_writer
	{
	public:
		// Construct writer from an output stream object
		xml_writer_stream(std::basic_ostream<char, std::char_traits<char> >& stream);
		xml_writer_stream(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& stream);

		virtual void write(const void* data, size_t size);

	private:
		std::basic_ostream<char, std::char_traits<char> >* narrow_stream;
		std::basic_ostream<wchar_t, std::char_traits<wchar_t> >* wide_stream;
	};
	      

	// A light-weight handle for manipulating attributes in DOM tree
	class  xml_attribute
	{
		friend class xml_attribute_iterator;
		friend class xml_node;

	private:
		xml_attribute_struct* _attr;
	
		typedef void (*unspecified_bool_type)(xml_attribute***);

	public:
		// Default constructor. Constructs an empty attribute.
		xml_attribute();
		
		// Constructs attribute from internal pointer
		explicit xml_attribute(xml_attribute_struct* attr);

		// Safe bool conversion operator
		operator unspecified_bool_type() const;

		// Borland C++ workaround
		bool operator!() const;

		// Comparison operators (compares wrapped attribute pointers)
		bool operator==(const xml_attribute& r) const;
		bool operator!=(const xml_attribute& r) const;
		bool operator<(const xml_attribute& r) const;
		bool operator>(const xml_attribute& r) const;
		bool operator<=(const xml_attribute& r) const;
		bool operator>=(const xml_attribute& r) const;

		// Check if attribute is empty
		bool empty() const;

		// Get attribute name/value, or "" if attribute is empty
		const char_t* name() const;
		const char_t* value() const;

		// Get attribute value, or the default value if attribute is empty
		const char_t* as_string(const char_t* def = "") const;

		// Get attribute value as a number, or the default value if conversion did not succeed or attribute is empty
		int as_int(int def = 0) const;
		unsigned int as_uint(unsigned int def = 0) const;
		double as_double(double def = 0) const;
		float as_float(float def = 0) const;

		// Get attribute value as bool (returns true if first character is in '1tTyY' set), or the default value if attribute is empty
		bool as_bool(bool def = false) const;

		// Set attribute name/value (returns false if attribute is empty or there is not enough memory)
		bool set_name(const char_t* rhs);
		bool set_value(const char_t* rhs);

		// Set attribute value with type conversion (numbers are converted to strings, boolean is converted to "true"/"false")
		bool set_value(int rhs);
		bool set_value(unsigned int rhs);
		bool set_value(double rhs);
		bool set_value(bool rhs);

		// Set attribute value (equivalent to set_value without error checking)
		xml_attribute& operator=(const char_t* rhs);
		xml_attribute& operator=(int rhs);
		xml_attribute& operator=(unsigned int rhs);
		xml_attribute& operator=(double rhs);
		xml_attribute& operator=(bool rhs);

		// Get next/previous attribute in the attribute list of the parent node
		xml_attribute next_attribute() const;
		xml_attribute previous_attribute() const;

		// Get hash value (unique for handles to the same object)
		size_t hash_value() const;

		// Get internal pointer
		xml_attribute_struct* internal_object() const;
	};

                   
	                         
	                                                                     
	                                                                     
      

	// A light-weight handle for manipulating nodes in DOM tree
	class  xml_node
	{
		friend class xml_attribute_iterator;
		friend class xml_node_iterator;
		friend class xml_named_node_iterator;

	protected:
		xml_node_struct* _root;

		typedef void (*unspecified_bool_type)(xml_node***);

	public:
		// Default constructor. Constructs an empty node.
		xml_node();

		// Constructs node from internal pointer
		explicit xml_node(xml_node_struct* p);

		// Safe bool conversion operator
		operator unspecified_bool_type() const;

		// Borland C++ workaround
		bool operator!() const;
	
		// Comparison operators (compares wrapped node pointers)
		bool operator==(const xml_node& r) const;
		bool operator!=(const xml_node& r) const;
		bool operator<(const xml_node& r) const;
		bool operator>(const xml_node& r) const;
		bool operator<=(const xml_node& r) const;
		bool operator>=(const xml_node& r) const;

		// Check if node is empty.
		bool empty() const;

		// Get node type
		xml_node_type type() const;

		// Get node name/value, or "" if node is empty or it has no name/value
		const char_t* name() const;
		const char_t* value() const;
	
		// Get attribute list
		xml_attribute first_attribute() const;
		xml_attribute last_attribute() const;

		// Get children list
		xml_node first_child() const;
		xml_node last_child() const;

		// Get next/previous sibling in the children list of the parent node
		xml_node next_sibling() const;
		xml_node previous_sibling() const;
		
		// Get parent node
		xml_node parent() const;

		// Get root of DOM tree this node belongs to
		xml_node root() const;

		// Get text object for the current node
		xml_text text() const;

		// Get child, attribute or next/previous sibling with the specified name
		xml_node child(const char_t* name) const;
		xml_attribute attribute(const char_t* name) const;
		xml_node next_sibling(const char_t* name) const;
		xml_node previous_sibling(const char_t* name) const;

		// Get child value of current node; that is, value of the first child node of type PCDATA/CDATA
		const char_t* child_value() const;

		// Get child value of child with specified name. Equivalent to child(name).child_value().
		const char_t* child_value(const char_t* name) const;

		// Set node name/value (returns false if node is empty, there is not enough memory, or node can not have name/value)
		bool set_name(const char_t* rhs);
		bool set_value(const char_t* rhs);
		
		// Add attribute with specified name. Returns added attribute, or empty attribute on errors.
		xml_attribute append_attribute(const char_t* name);
		xml_attribute prepend_attribute(const char_t* name);
		xml_attribute insert_attribute_after(const char_t* name, const xml_attribute& attr);
		xml_attribute insert_attribute_before(const char_t* name, const xml_attribute& attr);

		// Add a copy of the specified attribute. Returns added attribute, or empty attribute on errors.
		xml_attribute append_copy(const xml_attribute& proto);
		xml_attribute prepend_copy(const xml_attribute& proto);
		xml_attribute insert_copy_after(const xml_attribute& proto, const xml_attribute& attr);
		xml_attribute insert_copy_before(const xml_attribute& proto, const xml_attribute& attr);

		// Add child node with specified type. Returns added node, or empty node on errors.
		xml_node append_child(xml_node_type type = node_element);
		xml_node prepend_child(xml_node_type type = node_element);
		xml_node insert_child_after(xml_node_type type, const xml_node& node);
		xml_node insert_child_before(xml_node_type type, const xml_node& node);

		// Add child element with specified name. Returns added node, or empty node on errors.
		xml_node append_child(const char_t* name);
		xml_node prepend_child(const char_t* name);
		xml_node insert_child_after(const char_t* name, const xml_node& node);
		xml_node insert_child_before(const char_t* name, const xml_node& node);

		// Add a copy of the specified node as a child. Returns added node, or empty node on errors.
		xml_node append_copy(const xml_node& proto);
		xml_node prepend_copy(const xml_node& proto);
		xml_node insert_copy_after(const xml_node& proto, const xml_node& node);
		xml_node insert_copy_before(const xml_node& proto, const xml_node& node);

		// Remove specified attribute
		bool remove_attribute(const xml_attribute& a);
		bool remove_attribute(const char_t* name);

		// Remove specified child
		bool remove_child(const xml_node& n);
		bool remove_child(const char_t* name);

		// Find attribute using predicate. Returns first attribute for which predicate returned true.
		template <typename Predicate> xml_attribute find_attribute(Predicate pred) const
		{
			if (!_root) return xml_attribute();
			
			for (xml_attribute attrib = first_attribute(); attrib; attrib = attrib.next_attribute())
				if (pred(attrib))
					return attrib;
		
			return xml_attribute();
		}

		// Find child node using predicate. Returns first child for which predicate returned true.
		template <typename Predicate> xml_node find_child(Predicate pred) const
		{
			if (!_root) return xml_node();
	
			for (xml_node node = first_child(); node; node = node.next_sibling())
				if (pred(node))
					return node;
		
			return xml_node();
		}

		// Find node from subtree using predicate. Returns first node from subtree (depth-first), for which predicate returned true.
		template <typename Predicate> xml_node find_node(Predicate pred) const
		{
			if (!_root) return xml_node();

			xml_node cur = first_child();
			
			while (cur._root && cur._root != _root)
			{
				if (pred(cur)) return cur;

				if (cur.first_child()) cur = cur.first_child();
				else if (cur.next_sibling()) cur = cur.next_sibling();
				else
				{
					while (!cur.next_sibling() && cur._root != _root) cur = cur.parent();

					if (cur._root != _root) cur = cur.next_sibling();
				}
			}

			return xml_node();
		}

		// Find child node by attribute name/value
		xml_node find_child_by_attribute(const char_t* name, const char_t* attr_name, const char_t* attr_value) const;
		xml_node find_child_by_attribute(const char_t* attr_name, const char_t* attr_value) const;

	                      
		// Get the absolute node path from root as a text string.
		string_t path(char_t delimiter = '/') const;
	      

		// Search for a node by path consisting of node names and . or .. elements.
		xml_node first_element_by_path(const char_t* path, char_t delimiter = '/') const;

		// Recursively traverse subtree with xml_tree_walker
		bool traverse(xml_tree_walker& walker);
	
	                        
		                                                                                                
		                                                                                            
		                                                              

		                                            
		                                                                                          
		                                                            
	      
		
		// Print subtree using a writer object
		void print(xml_writer& writer, const char_t* indent = "\t", unsigned int flags = format_default, xml_encoding encoding = encoding_auto, unsigned int depth = 0) const;

	                      
		// Print subtree to stream
		void print(std::basic_ostream<char, std::char_traits<char> >& os, const char_t* indent = "\t", unsigned int flags = format_default, xml_encoding encoding = encoding_auto, unsigned int depth = 0) const;
		void print(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& os, const char_t* indent = "\t", unsigned int flags = format_default, unsigned int depth = 0) const;
	      

		// Child nodes iterators
		typedef xml_node_iterator iterator;

		iterator begin() const;
		iterator end() const;

		// Attribute iterators
		typedef xml_attribute_iterator attribute_iterator;

		attribute_iterator attributes_begin() const;
		attribute_iterator attributes_end() const;

		// Range-based for support
		xml_object_range<xml_node_iterator> children() const;
		xml_object_range<xml_named_node_iterator> children(const char_t* name) const;
		xml_object_range<xml_attribute_iterator> attributes() const;

		// Get node offset in parsed file/string (in char_t units) for debugging purposes
		ptrdiff_t offset_debug() const;

		// Get hash value (unique for handles to the same object)
		size_t hash_value() const;

		// Get internal pointer
		xml_node_struct* internal_object() const;
	};

                   
	                         
	                                                                
	                                                                
      

	// A helper for working with text inside PCDATA nodes
	class  xml_text
	{
		friend class xml_node;

		xml_node_struct* _root;

		typedef void (*unspecified_bool_type)(xml_text***);

		explicit xml_text(xml_node_struct* root);

		xml_node_struct* _data_new();
		xml_node_struct* _data() const;

	public:
		// Default constructor. Constructs an empty object.
		xml_text();

		// Safe bool conversion operator
		operator unspecified_bool_type() const;

		// Borland C++ workaround
		bool operator!() const;

		// Check if text object is empty
		bool empty() const;

		// Get text, or "" if object is empty
		const char_t* get() const;

		// Get text, or the default value if object is empty
		const char_t* as_string(const char_t* def = "") const;

		// Get text as a number, or the default value if conversion did not succeed or object is empty
		int as_int(int def = 0) const;
		unsigned int as_uint(unsigned int def = 0) const;
		double as_double(double def = 0) const;
		float as_float(float def = 0) const;

		// Get text as bool (returns true if first character is in '1tTyY' set), or the default value if object is empty
		bool as_bool(bool def = false) const;

		// Set text (returns false if object is empty or there is not enough memory)
		bool set(const char_t* rhs);

		// Set text with type conversion (numbers are converted to strings, boolean is converted to "true"/"false")
		bool set(int rhs);
		bool set(unsigned int rhs);
		bool set(double rhs);
		bool set(bool rhs);

		// Set text (equivalent to set without error checking)
		xml_text& operator=(const char_t* rhs);
		xml_text& operator=(int rhs);
		xml_text& operator=(unsigned int rhs);
		xml_text& operator=(double rhs);
		xml_text& operator=(bool rhs);

		// Get the data node (node_pcdata or node_cdata) for this object
		xml_node data() const;
	};

                   
	                         
	                                                                
	                                                                
      

	// Child node iterator (a bidirectional iterator over a collection of xml_node)
	class  xml_node_iterator
	{
		friend class xml_node;

	private:
		mutable xml_node _wrap;
		xml_node _parent;

		xml_node_iterator(xml_node_struct* ref, xml_node_struct* parent);

	public:
		// Iterator traits
		typedef ptrdiff_t difference_type;
		typedef xml_node value_type;
		typedef xml_node* pointer;
		typedef xml_node& reference;

	                      
		typedef std::bidirectional_iterator_tag iterator_category;
	      

		// Default constructor
		xml_node_iterator();

		// Construct an iterator which points to the specified node
		xml_node_iterator(const xml_node& node);

		// Iterator operators
		bool operator==(const xml_node_iterator& rhs) const;
		bool operator!=(const xml_node_iterator& rhs) const;

		xml_node& operator*() const;
		xml_node* operator->() const;

		const xml_node_iterator& operator++();
		xml_node_iterator operator++(int);

		const xml_node_iterator& operator--();
		xml_node_iterator operator--(int);
	};

	// Attribute iterator (a bidirectional iterator over a collection of xml_attribute)
	class  xml_attribute_iterator
	{
		friend class xml_node;

	private:
		mutable xml_attribute _wrap;
		xml_node _parent;

		xml_attribute_iterator(xml_attribute_struct* ref, xml_node_struct* parent);

	public:
		// Iterator traits
		typedef ptrdiff_t difference_type;
		typedef xml_attribute value_type;
		typedef xml_attribute* pointer;
		typedef xml_attribute& reference;

	                      
		typedef std::bidirectional_iterator_tag iterator_category;
	      

		// Default constructor
		xml_attribute_iterator();

		// Construct an iterator which points to the specified attribute
		xml_attribute_iterator(const xml_attribute& attr, const xml_node& parent);

		// Iterator operators
		bool operator==(const xml_attribute_iterator& rhs) const;
		bool operator!=(const xml_attribute_iterator& rhs) const;

		xml_attribute& operator*() const;
		xml_attribute* operator->() const;

		const xml_attribute_iterator& operator++();
		xml_attribute_iterator operator++(int);

		const xml_attribute_iterator& operator--();
		xml_attribute_iterator operator--(int);
	};

	// Named node range helper
	class xml_named_node_iterator
	{
	public:
		// Iterator traits
		typedef ptrdiff_t difference_type;
		typedef xml_node value_type;
		typedef xml_node* pointer;
		typedef xml_node& reference;

	                      
		typedef std::forward_iterator_tag iterator_category;
	      

		// Default constructor
		xml_named_node_iterator();

		// Construct an iterator which points to the specified node
		xml_named_node_iterator(const xml_node& node, const char_t* name);

		// Iterator operators
		bool operator==(const xml_named_node_iterator& rhs) const;
		bool operator!=(const xml_named_node_iterator& rhs) const;

		xml_node& operator*() const;
		xml_node* operator->() const;

		const xml_named_node_iterator& operator++();
		xml_named_node_iterator operator++(int);

	private:
		mutable xml_node _node;
		const char_t* _name;
	};

	// Abstract tree walker class (see xml_node::traverse)
	class  xml_tree_walker
	{
		friend class xml_node;

	private:
		int _depth;
	
	protected:
		// Get current traversal depth
		int depth() const;
	
	public:
		xml_tree_walker();
		virtual ~xml_tree_walker();

		// Callback that is called when traversal begins
		virtual bool begin(xml_node& node);

		// Callback that is called for each node traversed
		virtual bool for_each(xml_node& node) = 0;

		// Callback that is called when traversal ends
		virtual bool end(xml_node& node);
	};

	// Parsing status, returned as part of xml_parse_result object
	enum xml_parse_status
	{
		status_ok = 0,				// No error

		status_file_not_found,		// File was not found during load_file()
		status_io_error,			// Error reading from file/stream
		status_out_of_memory,		// Could not allocate memory
		status_internal_error,		// Internal error occurred

		status_unrecognized_tag,	// Parser could not determine tag type

		status_bad_pi,				// Parsing error occurred while parsing document declaration/processing instruction
		status_bad_comment,			// Parsing error occurred while parsing comment
		status_bad_cdata,			// Parsing error occurred while parsing CDATA section
		status_bad_doctype,			// Parsing error occurred while parsing document type declaration
		status_bad_pcdata,			// Parsing error occurred while parsing PCDATA section
		status_bad_start_element,	// Parsing error occurred while parsing start element tag
		status_bad_attribute,		// Parsing error occurred while parsing element attribute
		status_bad_end_element,		// Parsing error occurred while parsing end element tag
		status_end_element_mismatch // There was a mismatch of start-end tags (closing tag had incorrect name, some tag was not closed or there was an excessive closing tag)
	};

	// Parsing result
	struct  xml_parse_result
	{
		// Parsing status (see xml_parse_status)
		xml_parse_status status;

		// Last parsed offset (in char_t units from start of input data)
		ptrdiff_t offset;

		// Source document encoding
		xml_encoding encoding;

		// Default constructor, initializes object to failed state
		xml_parse_result();

		// Cast to bool operator
		operator bool() const;

		// Get error description
		const char* description() const;
	};

	// Document class (DOM tree root)
	class  xml_document: public xml_node
	{
	private:
		char_t* _buffer;

		char _memory[192];
		
		// Non-copyable semantics
		xml_document(const xml_document&);
		const xml_document& operator=(const xml_document&);

		void create();
		void destroy();

		xml_parse_result load_buffer_impl(void* contents, size_t size, unsigned int options, xml_encoding encoding, bool is_mutable, bool own);

	public:
		// Default constructor, makes empty document
		xml_document();

		// Destructor, invalidates all node/attribute handles to this document
		~xml_document();

		// Removes all nodes, leaving the empty document
		void reset();

		// Removes all nodes, then copies the entire contents of the specified document
		void reset(const xml_document& proto);

	                      
		// Load document from stream.
		xml_parse_result load(std::basic_istream<char, std::char_traits<char> >& stream, unsigned int options = parse_default, xml_encoding encoding = encoding_auto);
		xml_parse_result load(std::basic_istream<wchar_t, std::char_traits<wchar_t> >& stream, unsigned int options = parse_default);
	      

		// Load document from zero-terminated string. No encoding conversions are applied.
		xml_parse_result load(const char_t* contents, unsigned int options = parse_default);

		// Load document from file
		xml_parse_result load_file(const char* path, unsigned int options = parse_default, xml_encoding encoding = encoding_auto);
		xml_parse_result load_file(const wchar_t* path, unsigned int options = parse_default, xml_encoding encoding = encoding_auto);

		// Load document from buffer. Copies/converts the buffer, so it may be deleted or changed after the function returns.
		xml_parse_result load_buffer(const void* contents, size_t size, unsigned int options = parse_default, xml_encoding encoding = encoding_auto);

		// Load document from buffer, using the buffer for in-place parsing (the buffer is modified and used for storage of document data).
		// You should ensure that buffer data will persist throughout the document's lifetime, and free the buffer memory manually once document is destroyed.
		xml_parse_result load_buffer_inplace(void* contents, size_t size, unsigned int options = parse_default, xml_encoding encoding = encoding_auto);

		// Load document from buffer, using the buffer for in-place parsing (the buffer is modified and used for storage of document data).
		// You should allocate the buffer with pugixml allocation function; document will free the buffer when it is no longer needed (you can't use it anymore).
		xml_parse_result load_buffer_inplace_own(void* contents, size_t size, unsigned int options = parse_default, xml_encoding encoding = encoding_auto);

		// Save XML document to writer (semantics is slightly different from xml_node::print, see documentation for details).
		void save(xml_writer& writer, const char_t* indent = "\t", unsigned int flags = format_default, xml_encoding encoding = encoding_auto) const;

	                      
		// Save XML document to stream (semantics is slightly different from xml_node::print, see documentation for details).
		void save(std::basic_ostream<char, std::char_traits<char> >& stream, const char_t* indent = "\t", unsigned int flags = format_default, xml_encoding encoding = encoding_auto) const;
		void save(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& stream, const char_t* indent = "\t", unsigned int flags = format_default) const;
	      

		// Save XML to file
		bool save_file(const char* path, const char_t* indent = "\t", unsigned int flags = format_default, xml_encoding encoding = encoding_auto) const;
		bool save_file(const wchar_t* path, const char_t* indent = "\t", unsigned int flags = format_default, xml_encoding encoding = encoding_auto) const;

		// Get document element
		xml_node document_element() const;
	};

                        
	                          
	                     
	 
		                	                                           
		                                                  
		                  	           
		                  	           
		                  	            
	  

	                       
	                                       
	 
		                                
		                  

		                                                         
		                 

		                                                          
		                     

		                        
		                      

		                        
		                                
	  

	                          
	                                  
	 
		                                

	          
		                       
		                      

		                 

		                         
		                                      
		                                                 
		
	       
		                    
		                           

		                    
		                              

		                                                                                                                                                   
		                         
		                          
		                                 
		                                           

		                                                                                                
		                     
		                       
		                              
		                                      
	  

	                           
	                                      
	 
	        
		                          

		                         
		                                              
		                                                         

		                                               

	       
		                                 
		                     
		                      

		                                                                 
		                                                               

		                                                                                                                                          
		                                         
		                                           
		                                                  
		                                                          

		                                
		                                        
		                                                    
	  

	                                
	                               
	 
	        
		            
		                           

		                                                      

		                         
		                                
		                                           

	       
		                                                     
		                                                                                         
		                                                                             

		             
		               

		                                   
		                                     
		
		                                                                                                        
		                                                                                          
		                                                 
		
		                                                                                                       
		                                                                                          
		                                                  
		
	                      
		                                                                                                       
		                                                                                          
		                                                    
	      
		
		                                                                                                       
		                                                                                                                               
		                                                                                          
		                                                                   
		                                                                                   

		                                                            
		                                                                                                                               
		                                                                       
		                                                            

		                                                                                    
		                                         

		                                
		                                       

		                         
		                       
	  
	
	                             
	                        
	                                                          
	 
	        
		                           

	       
		                                        
		                                                           

		                    
		                                         

		                   
		                                         
	  
	      
	
	                                                      
	                              
	 
	        
		               
		                         
	
		                                                     

	       
		                                                   
		             
		
		                                               
		                                 
		                                                                   

		                             
		                      
		                                
		
		                                         
		                        

		                                
		                                       
		
		                         
		                       

		                       
		                                           
		                                           
	  

                   
	                         
	                                                                  
	                                                                  
      

	                                         
	                                  
	 
	       
		                  
		           
		 
			              			              
			            			                                       
			                   		                                        
		  
		
		                         
		                                         
	
		                                             
		                 

		                                                                                                                                       
		                                                                                      

		             
		                  
		
		                                       
		                                         
		                                                    

		                      
		                    
		
		                      
		                    

		                    
		                                                 
		
		                       
		                             
		                           

		                                                                      
		                                
		
		                                                     
		                         
		
		                               
		                   
	
	        
		             
		
		                    
		
		                   
		                 

		                                                       
	  
      

                      
	// Convert wide string to UTF8
	std::basic_string<char, std::char_traits<char>, std::allocator<char> >  as_utf8(const wchar_t* str);
	std::basic_string<char, std::char_traits<char>, std::allocator<char> >  as_utf8(const std::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >& str);
	
	// Convert UTF8 to wide string
	std::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >  as_wide(const char* str);
	std::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >  as_wide(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >& str);
      

	// Memory allocation function interface; returns pointer to allocated memory or NULL on failure
	typedef void* (*allocation_function)(size_t size);
	
	// Memory deallocation function interface
	typedef void (*deallocation_function)(void* ptr);

	// Override default memory management functions. All subsequent allocations/deallocations will be performed via supplied functions.
	void  set_memory_management_functions(allocation_function allocate, deallocation_function deallocate);
	
	// Get current memory management functions
	allocation_function  get_memory_allocation_function();
	deallocation_function  get_memory_deallocation_function();
}

                                                                     
             
 
	                                                                                                        
	                                                                                           
	                                                                                                
	                                                                                           
 
      

                                                    
             
 
	                                                             
	                                                                                                     
	                                                                                                          
	                                                                                                     
 
      

      

/**
 * Copyright (c) 2006-2012 Arseny Kapoulkine
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#__FILE__ _"C:\Users\Billy\Dropbox\Thesis\Projects\pwsafe-3.32-src\src\core\pugixml\pugixml.cpp" 17

                  
                 
                  
                  
                 

                        
                 
                  
                            
                   
      
      

                      
                 
                 
                
      

// For placement new
             

               
       
       
       
       
       
       
       
      

                       
       
       
       
       
      

                                                         
       
      

                   
       
       
       
      

              
                                                                                                
       
       
      

// Inlining controls
                                         
                                            
                       
                                                 
     
                        
      

// Simple static assertion
                                                                                                                           

// Digital Mars C++ bug workaround for passing char loaded from memory via stack
              
                                   
     
                          
      

// Borland C++ bug workaround for not defining ::memcpy depending on header include order (can't always use std::memcpy because some compilers don't have it at all)
                                                         
                  
                   
      

// In some environments MSVC is a compiler but the CRT lacks certain MSVC-specific features
                                          
                                       
      

                          
                                                        
                        
                       
                                 
     
                                                                                                                          
                                                        
                        
     
                                                                    
                          
      
                
                                          
      

// uintptr_t
                                          
                  
     
                          
                                                          
                         
                          
      
              
	                                
	                                  
	                                  
            
      

// Memory allocation
namespace pugi { namespace impl { namespace {
	 void* default_allocate(size_t size)
	{
		return malloc(size);
	}

	 void default_deallocate(void* ptr)
	{
		free(ptr);
	}

	template <typename T>
	struct xml_memory_management_function_storage
	{
		static allocation_function allocate;
		static deallocation_function deallocate;
	};

	template <typename T> allocation_function xml_memory_management_function_storage<T>::allocate = default_allocate;
	template <typename T> deallocation_function xml_memory_management_function_storage<T>::deallocate = default_deallocate;

	typedef xml_memory_management_function_storage<int> xml_memory;
} } }

// String utilities
namespace pugi { namespace impl { namespace {
	// Get string length
	 size_t strlength(const char_t* s)
	{
		assert(s);

	                         
		                 
	     
		return strlen(s);
	      
	}

	// Compare two strings
	 bool strequal(const char_t* src, const char_t* dst)
	{
		assert(src && dst);

	                         
		                             
	     
		return strcmp(src, dst) == 0;
	      
	}

	// Compare lhs with [rhs_begin, rhs_end)
	 bool strequalrange(const char_t* lhs, const char_t* rhs, size_t count)
	{
		for (size_t i = 0; i < count; ++i)
			if (lhs[i] != rhs[i])
				return false;
	
		return lhs[count] == 0;
	}
	
                         
	                                                                
	                                                            
	 
		                                                   
		          
	 
      
} } }

                                                          
// auto_ptr-like buffer holder for exception recovery
namespace pugi { namespace impl { namespace {
	struct buffer_holder
	{
		void* data;
		void (*deleter)(void*);

		buffer_holder(void* data_, void (*deleter_)(void*)): data(data_), deleter(deleter_)
		{
		}

		~buffer_holder()
		{
			if (data) deleter(data);
		}

		void* release()
		{
			void* result = data;
			data = 0;
			return result;
		}
	};
} } }
      

namespace pugi { namespace impl { namespace {
	static const size_t xml_memory_page_size =
	                               
		                        
	     
		32768
	      
		;

	static const uintptr_t xml_memory_page_alignment = 32;
	static const uintptr_t xml_memory_page_pointer_mask = ~(xml_memory_page_alignment - 1);
	static const uintptr_t xml_memory_page_name_allocated_mask = 16;
	static const uintptr_t xml_memory_page_value_allocated_mask = 8;
	static const uintptr_t xml_memory_page_type_mask = 7;

	struct xml_allocator;

	struct xml_memory_page
	{
		static xml_memory_page* construct(void* memory)
		{
			if (!memory) return 0; //$ redundant, left for performance

			xml_memory_page* result = static_cast<xml_memory_page*>(memory);

			result->allocator = 0;
			result->memory = 0;
			result->prev = 0;
			result->next = 0;
			result->busy_size = 0;
			result->freed_size = 0;

			return result;
		}

		xml_allocator* allocator;

		void* memory;

		xml_memory_page* prev;
		xml_memory_page* next;

		size_t busy_size;
		size_t freed_size;

		char data[1];
	};

	struct xml_memory_string_header
	{
		uint16_t page_offset; // offset from page->data
		uint16_t full_size; // 0 if string occupies whole page
	};

	struct xml_allocator
	{
		xml_allocator(xml_memory_page* root): _root(root), _busy_size(root->busy_size)
		{
		}

		xml_memory_page* allocate_page(size_t data_size)
		{
			size_t size = offsetof(xml_memory_page, data) + data_size;

			// allocate block with some alignment, leaving memory for worst-case padding
			void* memory = xml_memory::allocate(size + xml_memory_page_alignment);
			if (!memory) return 0;

			// align upwards to page boundary
			void* page_memory = reinterpret_cast<void*>((reinterpret_cast<uintptr_t>(memory) + (xml_memory_page_alignment - 1)) & ~(xml_memory_page_alignment - 1));

			// prepare page structure
			xml_memory_page* page = xml_memory_page::construct(page_memory);

			page->memory = memory;
			page->allocator = _root->allocator;

			return page;
		}

		static void deallocate_page(xml_memory_page* page)
		{
			xml_memory::deallocate(page->memory);
		}

		void* allocate_memory_oob(size_t size, xml_memory_page*& out_page);

		void* allocate_memory(size_t size, xml_memory_page*& out_page)
		{
			if (_busy_size + size > xml_memory_page_size) return allocate_memory_oob(size, out_page);

			void* buf = _root->data + _busy_size;

			_busy_size += size;

			out_page = _root;

			return buf;
		}

		void deallocate_memory(void* ptr, size_t size, xml_memory_page* page)
		{
			if (page == _root) page->busy_size = _busy_size;

			assert(ptr >= page->data && ptr < page->data + page->busy_size);
			(void)!ptr;

			page->freed_size += size;
			assert(page->freed_size <= page->busy_size);

			if (page->freed_size == page->busy_size)
			{
				if (page->next == 0)
				{
					assert(_root == page);

					// top page freed, just reset sizes
					page->busy_size = page->freed_size = 0;
					_busy_size = 0;
				}
				else
				{
					assert(_root != page);
					assert(page->prev);

					// remove from the list
					page->prev->next = page->next;
					page->next->prev = page->prev;

					// deallocate
					deallocate_page(page);
				}
			}
		}

		char_t* allocate_string(size_t length)
		{
			// allocate memory for string and header block
			size_t size = sizeof(xml_memory_string_header) + length * sizeof(char_t);
			
			// round size up to pointer alignment boundary
			size_t full_size = (size + (sizeof(void*) - 1)) & ~(sizeof(void*) - 1);

			xml_memory_page* page;
			xml_memory_string_header* header = static_cast<xml_memory_string_header*>(allocate_memory(full_size, page));

			if (!header) return 0;

			// setup header
			ptrdiff_t page_offset = reinterpret_cast<char*>(header) - page->data;

			assert(page_offset >= 0 && page_offset < (1 << 16));
			header->page_offset = static_cast<uint16_t>(page_offset);

			// full_size == 0 for large strings that occupy the whole page
			assert(full_size < (1 << 16) || (page->busy_size == full_size && page_offset == 0));
			header->full_size = static_cast<uint16_t>(full_size < (1 << 16) ? full_size : 0);

			// round-trip through void* to avoid 'cast increases required alignment of target type' warning
			// header is guaranteed a pointer-sized alignment, which should be enough for char_t
			return static_cast<char_t*>(static_cast<void*>(header + 1));
		}

		void deallocate_string(char_t* string)
		{
			// this function casts pointers through void* to avoid 'cast increases required alignment of target type' warnings
			// we're guaranteed the proper (pointer-sized) alignment on the input string if it was allocated via allocate_string

			// get header
			xml_memory_string_header* header = static_cast<xml_memory_string_header*>(static_cast<void*>(string)) - 1;

			// deallocate
			size_t page_offset = offsetof(xml_memory_page, data) + header->page_offset;
			xml_memory_page* page = reinterpret_cast<xml_memory_page*>(static_cast<void*>(reinterpret_cast<char*>(header) - page_offset));

			// if full_size == 0 then this string occupies the whole page
			size_t full_size = header->full_size == 0 ? page->busy_size : header->full_size;

			deallocate_memory(header, full_size, page);
		}

		xml_memory_page* _root;
		size_t _busy_size;
	};

	 void* xml_allocator::allocate_memory_oob(size_t size, xml_memory_page*& out_page)
	{
		const size_t large_allocation_threshold = xml_memory_page_size / 4;

		xml_memory_page* page = allocate_page(size <= large_allocation_threshold ? xml_memory_page_size : size);
		out_page = page;

		if (!page) return 0;

		if (size <= large_allocation_threshold)
		{
			_root->busy_size = _busy_size;

			// insert page at the end of linked list
			page->prev = _root;
			_root->next = page;
			_root = page;

			_busy_size = size;
		}
		else
		{
			// insert page before the end of linked list, so that it is deleted as soon as possible
			// the last page is not deleted even if it's empty (see deallocate_memory)
			assert(_root->prev);

			page->prev = _root->prev;
			page->next = _root;

			_root->prev->next = page;
			_root->prev = page;
		}

		// allocate inside page
		page->busy_size = size;

		return page->data;
	}
} } }

namespace pugi
{
	/// A 'name=value' XML attribute structure.
	struct xml_attribute_struct
	{
		/// Default ctor
		xml_attribute_struct(impl::xml_memory_page* page): header(reinterpret_cast<uintptr_t>(page)), name(0), value(0), prev_attribute_c(0), next_attribute(0)
		{
		}

		uintptr_t header;

		char_t* name;	///< Pointer to attribute name.
		char_t*	value;	///< Pointer to attribute value.

		xml_attribute_struct* prev_attribute_c;	///< Previous attribute (cyclic list)
		xml_attribute_struct* next_attribute;	///< Next attribute
	};

	/// An XML document tree node.
	struct xml_node_struct
	{
		/// Default ctor
		/// \param type - node type
		xml_node_struct(impl::xml_memory_page* page, xml_node_type type): header(reinterpret_cast<uintptr_t>(page) | (type - 1)), parent(0), name(0), value(0), first_child(0), prev_sibling_c(0), next_sibling(0), first_attribute(0)
		{
		}

		uintptr_t header;

		xml_node_struct*		parent;					///< Pointer to parent

		char_t*					name;					///< Pointer to element name.
		char_t*					value;					///< Pointer to any associated string data.

		xml_node_struct*		first_child;			///< First child
		
		xml_node_struct*		prev_sibling_c;			///< Left brother (cyclic list)
		xml_node_struct*		next_sibling;			///< Right brother
		
		xml_attribute_struct*	first_attribute;		///< First attribute
	};
}

namespace pugi { namespace impl { namespace {
	struct xml_document_struct: public xml_node_struct, public xml_allocator
	{
		xml_document_struct(xml_memory_page* page): xml_node_struct(page, node_document), xml_allocator(page), buffer(0)
		{
		}

		const char_t* buffer;
	};

	inline xml_allocator& get_allocator(const xml_node_struct* node)
	{
		assert(node);

		return *reinterpret_cast<xml_memory_page*>(node->header & xml_memory_page_pointer_mask)->allocator;
	}
} } }

// Low-level DOM operations
namespace pugi { namespace impl { namespace {
	inline xml_attribute_struct* allocate_attribute(xml_allocator& alloc)
	{
		xml_memory_page* page;
		void* memory = alloc.allocate_memory(sizeof(xml_attribute_struct), page);

		return new (memory) xml_attribute_struct(page);
	}

	inline xml_node_struct* allocate_node(xml_allocator& alloc, xml_node_type type)
	{
		xml_memory_page* page;
		void* memory = alloc.allocate_memory(sizeof(xml_node_struct), page);

		return new (memory) xml_node_struct(page, type);
	}

	inline void destroy_attribute(xml_attribute_struct* a, xml_allocator& alloc)
	{
		uintptr_t header = a->header;

		if (header & impl::xml_memory_page_name_allocated_mask) alloc.deallocate_string(a->name);
		if (header & impl::xml_memory_page_value_allocated_mask) alloc.deallocate_string(a->value);

		alloc.deallocate_memory(a, sizeof(xml_attribute_struct), reinterpret_cast<xml_memory_page*>(header & xml_memory_page_pointer_mask));
	}

	inline void destroy_node(xml_node_struct* n, xml_allocator& alloc)
	{
		uintptr_t header = n->header;

		if (header & impl::xml_memory_page_name_allocated_mask) alloc.deallocate_string(n->name);
		if (header & impl::xml_memory_page_value_allocated_mask) alloc.deallocate_string(n->value);

		for (xml_attribute_struct* attr = n->first_attribute; attr; )
		{
			xml_attribute_struct* next = attr->next_attribute;

			destroy_attribute(attr, alloc);

			attr = next;
		}

		for (xml_node_struct* child = n->first_child; child; )
		{
			xml_node_struct* next = child->next_sibling;

			destroy_node(child, alloc);

			child = next;
		}

		alloc.deallocate_memory(n, sizeof(xml_node_struct), reinterpret_cast<xml_memory_page*>(header & xml_memory_page_pointer_mask));
	}

	 xml_node_struct* append_node(xml_node_struct* node, xml_allocator& alloc, xml_node_type type = node_element)
	{
		xml_node_struct* child = allocate_node(alloc, type);
		if (!child) return 0;

		child->parent = node;

		xml_node_struct* first_child = node->first_child;
			
		if (first_child)
		{
			xml_node_struct* last_child = first_child->prev_sibling_c;

			last_child->next_sibling = child;
			child->prev_sibling_c = last_child;
			first_child->prev_sibling_c = child;
		}
		else
		{
			node->first_child = child;
			child->prev_sibling_c = child;
		}
			
		return child;
	}

	 xml_attribute_struct* append_attribute_ll(xml_node_struct* node, xml_allocator& alloc)
	{
		xml_attribute_struct* a = allocate_attribute(alloc);
		if (!a) return 0;

		xml_attribute_struct* first_attribute = node->first_attribute;

		if (first_attribute)
		{
			xml_attribute_struct* last_attribute = first_attribute->prev_attribute_c;

			last_attribute->next_attribute = a;
			a->prev_attribute_c = last_attribute;
			first_attribute->prev_attribute_c = a;
		}
		else
		{
			node->first_attribute = a;
			a->prev_attribute_c = a;
		}
			
		return a;
	}
} } }

// Helper classes for code generation
namespace pugi { namespace impl { namespace {
	struct opt_false
	{
		enum { value = 0 };
	};

	struct opt_true
	{
		enum { value = 1 };
	};
} } }

// Unicode utilities
namespace pugi { namespace impl { namespace {
	inline uint16_t endian_swap(uint16_t value)
	{
		return static_cast<uint16_t>(((value & 0xff) << 8) | (value >> 8));
	}

	inline uint32_t endian_swap(uint32_t value)
	{
		return ((value & 0xff) << 24) | ((value & 0xff00) << 8) | ((value & 0xff0000) >> 8) | (value >> 24);
	}

	struct utf8_counter
	{
		typedef size_t value_type;

		static value_type low(value_type result, uint32_t ch)
		{
			// U+0000..U+007F
			if (ch < 0x80) return result + 1;
			// U+0080..U+07FF
			else if (ch < 0x800) return result + 2;
			// U+0800..U+FFFF
			else return result + 3;
		}

		static value_type high(value_type result, uint32_t)
		{
			// U+10000..U+10FFFF
			return result + 4;
		}
	};

	struct utf8_writer
	{
		typedef uint8_t* value_type;

		static value_type low(value_type result, uint32_t ch)
		{
			// U+0000..U+007F
			if (ch < 0x80)
			{
				*result = static_cast<uint8_t>(ch);
				return result + 1;
			}
			// U+0080..U+07FF
			else if (ch < 0x800)
			{
				result[0] = static_cast<uint8_t>(0xC0 | (ch >> 6));
				result[1] = static_cast<uint8_t>(0x80 | (ch & 0x3F));
				return result + 2;
			}
			// U+0800..U+FFFF
			else
			{
				result[0] = static_cast<uint8_t>(0xE0 | (ch >> 12));
				result[1] = static_cast<uint8_t>(0x80 | ((ch >> 6) & 0x3F));
				result[2] = static_cast<uint8_t>(0x80 | (ch & 0x3F));
				return result + 3;
			}
		}

		static value_type high(value_type result, uint32_t ch)
		{
			// U+10000..U+10FFFF
			result[0] = static_cast<uint8_t>(0xF0 | (ch >> 18));
			result[1] = static_cast<uint8_t>(0x80 | ((ch >> 12) & 0x3F));
			result[2] = static_cast<uint8_t>(0x80 | ((ch >> 6) & 0x3F));
			result[3] = static_cast<uint8_t>(0x80 | (ch & 0x3F));
			return result + 4;
		}

		static value_type any(value_type result, uint32_t ch)
		{
			return (ch < 0x10000) ? low(result, ch) : high(result, ch);
		}
	};

	struct utf16_counter
	{
		typedef size_t value_type;

		static value_type low(value_type result, uint32_t)
		{
			return result + 1;
		}

		static value_type high(value_type result, uint32_t)
		{
			return result + 2;
		}
	};

	struct utf16_writer
	{
		typedef uint16_t* value_type;

		static value_type low(value_type result, uint32_t ch)
		{
			*result = static_cast<uint16_t>(ch);

			return result + 1;
		}

		static value_type high(value_type result, uint32_t ch)
		{
			uint32_t msh = static_cast<uint32_t>(ch - 0x10000) >> 10;
			uint32_t lsh = static_cast<uint32_t>(ch - 0x10000) & 0x3ff;

			result[0] = static_cast<uint16_t>(0xD800 + msh);
			result[1] = static_cast<uint16_t>(0xDC00 + lsh);

			return result + 2;
		}

		static value_type any(value_type result, uint32_t ch)
		{
			return (ch < 0x10000) ? low(result, ch) : high(result, ch);
		}
	};

	struct utf32_counter
	{
		typedef size_t value_type;

		static value_type low(value_type result, uint32_t)
		{
			return result + 1;
		}

		static value_type high(value_type result, uint32_t)
		{
			return result + 1;
		}
	};

	struct utf32_writer
	{
		typedef uint32_t* value_type;

		static value_type low(value_type result, uint32_t ch)
		{
			*result = ch;

			return result + 1;
		}

		static value_type high(value_type result, uint32_t ch)
		{
			*result = ch;

			return result + 1;
		}

		static value_type any(value_type result, uint32_t ch)
		{
			*result = ch;

			return result + 1;
		}
	};

	struct latin1_writer
	{
		typedef uint8_t* value_type;

		static value_type low(value_type result, uint32_t ch)
		{
			*result = static_cast<uint8_t>(ch > 255 ? '?' : ch);

			return result + 1;
		}

		static value_type high(value_type result, uint32_t ch)
		{
			(void)ch;

			*result = '?';

			return result + 1;
		}
	};

	template <size_t size> struct wchar_selector;

	template <> struct wchar_selector<2>
	{
		typedef uint16_t type;
		typedef utf16_counter counter;
		typedef utf16_writer writer;
	};

	template <> struct wchar_selector<4>
	{
		typedef uint32_t type;
		typedef utf32_counter counter;
		typedef utf32_writer writer;
	};

	typedef wchar_selector<sizeof(wchar_t)>::counter wchar_counter;
	typedef wchar_selector<sizeof(wchar_t)>::writer wchar_writer;

	template <typename Traits, typename opt_swap = opt_false> struct utf_decoder
	{
		static inline typename Traits::value_type decode_utf8_block(const uint8_t* data, size_t size, typename Traits::value_type result)
		{
			const uint8_t utf8_byte_mask = 0x3f;

			while (size)
			{
				uint8_t lead = *data;

				// 0xxxxxxx -> U+0000..U+007F
				if (lead < 0x80)
				{
					result = Traits::low(result, lead);
					data += 1;
					size -= 1;

					// process aligned single-byte (ascii) blocks
					if ((reinterpret_cast<uintptr_t>(data) & 3) == 0)
					{
						// round-trip through void* to silence 'cast increases required alignment of target type' warnings
						while (size >= 4 && (*static_cast<const uint32_t*>(static_cast<const void*>(data)) & 0x80808080) == 0)
						{
							result = Traits::low(result, data[0]);
							result = Traits::low(result, data[1]);
							result = Traits::low(result, data[2]);
							result = Traits::low(result, data[3]);
							data += 4;
							size -= 4;
						}
					}
				}
				// 110xxxxx -> U+0080..U+07FF
				else if (static_cast<unsigned int>(lead - 0xC0) < 0x20 && size >= 2 && (data[1] & 0xc0) == 0x80)
				{
					result = Traits::low(result, ((lead & ~0xC0) << 6) | (data[1] & utf8_byte_mask));
					data += 2;
					size -= 2;
				}
				// 1110xxxx -> U+0800-U+FFFF
				else if (static_cast<unsigned int>(lead - 0xE0) < 0x10 && size >= 3 && (data[1] & 0xc0) == 0x80 && (data[2] & 0xc0) == 0x80)
				{
					result = Traits::low(result, ((lead & ~0xE0) << 12) | ((data[1] & utf8_byte_mask) << 6) | (data[2] & utf8_byte_mask));
					data += 3;
					size -= 3;
				}
				// 11110xxx -> U+10000..U+10FFFF
				else if (static_cast<unsigned int>(lead - 0xF0) < 0x08 && size >= 4 && (data[1] & 0xc0) == 0x80 && (data[2] & 0xc0) == 0x80 && (data[3] & 0xc0) == 0x80)
				{
					result = Traits::high(result, ((lead & ~0xF0) << 18) | ((data[1] & utf8_byte_mask) << 12) | ((data[2] & utf8_byte_mask) << 6) | (data[3] & utf8_byte_mask));
					data += 4;
					size -= 4;
				}
				// 10xxxxxx or 11111xxx -> invalid
				else
				{
					data += 1;
					size -= 1;
				}
			}

			return result;
		}

		static inline typename Traits::value_type decode_utf16_block(const uint16_t* data, size_t size, typename Traits::value_type result)
		{
			const uint16_t* end = data + size;

			while (data < end)
			{
				uint16_t lead = opt_swap::value ? endian_swap(*data) : *data;

				// U+0000..U+D7FF
				if (lead < 0xD800)
				{
					result = Traits::low(result, lead);
					data += 1;
				}
				// U+E000..U+FFFF
				else if (static_cast<unsigned int>(lead - 0xE000) < 0x2000)
				{
					result = Traits::low(result, lead);
					data += 1;
				}
				// surrogate pair lead
				else if (static_cast<unsigned int>(lead - 0xD800) < 0x400 && data + 1 < end)
				{
					uint16_t next = opt_swap::value ? endian_swap(data[1]) : data[1];

					if (static_cast<unsigned int>(next - 0xDC00) < 0x400)
					{
						result = Traits::high(result, 0x10000 + ((lead & 0x3ff) << 10) + (next & 0x3ff));
						data += 2;
					}
					else
					{
						data += 1;
					}
				}
				else
				{
					data += 1;
				}
			}

			return result;
		}

		static inline typename Traits::value_type decode_utf32_block(const uint32_t* data, size_t size, typename Traits::value_type result)
		{
			const uint32_t* end = data + size;

			while (data < end)
			{
				uint32_t lead = opt_swap::value ? endian_swap(*data) : *data;

				// U+0000..U+FFFF
				if (lead < 0x10000)
				{
					result = Traits::low(result, lead);
					data += 1;
				}
				// U+10000..U+10FFFF
				else
				{
					result = Traits::high(result, lead);
					data += 1;
				}
			}

			return result;
		}

		static inline typename Traits::value_type decode_latin1_block(const uint8_t* data, size_t size, typename Traits::value_type result)
		{
			for (size_t i = 0; i < size; ++i)
			{
				result = Traits::low(result, data[i]);
			}

			return result;
		}

		static inline typename Traits::value_type decode_wchar_block_impl(const uint16_t* data, size_t size, typename Traits::value_type result)
		{
			return decode_utf16_block(data, size, result);
		}

		static inline typename Traits::value_type decode_wchar_block_impl(const uint32_t* data, size_t size, typename Traits::value_type result)
		{
			return decode_utf32_block(data, size, result);
		}

		static inline typename Traits::value_type decode_wchar_block(const wchar_t* data, size_t size, typename Traits::value_type result)
		{
			return decode_wchar_block_impl(reinterpret_cast<const wchar_selector<sizeof(wchar_t)>::type*>(data), size, result);
		}
	};

	template <typename T>  void convert_utf_endian_swap(T* result, const T* data, size_t length)
	{
		for (size_t i = 0; i < length; ++i) result[i] = endian_swap(data[i]);
	}

                         
	                                                                                            
	 
		                                                                                                                                               
	 
      
} } }

namespace pugi { namespace impl { namespace {
	enum chartype_t
	{
		ct_parse_pcdata = 1,	// \0, &, \r, <
		ct_parse_attr = 2,		// \0, &, \r, ', "
		ct_parse_attr_ws = 4,	// \0, &, \r, ', ", \n, tab
		ct_space = 8,			// \r, \n, space, tab
		ct_parse_cdata = 16,	// \0, ], >, \r
		ct_parse_comment = 32,	// \0, -, >, \r
		ct_symbol = 64,			// Any symbol > 127, a-z, A-Z, 0-9, _, :, -, .
		ct_start_symbol = 128	// Any symbol > 127, a-z, A-Z, _, :
	};

	static const unsigned char chartype_table[256] =
	{
		55,  0,   0,   0,   0,   0,   0,   0,      0,   12,  12,  0,   0,   63,  0,   0,   // 0-15
		0,   0,   0,   0,   0,   0,   0,   0,      0,   0,   0,   0,   0,   0,   0,   0,   // 16-31
		8,   0,   6,   0,   0,   0,   7,   6,      0,   0,   0,   0,   0,   96,  64,  0,   // 32-47
		64,  64,  64,  64,  64,  64,  64,  64,     64,  64,  192, 0,   1,   0,   48,  0,   // 48-63
		0,   192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192, // 64-79
		192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 0,   0,   16,  0,   192, // 80-95
		0,   192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192, // 96-111
		192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 0, 0, 0, 0, 0,           // 112-127

		192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192, // 128+
		192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192,
		192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192,
		192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192,
		192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192,
		192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192,
		192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192,
		192, 192, 192, 192, 192, 192, 192, 192,    192, 192, 192, 192, 192, 192, 192, 192
	};

	enum chartypex_t
	{
		ctx_special_pcdata = 1,   // Any symbol >= 0 and < 32 (except \t, \r, \n), &, <, >
		ctx_special_attr = 2,     // Any symbol >= 0 and < 32 (except \t), &, <, >, "
		ctx_start_symbol = 4,	  // Any symbol > 127, a-z, A-Z, _
		ctx_digit = 8,			  // 0-9
		ctx_symbol = 16			  // Any symbol > 127, a-z, A-Z, 0-9, _, -, .
	};
	
	static const unsigned char chartypex_table[256] =
	{
		3,  3,  3,  3,  3,  3,  3,  3,     3,  0,  2,  3,  3,  2,  3,  3,     // 0-15
		3,  3,  3,  3,  3,  3,  3,  3,     3,  3,  3,  3,  3,  3,  3,  3,     // 16-31
		0,  0,  2,  0,  0,  0,  3,  0,     0,  0,  0,  0,  0, 16, 16,  0,     // 32-47
		24, 24, 24, 24, 24, 24, 24, 24,    24, 24, 0,  0,  3,  0,  3,  0,     // 48-63

		0,  20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,    // 64-79
		20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 0,  0,  0,  0,  20,    // 80-95
		0,  20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,    // 96-111
		20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 0,  0,  0,  0,  0,     // 112-127

		20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,    // 128+
		20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,
		20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,
		20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,
		20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,
		20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,
		20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20,
		20, 20, 20, 20, 20, 20, 20, 20,    20, 20, 20, 20, 20, 20, 20, 20
	};
	
                         
	                                                                                                                                             
     
	                                                                                          
      

	                                                                              
	                                                                                

	 bool is_little_endian()
	{
		unsigned int ui = 1;

		return *reinterpret_cast<unsigned char*>(&ui) == 1;
	}

	 xml_encoding get_wchar_encoding()
	{
		{ static const char condition_failed[(sizeof(wchar_t) == 2 || sizeof(wchar_t) == 4) ? 1 : -1] = {0}; (void)condition_failed[0]; };

		if (sizeof(wchar_t) == 2)
			return is_little_endian() ? encoding_utf16_le : encoding_utf16_be;
		else 
			return is_little_endian() ? encoding_utf32_le : encoding_utf32_be;
	}

	 xml_encoding guess_buffer_encoding(uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3)
	{
		// look for BOM in first few bytes
		if (d0 == 0 && d1 == 0 && d2 == 0xfe && d3 == 0xff) return encoding_utf32_be;
		if (d0 == 0xff && d1 == 0xfe && d2 == 0 && d3 == 0) return encoding_utf32_le;
		if (d0 == 0xfe && d1 == 0xff) return encoding_utf16_be;
		if (d0 == 0xff && d1 == 0xfe) return encoding_utf16_le;
		if (d0 == 0xef && d1 == 0xbb && d2 == 0xbf) return encoding_utf8;

		// look for <, <? or <?xm in various encodings
		if (d0 == 0 && d1 == 0 && d2 == 0 && d3 == 0x3c) return encoding_utf32_be;
		if (d0 == 0x3c && d1 == 0 && d2 == 0 && d3 == 0) return encoding_utf32_le;
		if (d0 == 0 && d1 == 0x3c && d2 == 0 && d3 == 0x3f) return encoding_utf16_be;
		if (d0 == 0x3c && d1 == 0 && d2 == 0x3f && d3 == 0) return encoding_utf16_le;
		if (d0 == 0x3c && d1 == 0x3f && d2 == 0x78 && d3 == 0x6d) return encoding_utf8;

		// look for utf16 < followed by node name (this may fail, but is better than utf8 since it's zero terminated so early)
		if (d0 == 0 && d1 == 0x3c) return encoding_utf16_be;
		if (d0 == 0x3c && d1 == 0) return encoding_utf16_le;

		// no known BOM detected, assume utf8
		return encoding_utf8;
	}

	 xml_encoding get_buffer_encoding(xml_encoding encoding, const void* contents, size_t size)
	{
		// replace wchar encoding with utf implementation
		if (encoding == encoding_wchar) return get_wchar_encoding();

		// replace utf16 encoding with utf16 with specific endianness
		if (encoding == encoding_utf16) return is_little_endian() ? encoding_utf16_le : encoding_utf16_be;

		// replace utf32 encoding with utf32 with specific endianness
		if (encoding == encoding_utf32) return is_little_endian() ? encoding_utf32_le : encoding_utf32_be;

		// only do autodetection if no explicit encoding is requested
		if (encoding != encoding_auto) return encoding;

		// skip encoding autodetection if input buffer is too small
		if (size < 4) return encoding_utf8;

		// try to guess encoding (based on XML specification, Appendix F.1)
		const uint8_t* data = static_cast<const uint8_t*>(contents);

		 uint8_t d0 = data[0], d1 = data[1], d2 = data[2], d3 = data[3];

		return guess_buffer_encoding(d0, d1, d2, d3);
	}

	 bool get_mutable_buffer(char_t*& out_buffer, size_t& out_length, const void* contents, size_t size, bool is_mutable)
	{
		if (is_mutable)
		{
			out_buffer = static_cast<char_t*>(const_cast<void*>(contents));
		}
		else
		{
			void* buffer = xml_memory::allocate(size > 0 ? size : 1);
			if (!buffer) return false;

			memcpy(buffer, contents, size);

			out_buffer = static_cast<char_t*>(buffer);
		}

		out_length = size / sizeof(char_t);

		return true;
	}

                         
	                                                                    
	 
		                                                                                                                      
			                                                                                                                
	 

	                                                                                                                                     
	 
		                                                          
	
		               
		 
			                                       
		 
		    
		 
			                                                                             
			                              
		 

		                                   

		                                                        

		            
	 

	                                                                                                             
	 
		                                                            

		                                          
		                                                                          

		                                     
		                                                                                                            
		                              

		                                             
		                                                                                            
		                                                                                                       

		                                          
		               

		            
	 

	                                                                                                                                                     
	 
		                                                              
		                                        

		                                          
		                                                                                       

		                                     
		                                                                                                            
		                              

		                                              
		                                                                                            
		                                                                                                                    

		                                          
		               

		            
	 

	                                                                                                                                                     
	 
		                                                              
		                                        

		                                          
		                                                                                       

		                                     
		                                                                                                            
		                              

		                                              
		                                                                                            
		                                                                                                                    

		                                          
		               

		            
	 

	                                                                                                               
	 
		                                                            

		                              
		                  

		                                     
		                                                                                                            
		                              

		                                  
		                                                                                            
		                                                                                                         

		                                          
		               

		            
	 

	                                                                                                                                                
	 
		                      
		                                                   

		                                    
		                                                                                                              

		                                   
		                                                                                                                                          

		                          
		                                                                                                  

		                           
		                                                                   
		 
			                                                                                          

			                                      
				                                                                           
				                                                                         
		 

		                           
		                                                                   
		 
			                                                                                          

			                                      
				                                                                           
				                                                                         
		 

		                            
		                                                                                                      

		                            
		             
	 
     
	template <typename opt_swap>  bool convert_buffer_utf16(char_t*& out_buffer, size_t& out_length, const void* contents, size_t size, opt_swap)
	{
		const uint16_t* data = static_cast<const uint16_t*>(contents);
		size_t length = size / sizeof(uint16_t);

		// first pass: get length in utf8 units
		out_length = utf_decoder<utf8_counter, opt_swap>::decode_utf16_block(data, length, 0);

		// allocate buffer of suitable length
		out_buffer = static_cast<char_t*>(xml_memory::allocate((out_length > 0 ? out_length : 1) * sizeof(char_t)));
		if (!out_buffer) return false;

		// second pass: convert utf16 input to utf8
		uint8_t* out_begin = reinterpret_cast<uint8_t*>(out_buffer);
		uint8_t* out_end = utf_decoder<utf8_writer, opt_swap>::decode_utf16_block(data, length, out_begin);

		assert(out_end == out_begin + out_length);
		(void)!out_end;

		return true;
	}

	template <typename opt_swap>  bool convert_buffer_utf32(char_t*& out_buffer, size_t& out_length, const void* contents, size_t size, opt_swap)
	{
		const uint32_t* data = static_cast<const uint32_t*>(contents);
		size_t length = size / sizeof(uint32_t);

		// first pass: get length in utf8 units
		out_length = utf_decoder<utf8_counter, opt_swap>::decode_utf32_block(data, length, 0);

		// allocate buffer of suitable length
		out_buffer = static_cast<char_t*>(xml_memory::allocate((out_length > 0 ? out_length : 1) * sizeof(char_t)));
		if (!out_buffer) return false;

		// second pass: convert utf32 input to utf8
		uint8_t* out_begin = reinterpret_cast<uint8_t*>(out_buffer);
		uint8_t* out_end = utf_decoder<utf8_writer, opt_swap>::decode_utf32_block(data, length, out_begin);

		assert(out_end == out_begin + out_length);
		(void)!out_end;

		return true;
	}

	 size_t get_latin1_7bit_prefix_length(const uint8_t* data, size_t size)
	{
		for (size_t i = 0; i < size; ++i)
			if (data[i] > 127)
				return i;

		return size;
	}

	 bool convert_buffer_latin1(char_t*& out_buffer, size_t& out_length, const void* contents, size_t size, bool is_mutable)
	{
		const uint8_t* data = static_cast<const uint8_t*>(contents);

		// get size of prefix that does not need utf8 conversion
		size_t prefix_length = get_latin1_7bit_prefix_length(data, size);
		assert(prefix_length <= size);

		const uint8_t* postfix = data + prefix_length;
		size_t postfix_length = size - prefix_length;

		// if no conversion is needed, just return the original buffer
		if (postfix_length == 0) return get_mutable_buffer(out_buffer, out_length, contents, size, is_mutable);

		// first pass: get length in utf8 units
		out_length = prefix_length + utf_decoder<utf8_counter>::decode_latin1_block(postfix, postfix_length, 0);

		// allocate buffer of suitable length
		out_buffer = static_cast<char_t*>(xml_memory::allocate((out_length > 0 ? out_length : 1) * sizeof(char_t)));
		if (!out_buffer) return false;

		// second pass: convert latin1 input to utf8
		memcpy(out_buffer, data, prefix_length);

		uint8_t* out_begin = reinterpret_cast<uint8_t*>(out_buffer);
		uint8_t* out_end = utf_decoder<utf8_writer>::decode_latin1_block(postfix, postfix_length, out_begin + prefix_length);

		assert(out_end == out_begin + out_length);
		(void)!out_end;

		return true;
	}

	 bool convert_buffer(char_t*& out_buffer, size_t& out_length, xml_encoding encoding, const void* contents, size_t size, bool is_mutable)
	{
		// fast path: no conversion required
		if (encoding == encoding_utf8) return get_mutable_buffer(out_buffer, out_length, contents, size, is_mutable);

		// source encoding is utf16
		if (encoding == encoding_utf16_be || encoding == encoding_utf16_le)
		{
			xml_encoding native_encoding = is_little_endian() ? encoding_utf16_le : encoding_utf16_be;

			return (native_encoding == encoding) ?
				convert_buffer_utf16(out_buffer, out_length, contents, size, opt_false()) :
				convert_buffer_utf16(out_buffer, out_length, contents, size, opt_true());
		}

		// source encoding is utf32
		if (encoding == encoding_utf32_be || encoding == encoding_utf32_le)
		{
			xml_encoding native_encoding = is_little_endian() ? encoding_utf32_le : encoding_utf32_be;

			return (native_encoding == encoding) ?
				convert_buffer_utf32(out_buffer, out_length, contents, size, opt_false()) :
				convert_buffer_utf32(out_buffer, out_length, contents, size, opt_true());
		}

		// source encoding is latin1
		if (encoding == encoding_latin1) return convert_buffer_latin1(out_buffer, out_length, contents, size, is_mutable);

		assert(!"Invalid encoding");
		return false;
	}
      

	 size_t as_utf8_begin(const wchar_t* str, size_t length)
	{
		// get length in utf8 characters
		return utf_decoder<utf8_counter>::decode_wchar_block(str, length, 0);
	}

	 void as_utf8_end(char* buffer, size_t size, const wchar_t* str, size_t length)
	{
		// convert to utf8
		uint8_t* begin = reinterpret_cast<uint8_t*>(buffer);
		uint8_t* end = utf_decoder<utf8_writer>::decode_wchar_block(str, length, begin);
	
		assert(begin + size == end);
		(void)!end;

		// zero-terminate
		buffer[size] = 0;
	}
	
                      
	 std::string as_utf8_impl(const wchar_t* str, size_t length)
	{
		// first pass: get length in utf8 characters
		size_t size = as_utf8_begin(str, length);

		// allocate resulting string
		std::string result;
		result.resize(size);

		// second pass: convert to utf8
		if (size > 0) as_utf8_end(&result[0], size, str, length);

		return result;
	}

	 std::basic_string<wchar_t> as_wide_impl(const char* str, size_t size)
	{
		const uint8_t* data = reinterpret_cast<const uint8_t*>(str);

		// first pass: get length in wchar_t units
		size_t length = utf_decoder<wchar_counter>::decode_utf8_block(data, size, 0);

		// allocate resulting string
		std::basic_string<wchar_t> result;
		result.resize(length);

		// second pass: convert to wchar_t
		if (length > 0)
		{
			wchar_writer::value_type begin = reinterpret_cast<wchar_writer::value_type>(&result[0]);
			wchar_writer::value_type end = utf_decoder<wchar_writer>::decode_utf8_block(data, size, begin);

			assert(begin + length == end);
			(void)!end;
		}

		return result;
	}
      

	inline bool strcpy_insitu_allow(size_t length, uintptr_t allocated, char_t* target)
	{
		assert(target);
		size_t target_length = strlength(target);

		// always reuse document buffer memory if possible
		if (!allocated) return target_length >= length;

		// reuse heap memory if waste is not too great
		const size_t reuse_threshold = 32;

		return target_length >= length && (target_length < reuse_threshold || target_length - length < target_length / 2);
	}

	 bool strcpy_insitu(char_t*& dest, uintptr_t& header, uintptr_t header_mask, const char_t* source)
	{
		size_t source_length = strlength(source);

		if (source_length == 0)
		{
			// empty string and null pointer are equivalent, so just deallocate old memory
			xml_allocator* alloc = reinterpret_cast<xml_memory_page*>(header & xml_memory_page_pointer_mask)->allocator;

			if (header & header_mask) alloc->deallocate_string(dest);
			
			// mark the string as not allocated
			dest = 0;
			header &= ~header_mask;

			return true;
		}
		else if (dest && strcpy_insitu_allow(source_length, header & header_mask, dest))
		{
			// we can reuse old buffer, so just copy the new data (including zero terminator)
			memcpy(dest, source, (source_length + 1) * sizeof(char_t));
			
			return true;
		}
		else
		{
			xml_allocator* alloc = reinterpret_cast<xml_memory_page*>(header & xml_memory_page_pointer_mask)->allocator;

			// allocate new buffer
			char_t* buf = alloc->allocate_string(source_length + 1);
			if (!buf) return false;

			// copy the string (including zero terminator)
			memcpy(buf, source, (source_length + 1) * sizeof(char_t));

			// deallocate old buffer (*after* the above to protect against overlapping memory and/or allocation failures)
			if (header & header_mask) alloc->deallocate_string(dest);
			
			// the string is now allocated, so set the flag
			dest = buf;
			header |= header_mask;

			return true;
		}
	}

	struct gap
	{
		char_t* end;
		size_t size;
			
		gap(): end(0), size(0)
		{
		}
			
		// Push new gap, move s count bytes further (skipping the gap).
		// Collapse previous gap.
		void push(char_t*& s, size_t count)
		{
			if (end) // there was a gap already; collapse it
			{
				// Move [old_gap_end, new_gap_start) to [old_gap_start, ...)
				assert(s >= end);
				memmove(end - size, end, reinterpret_cast<char*>(s) - reinterpret_cast<char*>(end));
			}
				
			s += count; // end of current gap
				
			// "merge" two gaps
			end = s;
			size += count;
		}
			
		// Collapse all gaps, return past-the-end pointer
		char_t* flush(char_t* s)
		{
			if (end)
			{
				// Move [old_gap_end, current_pos) to [old_gap_start, ...)
				assert(s >= end);
				memmove(end - size, end, reinterpret_cast<char*>(s) - reinterpret_cast<char*>(end));

				return s - size;
			}
			else return s;
		}
	};
	
	 char_t* strconv_escape(char_t* s, gap& g)
	{
		char_t* stre = s + 1;

		switch (*stre)
		{
			case '#':	// &#...
			{
				unsigned int ucsc = 0;

				if (stre[1] == 'x') // &#x... (hex code)
				{
					stre += 2;

					char_t ch = *stre;

					if (ch == ';') return stre;

					for (;;)
					{
						if (static_cast<unsigned int>(ch - '0') <= 9)
							ucsc = 16 * ucsc + (ch - '0');
						else if (static_cast<unsigned int>((ch | ' ') - 'a') <= 5)
							ucsc = 16 * ucsc + ((ch | ' ') - 'a' + 10);
						else if (ch == ';')
							break;
						else // cancel
							return stre;

						ch = *++stre;
					}
					
					++stre;
				}
				else	// &#... (dec code)
				{
					char_t ch = *++stre;

					if (ch == ';') return stre;

					for (;;)
					{
						if (static_cast<unsigned int>(ch - '0') <= 9)
							ucsc = 10 * ucsc + (ch - '0');
						else if (ch == ';')
							break;
						else // cancel
							return stre;

						ch = *++stre;
					}
					
					++stre;
				}

			                         
				                                                                                                      
			     
				s = reinterpret_cast<char_t*>(utf8_writer::any(reinterpret_cast<uint8_t*>(s), ucsc));
			      
					
				g.push(s, stre - s);
				return stre;
			}

			case 'a':	// &a
			{
				++stre;

				if (*stre == 'm') // &am
				{
					if (*++stre == 'p' && *++stre == ';') // &amp;
					{
						*s++ = '&';
						++stre;
							
						g.push(s, stre - s);
						return stre;
					}
				}
				else if (*stre == 'p') // &ap
				{
					if (*++stre == 'o' && *++stre == 's' && *++stre == ';') // &apos;
					{
						*s++ = '\'';
						++stre;

						g.push(s, stre - s);
						return stre;
					}
				}
				break;
			}

			case 'g': // &g
			{
				if (*++stre == 't' && *++stre == ';') // &gt;
				{
					*s++ = '>';
					++stre;
					
					g.push(s, stre - s);
					return stre;
				}
				break;
			}

			case 'l': // &l
			{
				if (*++stre == 't' && *++stre == ';') // &lt;
				{
					*s++ = '<';
					++stre;
						
					g.push(s, stre - s);
					return stre;
				}
				break;
			}

			case 'q': // &q
			{
				if (*++stre == 'u' && *++stre == 'o' && *++stre == 't' && *++stre == ';') // &quot;
				{
					*s++ = '"';
					++stre;
					
					g.push(s, stre - s);
					return stre;
				}
				break;
			}

			default:
				break;
		}
		
		return stre;
	}

	// Utility macro for last character handling
	                                                                 

	 char_t* strconv_comment(char_t* s, char_t endch)
	{
		gap g;
		
		while (true)
		{
			while (!(chartype_table[static_cast<unsigned char>(*s)] & (ct_parse_comment))) ++s;
		
			if (*s == '\r') // Either a single 0x0d or 0x0d 0x0a pair
			{
				*s++ = '\n'; // replace first one with 0x0a
				
				if (*s == '\n') g.push(s, 1);
			}
			else if (s[0] == '-' && s[1] == '-' && ((s[2]) == ('>') || ((s[2]) == 0 && endch == ('>')))) // comment ends here
			{
				*g.flush(s) = 0;
				
				return s + (s[2] == '>' ? 3 : 2);
			}
			else if (*s == 0)
			{
				return 0;
			}
			else ++s;
		}
	}

	 char_t* strconv_cdata(char_t* s, char_t endch)
	{
		gap g;
			
		while (true)
		{
			while (!(chartype_table[static_cast<unsigned char>(*s)] & (ct_parse_cdata))) ++s;
			
			if (*s == '\r') // Either a single 0x0d or 0x0d 0x0a pair
			{
				*s++ = '\n'; // replace first one with 0x0a
				
				if (*s == '\n') g.push(s, 1);
			}
			else if (s[0] == ']' && s[1] == ']' && ((s[2]) == ('>') || ((s[2]) == 0 && endch == ('>')))) // CDATA ends here
			{
				*g.flush(s) = 0;
				
				return s + 1;
			}
			else if (*s == 0)
			{
				return 0;
			}
			else ++s;
		}
	}
	
	typedef char_t* (*strconv_pcdata_t)(char_t*);
		
	template <typename opt_eol, typename opt_escape> struct strconv_pcdata_impl
	{
		static char_t* parse(char_t* s)
		{
			gap g;
			
			while (true)
			{
				while (!(chartype_table[static_cast<unsigned char>(*s)] & (ct_parse_pcdata))) ++s;
					
				if (*s == '<') // PCDATA ends here
				{
					*g.flush(s) = 0;
					
					return s + 1;
				}
				else if (opt_eol::value && *s == '\r') // Either a single 0x0d or 0x0d 0x0a pair
				{
					*s++ = '\n'; // replace first one with 0x0a
					
					if (*s == '\n') g.push(s, 1);
				}
				else if (opt_escape::value && *s == '&')
				{
					s = strconv_escape(s, g);
				}
				else if (*s == 0)
				{
					return s;
				}
				else ++s;
			}
		}
	};
	
	 strconv_pcdata_t get_strconv_pcdata(unsigned int optmask)
	{
		{ static const char condition_failed[(parse_escapes == 0x10 && parse_eol == 0x20) ? 1 : -1] = {0}; (void)condition_failed[0]; };

		switch ((optmask >> 4) & 3) // get bitmask for flags (eol escapes)
		{
		case 0: return strconv_pcdata_impl<opt_false, opt_false>::parse;
		case 1: return strconv_pcdata_impl<opt_false, opt_true>::parse;
		case 2: return strconv_pcdata_impl<opt_true, opt_false>::parse;
		case 3: return strconv_pcdata_impl<opt_true, opt_true>::parse;
		default: return 0; // should not get here
		}
	}

	typedef char_t* (*strconv_attribute_t)(char_t*, char_t);
	
	template <typename opt_escape> struct strconv_attribute_impl
	{
		static char_t* parse_wnorm(char_t* s, char_t end_quote)
		{
			gap g;

			// trim leading whitespaces
			if ((chartype_table[static_cast<unsigned char>(*s)] & (ct_space)))
			{
				char_t* str = s;
				
				do ++str;
				while ((chartype_table[static_cast<unsigned char>(*str)] & (ct_space)));
				
				g.push(s, str - s);
			}

			while (true)
			{
				while (!(chartype_table[static_cast<unsigned char>(*s)] & (ct_parse_attr_ws | ct_space))) ++s;
				
				if (*s == end_quote)
				{
					char_t* str = g.flush(s);
					
					do *str-- = 0;
					while ((chartype_table[static_cast<unsigned char>(*str)] & (ct_space)));
				
					return s + 1;
				}
				else if ((chartype_table[static_cast<unsigned char>(*s)] & (ct_space)))
				{
					*s++ = ' ';
		
					if ((chartype_table[static_cast<unsigned char>(*s)] & (ct_space)))
					{
						char_t* str = s + 1;
						while ((chartype_table[static_cast<unsigned char>(*str)] & (ct_space))) ++str;
						
						g.push(s, str - s);
					}
				}
				else if (opt_escape::value && *s == '&')
				{
					s = strconv_escape(s, g);
				}
				else if (!*s)
				{
					return 0;
				}
				else ++s;
			}
		}

		static char_t* parse_wconv(char_t* s, char_t end_quote)
		{
			gap g;

			while (true)
			{
				while (!(chartype_table[static_cast<unsigned char>(*s)] & (ct_parse_attr_ws))) ++s;
				
				if (*s == end_quote)
				{
					*g.flush(s) = 0;
				
					return s + 1;
				}
				else if ((chartype_table[static_cast<unsigned char>(*s)] & (ct_space)))
				{
					if (*s == '\r')
					{
						*s++ = ' ';
				
						if (*s == '\n') g.push(s, 1);
					}
					else *s++ = ' ';
				}
				else if (opt_escape::value && *s == '&')
				{
					s = strconv_escape(s, g);
				}
				else if (!*s)
				{
					return 0;
				}
				else ++s;
			}
		}

		static char_t* parse_eol(char_t* s, char_t end_quote)
		{
			gap g;

			while (true)
			{
				while (!(chartype_table[static_cast<unsigned char>(*s)] & (ct_parse_attr))) ++s;
				
				if (*s == end_quote)
				{
					*g.flush(s) = 0;
				
					return s + 1;
				}
				else if (*s == '\r')
				{
					*s++ = '\n';
					
					if (*s == '\n') g.push(s, 1);
				}
				else if (opt_escape::value && *s == '&')
				{
					s = strconv_escape(s, g);
				}
				else if (!*s)
				{
					return 0;
				}
				else ++s;
			}
		}

		static char_t* parse_simple(char_t* s, char_t end_quote)
		{
			gap g;

			while (true)
			{
				while (!(chartype_table[static_cast<unsigned char>(*s)] & (ct_parse_attr))) ++s;
				
				if (*s == end_quote)
				{
					*g.flush(s) = 0;
				
					return s + 1;
				}
				else if (opt_escape::value && *s == '&')
				{
					s = strconv_escape(s, g);
				}
				else if (!*s)
				{
					return 0;
				}
				else ++s;
			}
		}
	};

	 strconv_attribute_t get_strconv_attribute(unsigned int optmask)
	{
		{ static const char condition_failed[(parse_escapes == 0x10 && parse_eol == 0x20 && parse_wconv_attribute == 0x40 && parse_wnorm_attribute == 0x80) ? 1 : -1] = {0}; (void)condition_failed[0]; };
		
		switch ((optmask >> 4) & 15) // get bitmask for flags (wconv wnorm eol escapes)
		{
		case 0:  return strconv_attribute_impl<opt_false>::parse_simple;
		case 1:  return strconv_attribute_impl<opt_true>::parse_simple;
		case 2:  return strconv_attribute_impl<opt_false>::parse_eol;
		case 3:  return strconv_attribute_impl<opt_true>::parse_eol;
		case 4:  return strconv_attribute_impl<opt_false>::parse_wconv;
		case 5:  return strconv_attribute_impl<opt_true>::parse_wconv;
		case 6:  return strconv_attribute_impl<opt_false>::parse_wconv;
		case 7:  return strconv_attribute_impl<opt_true>::parse_wconv;
		case 8:  return strconv_attribute_impl<opt_false>::parse_wnorm;
		case 9:  return strconv_attribute_impl<opt_true>::parse_wnorm;
		case 10: return strconv_attribute_impl<opt_false>::parse_wnorm;
		case 11: return strconv_attribute_impl<opt_true>::parse_wnorm;
		case 12: return strconv_attribute_impl<opt_false>::parse_wnorm;
		case 13: return strconv_attribute_impl<opt_true>::parse_wnorm;
		case 14: return strconv_attribute_impl<opt_false>::parse_wnorm;
		case 15: return strconv_attribute_impl<opt_true>::parse_wnorm;
		default: return 0; // should not get here
		}
	}

	inline xml_parse_result make_parse_result(xml_parse_status status, ptrdiff_t offset = 0)
	{
		xml_parse_result result;
		result.status = status;
		result.offset = offset;

		return result;
	}

	struct xml_parser
	{
		xml_allocator alloc;
		char_t* error_offset;
		xml_parse_status error_status;
		
		// Parser utilities.
		                      			                                                
		                         			                  
		                            		                                                                                                       
		                       			                            
		                        			                                
		                          		                    
		                      			                         
		                                 	                                                                    
		                                 	                                           
		
		xml_parser(const xml_allocator& alloc_): alloc(alloc_), error_offset(0), error_status(status_ok)
		{
		}

		// DOCTYPE consists of nested sections of the following possible types:
		// <!-- ... -->, <? ... ?>, "...", '...'
		// <![...]]>
		// <!...>
		// First group can not contain nested groups
		// Second group can contain nested groups of the same type
		// Third group can contain all other groups
		char_t* parse_doctype_primitive(char_t* s)
		{
			if (*s == '"' || *s == '\'')
			{
				// quoted string
				char_t ch = *s++;
				{ while (*s != 0 && !(*s == ch)) ++s; };
				if (!*s) return error_offset = s, error_status = status_bad_doctype, static_cast<char_t*>(0);

				s++;
			}
			else if (s[0] == '<' && s[1] == '?')
			{
				// <? ... ?>
				s += 2;
				{ while (*s != 0 && !(s[0] == '?' && s[1] == '>')) ++s; }; // no need for ENDSWITH because ?> can't terminate proper doctype
				if (!*s) return error_offset = s, error_status = status_bad_doctype, static_cast<char_t*>(0);

				s += 2;
			}
			else if (s[0] == '<' && s[1] == '!' && s[2] == '-' && s[3] == '-')
			{
				s += 4;
				{ while (*s != 0 && !(s[0] == '-' && s[1] == '-' && s[2] == '>')) ++s; }; // no need for ENDSWITH because --> can't terminate proper doctype
				if (!*s) return error_offset = s, error_status = status_bad_doctype, static_cast<char_t*>(0);

				s += 4;
			}
			else return error_offset = s, error_status = status_bad_doctype, static_cast<char_t*>(0);

			return s;
		}

		char_t* parse_doctype_ignore(char_t* s)
		{
			assert(s[0] == '<' && s[1] == '!' && s[2] == '[');
			s++;

			while (*s)
			{
				if (s[0] == '<' && s[1] == '!' && s[2] == '[')
				{
					// nested ignore section
					s = parse_doctype_ignore(s);
					if (!s) return s;
				}
				else if (s[0] == ']' && s[1] == ']' && s[2] == '>')
				{
					// ignore section end
					s += 3;

					return s;
				}
				else s++;
			}

			return error_offset = s, error_status = status_bad_doctype, static_cast<char_t*>(0);
		}

		char_t* parse_doctype_group(char_t* s, char_t endch, bool toplevel)
		{
			assert(s[0] == '<' && s[1] == '!');
			s++;

			while (*s)
			{
				if (s[0] == '<' && s[1] == '!' && s[2] != '-')
				{
					if (s[2] == '[')
					{
						// ignore
						s = parse_doctype_ignore(s);
						if (!s) return s;
					}
					else
					{
						// some control group
						s = parse_doctype_group(s, endch, false);
						if (!s) return s;
					}
				}
				else if (s[0] == '<' || s[0] == '"' || s[0] == '\'')
				{
					// unknown tag (forbidden), or some primitive group
					s = parse_doctype_primitive(s);
					if (!s) return s;
				}
				else if (*s == '>')
				{
					s++;

					return s;
				}
				else s++;
			}

			if (!toplevel || endch != '>') return error_offset = s, error_status = status_bad_doctype, static_cast<char_t*>(0);

			return s;
		}

		char_t* parse_exclamation(char_t* s, xml_node_struct* cursor, unsigned int optmsk, char_t endch)
		{
			// parse node contents, starting with exclamation mark
			++s;

			if (*s == '-') // '<!-...'
			{
				++s;

				if (*s == '-') // '<!--...'
				{
					++s;

					if (( optmsk & (parse_comments) ))
					{
						{ cursor = append_node(cursor, alloc, node_comment); if (!cursor) return error_offset = s, error_status = status_out_of_memory, static_cast<char_t*>(0); }; // Append a new node on the tree.
						cursor->value = s; // Save the offset.
					}

					if (( optmsk & (parse_eol) ) && ( optmsk & (parse_comments) ))
					{
						s = strconv_comment(s, endch);

						if (!s) return error_offset = cursor->value, error_status = status_bad_comment, static_cast<char_t*>(0);
					}
					else
					{
						// Scan for terminating '-->'.
						{ while (*s != 0 && !(s[0] == '-' && s[1] == '-' && ((s[2]) == ('>') || ((s[2]) == 0 && endch == ('>'))))) ++s; };
						{ if (*s == 0) return error_offset = s, error_status = status_bad_comment, static_cast<char_t*>(0); };

						if (( optmsk & (parse_comments) ))
							*s = 0; // Zero-terminate this segment at the first terminating '-'.

						s += (s[2] == '>' ? 3 : 2); // Step over the '\0->'.
					}
				}
				else return error_offset = s, error_status = status_bad_comment, static_cast<char_t*>(0);
			}
			else if (*s == '[')
			{
				// '<![CDATA[...'
				if (*++s=='C' && *++s=='D' && *++s=='A' && *++s=='T' && *++s=='A' && *++s == '[')
				{
					++s;

					if (( optmsk & (parse_cdata) ))
					{
						{ cursor = append_node(cursor, alloc, node_cdata); if (!cursor) return error_offset = s, error_status = status_out_of_memory, static_cast<char_t*>(0); }; // Append a new node on the tree.
						cursor->value = s; // Save the offset.

						if (( optmsk & (parse_eol) ))
						{
							s = strconv_cdata(s, endch);

							if (!s) return error_offset = cursor->value, error_status = status_bad_cdata, static_cast<char_t*>(0);
						}
						else
						{
							// Scan for terminating ']]>'.
							{ while (*s != 0 && !(s[0] == ']' && s[1] == ']' && ((s[2]) == ('>') || ((s[2]) == 0 && endch == ('>'))))) ++s; };
							{ if (*s == 0) return error_offset = s, error_status = status_bad_cdata, static_cast<char_t*>(0); };

							*s++ = 0; // Zero-terminate this segment.
						}
					}
					else // Flagged for discard, but we still have to scan for the terminator.
					{
						// Scan for terminating ']]>'.
						{ while (*s != 0 && !(s[0] == ']' && s[1] == ']' && ((s[2]) == ('>') || ((s[2]) == 0 && endch == ('>'))))) ++s; };
						{ if (*s == 0) return error_offset = s, error_status = status_bad_cdata, static_cast<char_t*>(0); };

						++s;
					}

					s += (s[1] == '>' ? 2 : 1); // Step over the last ']>'.
				}
				else return error_offset = s, error_status = status_bad_cdata, static_cast<char_t*>(0);
			}
			else if (s[0] == 'D' && s[1] == 'O' && s[2] == 'C' && s[3] == 'T' && s[4] == 'Y' && s[5] == 'P' && ((s[6]) == ('E') || ((s[6]) == 0 && endch == ('E'))))
			{
				s -= 2;

				if (cursor->parent) return error_offset = s, error_status = status_bad_doctype, static_cast<char_t*>(0);

				char_t* mark = s + 9;

				s = parse_doctype_group(s, endch, true);
				if (!s) return s;

				if (( optmsk & (parse_doctype) ))
				{
					while ((chartype_table[static_cast<unsigned char>(*mark)] & (ct_space))) ++mark;

					{ cursor = append_node(cursor, alloc, node_doctype); if (!cursor) return error_offset = s, error_status = status_out_of_memory, static_cast<char_t*>(0); };

					cursor->value = mark;

					assert((s[0] == 0 && endch == '>') || s[-1] == '>');
					s[*s == 0 ? 0 : -1] = 0;

					{ cursor = cursor->parent; };
				}
			}
			else if (*s == 0 && endch == '-') return error_offset = s, error_status = status_bad_comment, static_cast<char_t*>(0);
			else if (*s == 0 && endch == '[') return error_offset = s, error_status = status_bad_cdata, static_cast<char_t*>(0);
			else return error_offset = s, error_status = status_unrecognized_tag, static_cast<char_t*>(0);

			return s;
		}

		char_t* parse_question(char_t* s, xml_node_struct*& ref_cursor, unsigned int optmsk, char_t endch)
		{
			// load into registers
			xml_node_struct* cursor = ref_cursor;
			char_t ch = 0;

			// parse node contents, starting with question mark
			++s;

			// read PI target
			char_t* target = s;

			if (!(chartype_table[static_cast<unsigned char>(*s)] & (ct_start_symbol))) return error_offset = s, error_status = status_bad_pi, static_cast<char_t*>(0);

			{ while (((chartype_table[static_cast<unsigned char>(*s)] & (ct_symbol)))) ++s; };
			{ if (*s == 0) return error_offset = s, error_status = status_bad_pi, static_cast<char_t*>(0); };

			// determine node type; stricmp / strcasecmp is not portable
			bool declaration = (target[0] | ' ') == 'x' && (target[1] | ' ') == 'm' && (target[2] | ' ') == 'l' && target + 3 == s;

			if (declaration ? ( optmsk & (parse_declaration) ) : ( optmsk & (parse_pi) ))
			{
				if (declaration)
				{
					// disallow non top-level declarations
					if (cursor->parent) return error_offset = s, error_status = status_bad_pi, static_cast<char_t*>(0);

					{ cursor = append_node(cursor, alloc, node_declaration); if (!cursor) return error_offset = s, error_status = status_out_of_memory, static_cast<char_t*>(0); };
				}
				else
				{
					{ cursor = append_node(cursor, alloc, node_pi); if (!cursor) return error_offset = s, error_status = status_out_of_memory, static_cast<char_t*>(0); };
				}

				cursor->name = target;

				{ ch = *s; *s = 0; ++s; };

				// parse value/attributes
				if (ch == '?')
				{
					// empty node
					if (!((*s) == ('>') || ((*s) == 0 && endch == ('>')))) return error_offset = s, error_status = status_bad_pi, static_cast<char_t*>(0);
					s += (*s == '>');

					{ cursor = cursor->parent; };
				}
				else if ((chartype_table[static_cast<unsigned char>(ch)] & (ct_space)))
				{
					{ while ((chartype_table[static_cast<unsigned char>(*s)] & (ct_space))) ++s; };

					// scan for tag end
					char_t* value = s;

					{ while (*s != 0 && !(s[0] == '?' && ((s[1]) == ('>') || ((s[1]) == 0 && endch == ('>'))))) ++s; };
					{ if (*s == 0) return error_offset = s, error_status = status_bad_pi, static_cast<char_t*>(0); };

					if (declaration)
					{
						// replace ending ? with / so that 'element' terminates properly
						*s = '/';

						// we exit from this function with cursor at node_declaration, which is a signal to parse() to go to LOC_ATTRIBUTES
						s = value;
					}
					else
					{
						// store value and step over >
						cursor->value = value;
						{ cursor = cursor->parent; };

						{ ch = *s; *s = 0; ++s; };

						s += (*s == '>');
					}
				}
				else return error_offset = s, error_status = status_bad_pi, static_cast<char_t*>(0);
			}
			else
			{
				// scan for tag end
				{ while (*s != 0 && !(s[0] == '?' && ((s[1]) == ('>') || ((s[1]) == 0 && endch == ('>'))))) ++s; };
				{ if (*s == 0) return error_offset = s, error_status = status_bad_pi, static_cast<char_t*>(0); };

				s += (s[1] == '>' ? 2 : 1);
			}

			// store from registers
			ref_cursor = cursor;

			return s;
		}

		char_t* parse(char_t* s, xml_node_struct* xmldoc, unsigned int optmsk, char_t endch)
		{
			strconv_attribute_t strconv_attribute = get_strconv_attribute(optmsk);
			strconv_pcdata_t strconv_pcdata = get_strconv_pcdata(optmsk);
			
			char_t ch = 0;
			xml_node_struct* cursor = xmldoc;
			char_t* mark = s;

			while (*s != 0)
			{
				if (*s == '<')
				{
					++s;

				LOC_TAG:
					if ((chartype_table[static_cast<unsigned char>(*s)] & (ct_start_symbol))) // '<#...'
					{
						{ cursor = append_node(cursor, alloc, node_element); if (!cursor) return error_offset = s, error_status = status_out_of_memory, static_cast<char_t*>(0); }; // Append a new node to the tree.

						cursor->name = s;

						{ while (((chartype_table[static_cast<unsigned char>(*s)] & (ct_symbol)))) ++s; }; // Scan for a terminator.
						{ ch = *s; *s = 0; ++s; }; // Save char in 'ch', terminate & step over.

						if (ch == '>')
						{
							// end of tag
						}
						else if ((chartype_table[static_cast<unsigned char>(ch)] & (ct_space)))
						{
						LOC_ATTRIBUTES:
							while (true)
							{
								{ while ((chartype_table[static_cast<unsigned char>(*s)] & (ct_space))) ++s; }; // Eat any whitespace.
						
								if ((chartype_table[static_cast<unsigned char>(*s)] & (ct_start_symbol))) // <... #...
								{
									xml_attribute_struct* a = append_attribute_ll(cursor, alloc); // Make space for this attribute.
									if (!a) return error_offset = s, error_status = status_out_of_memory, static_cast<char_t*>(0);

									a->name = s; // Save the offset.

									{ while (((chartype_table[static_cast<unsigned char>(*s)] & (ct_symbol)))) ++s; }; // Scan for a terminator.
									{ if (*s == 0) return error_offset = s, error_status = status_bad_attribute, static_cast<char_t*>(0); }; //$ redundant, left for performance

									{ ch = *s; *s = 0; ++s; }; // Save char in 'ch', terminate & step over.
									{ if (*s == 0) return error_offset = s, error_status = status_bad_attribute, static_cast<char_t*>(0); }; //$ redundant, left for performance

									if ((chartype_table[static_cast<unsigned char>(ch)] & (ct_space)))
									{
										{ while ((chartype_table[static_cast<unsigned char>(*s)] & (ct_space))) ++s; }; // Eat any whitespace.
										{ if (*s == 0) return error_offset = s, error_status = status_bad_attribute, static_cast<char_t*>(0); }; //$ redundant, left for performance

										ch = *s;
										++s;
									}
									
									if (ch == '=') // '<... #=...'
									{
										{ while ((chartype_table[static_cast<unsigned char>(*s)] & (ct_space))) ++s; }; // Eat any whitespace.

										if (*s == '"' || *s == '\'') // '<... #="...'
										{
											ch = *s; // Save quote char to avoid breaking on "''" -or- '""'.
											++s; // Step over the quote.
											a->value = s; // Save the offset.

											s = strconv_attribute(s, ch);
										
											if (!s) return error_offset = a->value, error_status = status_bad_attribute, static_cast<char_t*>(0);

											// After this line the loop continues from the start;
											// Whitespaces, / and > are ok, symbols and EOF are wrong,
											// everything else will be detected
											if ((chartype_table[static_cast<unsigned char>(*s)] & (ct_start_symbol))) return error_offset = s, error_status = status_bad_attribute, static_cast<char_t*>(0);
										}
										else return error_offset = s, error_status = status_bad_attribute, static_cast<char_t*>(0);
									}
									else return error_offset = s, error_status = status_bad_attribute, static_cast<char_t*>(0);
								}
								else if (*s == '/')
								{
									++s;
									
									if (*s == '>')
									{
										{ cursor = cursor->parent; };
										s++;
										break;
									}
									else if (*s == 0 && endch == '>')
									{
										{ cursor = cursor->parent; };
										break;
									}
									else return error_offset = s, error_status = status_bad_start_element, static_cast<char_t*>(0);
								}
								else if (*s == '>')
								{
									++s;

									break;
								}
								else if (*s == 0 && endch == '>')
								{
									break;
								}
								else return error_offset = s, error_status = status_bad_start_element, static_cast<char_t*>(0);
							}

							// !!!
						}
						else if (ch == '/') // '<#.../'
						{
							if (!((*s) == ('>') || ((*s) == 0 && endch == ('>')))) return error_offset = s, error_status = status_bad_start_element, static_cast<char_t*>(0);

							{ cursor = cursor->parent; }; // Pop.

							s += (*s == '>');
						}
						else if (ch == 0)
						{
							// we stepped over null terminator, backtrack & handle closing tag
							--s;
							
							if (endch != '>') return error_offset = s, error_status = status_bad_start_element, static_cast<char_t*>(0);
						}
						else return error_offset = s, error_status = status_bad_start_element, static_cast<char_t*>(0);
					}
					else if (*s == '/')
					{
						++s;

						char_t* name = cursor->name;
						if (!name) return error_offset = s, error_status = status_end_element_mismatch, static_cast<char_t*>(0);
						
						while ((chartype_table[static_cast<unsigned char>(*s)] & (ct_symbol)))
						{
							if (*s++ != *name++) return error_offset = s, error_status = status_end_element_mismatch, static_cast<char_t*>(0);
						}

						if (*name)
						{
							if (*s == 0 && name[0] == endch && name[1] == 0) return error_offset = s, error_status = status_bad_end_element, static_cast<char_t*>(0);
							else return error_offset = s, error_status = status_end_element_mismatch, static_cast<char_t*>(0);
						}
							
						{ cursor = cursor->parent; }; // Pop.

						{ while ((chartype_table[static_cast<unsigned char>(*s)] & (ct_space))) ++s; };

						if (*s == 0)
						{
							if (endch != '>') return error_offset = s, error_status = status_bad_end_element, static_cast<char_t*>(0);
						}
						else
						{
							if (*s != '>') return error_offset = s, error_status = status_bad_end_element, static_cast<char_t*>(0);
							++s;
						}
					}
					else if (*s == '?') // '<?...'
					{
						s = parse_question(s, cursor, optmsk, endch);
						if (!s) return s;

						assert(cursor);
						if ((cursor->header & xml_memory_page_type_mask) + 1 == node_declaration) goto LOC_ATTRIBUTES;
					}
					else if (*s == '!') // '<!...'
					{
						s = parse_exclamation(s, cursor, optmsk, endch);
						if (!s) return s;
					}
					else if (*s == 0 && endch == '?') return error_offset = s, error_status = status_bad_pi, static_cast<char_t*>(0);
					else return error_offset = s, error_status = status_unrecognized_tag, static_cast<char_t*>(0);
				}
				else
				{
					mark = s; // Save this offset while searching for a terminator.

					{ while ((chartype_table[static_cast<unsigned char>(*s)] & (ct_space))) ++s; }; // Eat whitespace if no genuine PCDATA here.

					if (*s == '<')
					{
						// We skipped some whitespace characters because otherwise we would take the tag branch instead of PCDATA one
						assert(mark != s);

						if (!( optmsk & (parse_ws_pcdata | parse_ws_pcdata_single) ))
						{
							continue;
						}
						else if (( optmsk & (parse_ws_pcdata_single) ))
						{
							if (s[1] != '/' || cursor->first_child) continue;
						}
					}

					s = mark;
							
					if (cursor->parent)
					{
						{ cursor = append_node(cursor, alloc, node_pcdata); if (!cursor) return error_offset = s, error_status = status_out_of_memory, static_cast<char_t*>(0); }; // Append a new node on the tree.
						cursor->value = s; // Save the offset.

						s = strconv_pcdata(s);
								
						{ cursor = cursor->parent; }; // Pop since this is a standalone.
						
						if (!*s) break;
					}
					else
					{
						{ while (*s != 0 && !(*s == '<')) ++s; }; // '...<'
						if (!*s) break;
						
						++s;
					}

					// We're after '<'
					goto LOC_TAG;
				}
			}

			// check that last tag is closed
			if (cursor != xmldoc) return error_offset = s, error_status = status_end_element_mismatch, static_cast<char_t*>(0);

			return s;
		}

		static xml_parse_result parse(char_t* buffer, size_t length, xml_node_struct* root, unsigned int optmsk)
		{
			xml_document_struct* xmldoc = static_cast<xml_document_struct*>(root);

			// store buffer for offset_debug
			xmldoc->buffer = buffer;

			// early-out for empty documents
			if (length == 0) return make_parse_result(status_ok);

			// create parser on stack
			xml_parser parser(*xmldoc);

			// save last character and make buffer zero-terminated (speeds up parsing)
			char_t endch = buffer[length - 1];
			buffer[length - 1] = 0;
			
			// perform actual parsing
			parser.parse(buffer, xmldoc, optmsk, endch);

			xml_parse_result result = make_parse_result(parser.error_status, parser.error_offset ? parser.error_offset - buffer : 0);
			assert(result.offset >= 0 && static_cast<size_t>(result.offset) <= length);

			// update allocator state
			*static_cast<xml_allocator*>(xmldoc) = parser.alloc;

			// since we removed last character, we have to handle the only possible false positive
			if (result && endch == '<')
			{
				// there's no possible well-formed document with < at the end
				return make_parse_result(status_unrecognized_tag, length);
			}

			return result;
		}
	};

	// Output facilities
	 xml_encoding get_write_native_encoding()
	{
	                         
		                            
	     
		return encoding_utf8;
	      
	}

	 xml_encoding get_write_encoding(xml_encoding encoding)
	{
		// replace wchar encoding with utf implementation
		if (encoding == encoding_wchar) return get_wchar_encoding();

		// replace utf16 encoding with utf16 with specific endianness
		if (encoding == encoding_utf16) return is_little_endian() ? encoding_utf16_le : encoding_utf16_be;

		// replace utf32 encoding with utf32 with specific endianness
		if (encoding == encoding_utf32) return is_little_endian() ? encoding_utf32_le : encoding_utf32_be;

		// only do autodetection if no explicit encoding is requested
		if (encoding != encoding_auto) return encoding;

		// assume utf8 encoding
		return encoding_utf8;
	}

                         
	                                                                   
	 
		                   

		                                                               
		                                                                                                                                           
	 

	                                                                                                                                                         
	 
		                                   
		                                                         
		 
			                                                

			                               
		 
	
		                  
		                              
		 
			                     
			                                                                                

			                                       
		 

		                   
		                                                                   
		 
			                       

			                          
			                                                                                  

			                    
			                                                                                          

			                                                                                                      

			                                                          
		 

		                   
		                                                                   
		 
			                       

			                          
			                                                                                  

			                    
			                                                                                          

			                                                                                                      

			                                                          
		 

		                    
		                                
		 
			                     
			                                                                                  

			                                       
		 

		                            
		         
	 
     
	 size_t get_valid_length(const char_t* data, size_t length)
	{
		assert(length > 4);

		for (size_t i = 1; i <= 4; ++i)
		{
			uint8_t ch = static_cast<uint8_t>(data[length - i]);

			// either a standalone character or a leading one
			if ((ch & 0xc0) != 0x80) return length - i;
		}

		// there are four non-leading characters at the end, sequence tail is broken so might as well process the whole chunk
		return length;
	}

	 size_t convert_buffer(char_t* /* r_char */, uint8_t* r_u8, uint16_t* r_u16, uint32_t* r_u32, const char_t* data, size_t length, xml_encoding encoding)
	{
		if (encoding == encoding_utf16_be || encoding == encoding_utf16_le)
		{
			uint16_t* dest = r_u16;

			// convert to native utf16
			uint16_t* end = utf_decoder<utf16_writer>::decode_utf8_block(reinterpret_cast<const uint8_t*>(data), length, dest);

			// swap if necessary
			xml_encoding native_encoding = is_little_endian() ? encoding_utf16_le : encoding_utf16_be;

			if (native_encoding != encoding) convert_utf_endian_swap(dest, dest, static_cast<size_t>(end - dest));

			return static_cast<size_t>(end - dest) * sizeof(uint16_t);
		}

		if (encoding == encoding_utf32_be || encoding == encoding_utf32_le)
		{
			uint32_t* dest = r_u32;

			// convert to native utf32
			uint32_t* end = utf_decoder<utf32_writer>::decode_utf8_block(reinterpret_cast<const uint8_t*>(data), length, dest);

			// swap if necessary
			xml_encoding native_encoding = is_little_endian() ? encoding_utf32_le : encoding_utf32_be;

			if (native_encoding != encoding) convert_utf_endian_swap(dest, dest, static_cast<size_t>(end - dest));

			return static_cast<size_t>(end - dest) * sizeof(uint32_t);
		}

		if (encoding == encoding_latin1)
		{
			uint8_t* dest = r_u8;
			uint8_t* end = utf_decoder<latin1_writer>::decode_utf8_block(reinterpret_cast<const uint8_t*>(data), length, dest);

			return static_cast<size_t>(end - dest);
		}

		assert(!"Invalid encoding");
		return 0;
	}
      

	class xml_buffered_writer
	{
		xml_buffered_writer(const xml_buffered_writer&);
		xml_buffered_writer& operator=(const xml_buffered_writer&);

	public:
		xml_buffered_writer(xml_writer& writer_, xml_encoding user_encoding): writer(writer_), bufsize(0), encoding(get_write_encoding(user_encoding))
		{
			{ static const char condition_failed[(bufcapacity >= 8) ? 1 : -1] = {0}; (void)condition_failed[0]; };
		}

		~xml_buffered_writer()
		{
			flush();
		}

		void flush()
		{
			flush(buffer, bufsize);
			bufsize = 0;
		}

		void flush(const char_t* data, size_t size)
		{
			if (size == 0) return;

			// fast path, just write data
			if (encoding == get_write_native_encoding())
				writer.write(data, size * sizeof(char_t));
			else
			{
				// convert chunk
				size_t result = convert_buffer(scratch.data_char, scratch.data_u8, scratch.data_u16, scratch.data_u32, data, size, encoding);
				assert(result <= sizeof(scratch));

				// write data
				writer.write(scratch.data_u8, result);
			}
		}

		void write(const char_t* data, size_t length)
		{
			if (bufsize + length > bufcapacity)
			{
				// flush the remaining buffer contents
				flush();

				// handle large chunks
				if (length > bufcapacity)
				{
					if (encoding == get_write_native_encoding())
					{
						// fast path, can just write data chunk
						writer.write(data, length * sizeof(char_t));
						return;
					}

					// need to convert in suitable chunks
					while (length > bufcapacity)
					{
						// get chunk size by selecting such number of characters that are guaranteed to fit into scratch buffer
						// and form a complete codepoint sequence (i.e. discard start of last codepoint if necessary)
						size_t chunk_size = get_valid_length(data, bufcapacity);

						// convert chunk and write
						flush(data, chunk_size);

						// iterate
						data += chunk_size;
						length -= chunk_size;
					}

					// small tail is copied below
					bufsize = 0;
				}
			}

			memcpy(buffer + bufsize, data, length * sizeof(char_t));
			bufsize += length;
		}

		void write(const char_t* data)
		{
			write(data, strlength(data));
		}

		void write(char_t d0)
		{
			if (bufsize + 1 > bufcapacity) flush();

			buffer[bufsize + 0] = d0;
			bufsize += 1;
		}

		void write(char_t d0, char_t d1)
		{
			if (bufsize + 2 > bufcapacity) flush();

			buffer[bufsize + 0] = d0;
			buffer[bufsize + 1] = d1;
			bufsize += 2;
		}

		void write(char_t d0, char_t d1, char_t d2)
		{
			if (bufsize + 3 > bufcapacity) flush();

			buffer[bufsize + 0] = d0;
			buffer[bufsize + 1] = d1;
			buffer[bufsize + 2] = d2;
			bufsize += 3;
		}

		void write(char_t d0, char_t d1, char_t d2, char_t d3)
		{
			if (bufsize + 4 > bufcapacity) flush();

			buffer[bufsize + 0] = d0;
			buffer[bufsize + 1] = d1;
			buffer[bufsize + 2] = d2;
			buffer[bufsize + 3] = d3;
			bufsize += 4;
		}

		void write(char_t d0, char_t d1, char_t d2, char_t d3, char_t d4)
		{
			if (bufsize + 5 > bufcapacity) flush();

			buffer[bufsize + 0] = d0;
			buffer[bufsize + 1] = d1;
			buffer[bufsize + 2] = d2;
			buffer[bufsize + 3] = d3;
			buffer[bufsize + 4] = d4;
			bufsize += 5;
		}

		void write(char_t d0, char_t d1, char_t d2, char_t d3, char_t d4, char_t d5)
		{
			if (bufsize + 6 > bufcapacity) flush();

			buffer[bufsize + 0] = d0;
			buffer[bufsize + 1] = d1;
			buffer[bufsize + 2] = d2;
			buffer[bufsize + 3] = d3;
			buffer[bufsize + 4] = d4;
			buffer[bufsize + 5] = d5;
			bufsize += 6;
		}

		// utf8 maximum expansion: x4 (-> utf32)
		// utf16 maximum expansion: x2 (-> utf32)
		// utf32 maximum expansion: x1
		enum
		{
			bufcapacitybytes =
			                                  
				                           
			     
				10240
			      
			,
			bufcapacity = bufcapacitybytes / (sizeof(char_t) + 4)
		};

		char_t buffer[bufcapacity];

		union
		{
			uint8_t data_u8[4 * bufcapacity];
			uint16_t data_u16[2 * bufcapacity];
			uint32_t data_u32[bufcapacity];
			char_t data_char[bufcapacity];
		} scratch;

		xml_writer& writer;
		size_t bufsize;
		xml_encoding encoding;
	};

	 void text_output_escaped(xml_buffered_writer& writer, const char_t* s, chartypex_t type)
	{
		while (*s)
		{
			const char_t* prev = s;
			
			// While *s is a usual symbol
			while (!(chartypex_table[static_cast<unsigned char>(*s)] & (type))) ++s;
		
			writer.write(prev, static_cast<size_t>(s - prev));

			switch (*s)
			{
				case 0: break;
				case '&':
					writer.write('&', 'a', 'm', 'p', ';');
					++s;
					break;
				case '<':
					writer.write('&', 'l', 't', ';');
					++s;
					break;
				case '>':
					writer.write('&', 'g', 't', ';');
					++s;
					break;
				case '"':
					writer.write('&', 'q', 'u', 'o', 't', ';');
					++s;
					break;
				default: // s is not a usual symbol
				{
					unsigned int ch = static_cast<unsigned int>(*s++);
					assert(ch < 32);

					writer.write('&', '#', static_cast<char_t>((ch / 10) + '0'), static_cast<char_t>((ch % 10) + '0'), ';');
				}
			}
		}
	}

	 void text_output(xml_buffered_writer& writer, const char_t* s, chartypex_t type, unsigned int flags)
	{
		if (flags & format_no_escapes)
			writer.write(s);
		else
			text_output_escaped(writer, s, type);
	}

	 void text_output_cdata(xml_buffered_writer& writer, const char_t* s)
	{
		do
		{
			writer.write('<', '!', '[', 'C', 'D');
			writer.write('A', 'T', 'A', '[');

			const char_t* prev = s;

			// look for ]]> sequence - we can't output it as is since it terminates CDATA
			while (*s && !(s[0] == ']' && s[1] == ']' && s[2] == '>')) ++s;

			// skip ]] if we stopped at ]]>, > will go to the next CDATA section
			if (*s) s += 2;

			writer.write(prev, static_cast<size_t>(s - prev));

			writer.write(']', ']', '>');
		}
		while (*s);
	}

	 void node_output_attributes(xml_buffered_writer& writer, const xml_node& node, unsigned int flags)
	{
		const char_t* default_name = ":anonymous";

		for (xml_attribute a = node.first_attribute(); a; a = a.next_attribute())
		{
			writer.write(' ');
			writer.write(a.name()[0] ? a.name() : default_name);
			writer.write('=', '"');

			text_output(writer, a.value(), ctx_special_attr, flags);

			writer.write('"');
		}
	}

	 void node_output(xml_buffered_writer& writer, const xml_node& node, const char_t* indent, unsigned int flags, unsigned int depth)
	{
		const char_t* default_name = ":anonymous";

		if ((flags & format_indent) != 0 && (flags & format_raw) == 0)
			for (unsigned int i = 0; i < depth; ++i) writer.write(indent);

		switch (node.type())
		{
		case node_document:
		{
			for (xml_node n = node.first_child(); n; n = n.next_sibling())
				node_output(writer, n, indent, flags, depth);
			break;
		}
			
		case node_element:
		{
			const char_t* name = node.name()[0] ? node.name() : default_name;

			writer.write('<');
			writer.write(name);

			node_output_attributes(writer, node, flags);

			if (flags & format_raw)
			{
				if (!node.first_child())
					writer.write(' ', '/', '>');
				else
				{
					writer.write('>');

					for (xml_node n = node.first_child(); n; n = n.next_sibling())
						node_output(writer, n, indent, flags, depth + 1);

					writer.write('<', '/');
					writer.write(name);
					writer.write('>');
				}
			}
			else if (!node.first_child())
				writer.write(' ', '/', '>', '\n');
			else if (node.first_child() == node.last_child() && (node.first_child().type() == node_pcdata || node.first_child().type() == node_cdata))
			{
				writer.write('>');

				if (node.first_child().type() == node_pcdata)
					text_output(writer, node.first_child().value(), ctx_special_pcdata, flags);
				else
					text_output_cdata(writer, node.first_child().value());

				writer.write('<', '/');
				writer.write(name);
				writer.write('>', '\n');
			}
			else
			{
				writer.write('>', '\n');
				
				for (xml_node n = node.first_child(); n; n = n.next_sibling())
					node_output(writer, n, indent, flags, depth + 1);

				if ((flags & format_indent) != 0 && (flags & format_raw) == 0)
					for (unsigned int i = 0; i < depth; ++i) writer.write(indent);
				
				writer.write('<', '/');
				writer.write(name);
				writer.write('>', '\n');
			}

			break;
		}
		
		case node_pcdata:
			text_output(writer, node.value(), ctx_special_pcdata, flags);
			if ((flags & format_raw) == 0) writer.write('\n');
			break;

		case node_cdata:
			text_output_cdata(writer, node.value());
			if ((flags & format_raw) == 0) writer.write('\n');
			break;

		case node_comment:
			writer.write('<', '!', '-', '-');
			writer.write(node.value());
			writer.write('-', '-', '>');
			if ((flags & format_raw) == 0) writer.write('\n');
			break;

		case node_pi:
		case node_declaration:
			writer.write('<', '?');
			writer.write(node.name()[0] ? node.name() : default_name);

			if (node.type() == node_declaration)
			{
				node_output_attributes(writer, node, flags);
			}
			else if (node.value()[0])
			{
				writer.write(' ');
				writer.write(node.value());
			}

			writer.write('?', '>');
			if ((flags & format_raw) == 0) writer.write('\n');
			break;

		case node_doctype:
			writer.write('<', '!', 'D', 'O', 'C');
			writer.write('T', 'Y', 'P', 'E');

			if (node.value()[0])
			{
				writer.write(' ');
				writer.write(node.value());
			}

			writer.write('>');
			if ((flags & format_raw) == 0) writer.write('\n');
			break;

		default:
			assert(!"Invalid node type");
		}
	}

	inline bool has_declaration(const xml_node& node)
	{
		for (xml_node child = node.first_child(); child; child = child.next_sibling())
		{
			xml_node_type type = child.type();

			if (type == node_declaration) return true;
			if (type == node_element) return false;
		}

		return false;
	}

	inline bool allow_insert_child(xml_node_type parent, xml_node_type child)
	{
		if (parent != node_document && parent != node_element) return false;
		if (child == node_document || child == node_null) return false;
		if (parent != node_document && (child == node_declaration || child == node_doctype)) return false;

		return true;
	}

	 void recursive_copy_skip(xml_node& dest, const xml_node& source, const xml_node& skip)
	{
		assert(dest.type() == source.type());

		switch (source.type())
		{
		case node_element:
		{
			dest.set_name(source.name());

			for (xml_attribute a = source.first_attribute(); a; a = a.next_attribute())
				dest.append_attribute(a.name()).set_value(a.value());

			for (xml_node c = source.first_child(); c; c = c.next_sibling())
			{
				if (c == skip) continue;

				xml_node cc = dest.append_child(c.type());
				assert(cc);

				recursive_copy_skip(cc, c, skip);
			}

			break;
		}

		case node_pcdata:
		case node_cdata:
		case node_comment:
		case node_doctype:
			dest.set_value(source.value());
			break;

		case node_pi:
			dest.set_name(source.name());
			dest.set_value(source.value());
			break;

		case node_declaration:
		{
			dest.set_name(source.name());

			for (xml_attribute a = source.first_attribute(); a; a = a.next_attribute())
				dest.append_attribute(a.name()).set_value(a.value());

			break;
		}

		default:
			assert(!"Invalid node type");
		}
	}

	inline bool is_text_node(xml_node_struct* node)
	{
		xml_node_type type = static_cast<xml_node_type>((node->header & impl::xml_memory_page_type_mask) + 1);

		return type == node_pcdata || type == node_cdata;
	}

	// get value with conversion functions
	 int get_value_int(const char_t* value, int def)
	{
		if (!value) return def;

	                         
		                                              
	     
		return static_cast<int>(strtol(value, 0, 10));
	      
	}

	 unsigned int get_value_uint(const char_t* value, unsigned int def)
	{
		if (!value) return def;

	                         
		                                                        
	     
		return static_cast<unsigned int>(strtoul(value, 0, 10));
	      
	}

	 double get_value_double(const char_t* value, double def)
	{
		if (!value) return def;

	                         
		                        
	     
		return strtod(value, 0);
	      
	}

	 float get_value_float(const char_t* value, float def)
	{
		if (!value) return def;

	                         
		                                            
	     
		return static_cast<float>(strtod(value, 0));
	      
	}

	 bool get_value_bool(const char_t* value, bool def)
	{
		if (!value) return def;

		// only look at first char
		char_t first = *value;

		// 1*, t* (true), T* (True), y* (yes), Y* (YES)
		return (first == '1' || first == 't' || first == 'T' || first == 'y' || first == 'Y');
	}

	// set value with conversion functions
	 bool set_value_buffer(char_t*& dest, uintptr_t& header, uintptr_t header_mask, char (&buf)[128])
	{
	                         
		                 
		                             

		                                                      
	     
		return strcpy_insitu(dest, header, header_mask, buf);
	      
	}

	 bool set_value_convert(char_t*& dest, uintptr_t& header, uintptr_t header_mask, int value)
	{
		char buf[128];
		sprintf(buf, "%d", value);
	
		return set_value_buffer(dest, header, header_mask, buf);
	}

	 bool set_value_convert(char_t*& dest, uintptr_t& header, uintptr_t header_mask, unsigned int value)
	{
		char buf[128];
		sprintf(buf, "%u", value);

		return set_value_buffer(dest, header, header_mask, buf);
	}

	 bool set_value_convert(char_t*& dest, uintptr_t& header, uintptr_t header_mask, double value)
	{
		char buf[128];
		sprintf(buf, "%g", value);

		return set_value_buffer(dest, header, header_mask, buf);
	}
	
	 bool set_value_convert(char_t*& dest, uintptr_t& header, uintptr_t header_mask, bool value)
	{
		return strcpy_insitu(dest, header, header_mask, value ? "true" : "false");
	}

	// we need to get length of entire file to load it in memory; the only (relatively) sane way to do it is via seek/tell trick
	 xml_parse_status get_file_size(FILE* file, size_t& out_result)
	{
	                                                                                             
		                                                           
		                            

		                             
		                                     
		                             
	                                                                                   
		                                                           
		                            

		                            
		                                    
		                            
	     
		// if this is a 32-bit OS, long is enough; if this is a unix system, long is 64-bit, which is enough; otherwise we can't do anything anyway.
		typedef long length_type;

		fseek(file, 0, SEEK_END);
		length_type length = ftell(file);
		fseek(file, 0, SEEK_SET);
	      

		// check for I/O errors
		if (length < 0) return status_io_error;
		
		// check for overflow
		size_t result = static_cast<size_t>(length);

		if (static_cast<length_type>(result) != length) return status_out_of_memory;

		// finalize
		out_result = result;

		return status_ok;
	}

	 xml_parse_result load_file_impl(xml_document& doc, FILE* file, unsigned int options, xml_encoding encoding)
	{
		if (!file) return make_parse_result(status_file_not_found);

		// get file size (can result in I/O errors)
		size_t size = 0;
		xml_parse_status size_status = get_file_size(file, size);

		if (size_status != status_ok)
		{
			fclose(file);
			return make_parse_result(size_status);
		}
		
		// allocate buffer for the whole file
		char* contents = static_cast<char*>(xml_memory::allocate(size > 0 ? size : 1));

		if (!contents)
		{
			fclose(file);
			return make_parse_result(status_out_of_memory);
		}

		// read file in memory
		size_t read_size = fread(contents, 1, size, file);
		fclose(file);

		if (read_size != size)
		{
			xml_memory::deallocate(contents);
			return make_parse_result(status_io_error);
		}
		
		return doc.load_buffer_inplace_own(contents, size, options, encoding);
	}

                      
	template <typename T> struct xml_stream_chunk
	{
		static xml_stream_chunk* create()
		{
			void* memory = xml_memory::allocate(sizeof(xml_stream_chunk));
			
			return new (memory) xml_stream_chunk();
		}

		static void destroy(void* ptr)
		{
			xml_stream_chunk* chunk = static_cast<xml_stream_chunk*>(ptr);

			// free chunk chain
			while (chunk)
			{
				xml_stream_chunk* next = chunk->next;
				xml_memory::deallocate(chunk);
				chunk = next;
			}
		}

		xml_stream_chunk(): next(0), size(0)
		{
		}

		xml_stream_chunk* next;
		size_t size;

		T data[xml_memory_page_size / sizeof(T)];
	};

	template <typename T>  xml_parse_status load_stream_data_noseek(std::basic_istream<T>& stream, void** out_buffer, size_t* out_size)
	{
		buffer_holder chunks(0, xml_stream_chunk<T>::destroy);

		// read file to a chunk list
		size_t total = 0;
		xml_stream_chunk<T>* last = 0;

		while (!stream.eof())
		{
			// allocate new chunk
			xml_stream_chunk<T>* chunk = xml_stream_chunk<T>::create();
			if (!chunk) return status_out_of_memory;

			// append chunk to list
			if (last) last = last->next = chunk;
			else chunks.data = last = chunk;

			// read data to chunk
			stream.read(chunk->data, static_cast<std::streamsize>(sizeof(chunk->data) / sizeof(T)));
			chunk->size = static_cast<size_t>(stream.gcount()) * sizeof(T);

			// read may set failbit | eofbit in case gcount() is less than read length, so check for other I/O errors
			if (stream.bad() || (!stream.eof() && stream.fail())) return status_io_error;

			// guard against huge files (chunk size is small enough to make this overflow check work)
			if (total + chunk->size < total) return status_out_of_memory;
			total += chunk->size;
		}

		// copy chunk list to a contiguous buffer
		char* buffer = static_cast<char*>(xml_memory::allocate(total));
		if (!buffer) return status_out_of_memory;

		char* write = buffer;

		for (xml_stream_chunk<T>* chunk = static_cast<xml_stream_chunk<T>*>(chunks.data); chunk; chunk = chunk->next)
		{
			assert(write + chunk->size <= buffer + total);
			memcpy(write, chunk->data, chunk->size);
			write += chunk->size;
		}

		assert(write == buffer + total);

		// return buffer
		*out_buffer = buffer;
		*out_size = total;

		return status_ok;
	}

	template <typename T>  xml_parse_status load_stream_data_seek(std::basic_istream<T>& stream, void** out_buffer, size_t* out_size)
	{
		// get length of remaining data in stream
		typename std::basic_istream<T>::pos_type pos = stream.tellg();
		stream.seekg(0, std::ios::end);
		std::streamoff length = stream.tellg() - pos;
		stream.seekg(pos);

		if (stream.fail() || pos < 0) return status_io_error;

		// guard against huge files
		size_t read_length = static_cast<size_t>(length);

		if (static_cast<std::streamsize>(read_length) != length || length < 0) return status_out_of_memory;

		// read stream data into memory (guard against stream exceptions with buffer holder)
		buffer_holder buffer(xml_memory::allocate((read_length > 0 ? read_length : 1) * sizeof(T)), xml_memory::deallocate);
		if (!buffer.data) return status_out_of_memory;

		stream.read(static_cast<T*>(buffer.data), static_cast<std::streamsize>(read_length));

		// read may set failbit | eofbit in case gcount() is less than read_length (i.e. line ending conversion), so check for other I/O errors
		if (stream.bad() || (!stream.eof() && stream.fail())) return status_io_error;

		// return buffer
		size_t actual_length = static_cast<size_t>(stream.gcount());
		assert(actual_length <= read_length);

		*out_buffer = buffer.release();
		*out_size = actual_length * sizeof(T);

		return status_ok;
	}

	template <typename T>  xml_parse_result load_stream_impl(xml_document& doc, std::basic_istream<T>& stream, unsigned int options, xml_encoding encoding)
	{
		void* buffer = 0;
		size_t size = 0;

		// load stream to memory (using seek-based implementation if possible, since it's faster and takes less memory)
		xml_parse_status status = (stream.tellg() < 0) ? load_stream_data_noseek(stream, &buffer, &size) : load_stream_data_seek(stream, &buffer, &size);
		if (status != status_ok) return make_parse_result(status);

		return doc.load_buffer_inplace_own(buffer, size, options, encoding);
	}
      

                                                                                                                   
	                                                                       
	 
		                           
	 
     
	 char* convert_path_heap(const wchar_t* str)
	{
		assert(str);

		// first pass: get length in utf8 characters
		size_t length = wcslen(str);
		size_t size = as_utf8_begin(str, length);

		// allocate resulting string
		char* result = static_cast<char*>(xml_memory::allocate(size + 1));
		if (!result) return 0;

		// second pass: convert to utf8
		as_utf8_end(result, size, str, length);

		return result;
	}

	 FILE* open_file_wide(const wchar_t* path, const wchar_t* mode)
	{
		// there is no standard function to open wide paths, so our best bet is to try utf8 path
		char* path_utf8 = convert_path_heap(path);
		if (!path_utf8) return 0;

		// convert mode to ASCII (we mirror _wfopen interface)
		char mode_ascii[4] = {0};
		for (size_t i = 0; mode[i]; ++i) mode_ascii[i] = static_cast<char>(mode[i]);

		// try to open the utf8 path
		FILE* result = fopen(path_utf8, mode_ascii);

		// free dummy buffer
		xml_memory::deallocate(path_utf8);

		return result;
	}
      

	 bool save_file_impl(const xml_document& doc, FILE* file, const char_t* indent, unsigned int flags, xml_encoding encoding)
	{
		if (!file) return false;

		xml_writer_file writer(file);
		doc.save(writer, indent, flags, encoding);

		int result = ferror(file);

		fclose(file);

		return result == 0;
	}
} } }

namespace pugi
{
	 xml_writer_file::xml_writer_file(void* file_): file(file_)
	{
	}

	 void xml_writer_file::write(const void* data, size_t size)
	{
		size_t result = fwrite(data, 1, size, static_cast<FILE*>(file));
		(void)!result; // unfortunately we can't do proper error handling here
	}

                      
	 xml_writer_stream::xml_writer_stream(std::basic_ostream<char, std::char_traits<char> >& stream): narrow_stream(&stream), wide_stream(0)
	{
	}

	 xml_writer_stream::xml_writer_stream(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& stream): narrow_stream(0), wide_stream(&stream)
	{
	}

	 void xml_writer_stream::write(const void* data, size_t size)
	{
		if (narrow_stream)
		{
			assert(!wide_stream);
			narrow_stream->write(reinterpret_cast<const char*>(data), static_cast<std::streamsize>(size));
		}
		else
		{
			assert(wide_stream);
			assert(size % sizeof(wchar_t) == 0);

			wide_stream->write(reinterpret_cast<const wchar_t*>(data), static_cast<std::streamsize>(size / sizeof(wchar_t)));
		}
	}
      

	 xml_tree_walker::xml_tree_walker(): _depth(0)
	{
	}
	
	 xml_tree_walker::~xml_tree_walker()
	{
	}

	 int xml_tree_walker::depth() const
	{
		return _depth;
	}

	 bool xml_tree_walker::begin(xml_node&)
	{
		return true;
	}

	 bool xml_tree_walker::end(xml_node&)
	{
		return true;
	}

	 xml_attribute::xml_attribute(): _attr(0)
	{
	}

	 xml_attribute::xml_attribute(xml_attribute_struct* attr): _attr(attr)
	{
	}

	 static void unspecified_bool_xml_attribute(xml_attribute***)
	{
	}

	 xml_attribute::operator xml_attribute::unspecified_bool_type() const
	{
		return _attr ? unspecified_bool_xml_attribute : 0;
	}

	 bool xml_attribute::operator!() const
	{
		return !_attr;
	}

	 bool xml_attribute::operator==(const xml_attribute& r) const
	{
		return (_attr == r._attr);
	}
	
	 bool xml_attribute::operator!=(const xml_attribute& r) const
	{
		return (_attr != r._attr);
	}

	 bool xml_attribute::operator<(const xml_attribute& r) const
	{
		return (_attr < r._attr);
	}
	
	 bool xml_attribute::operator>(const xml_attribute& r) const
	{
		return (_attr > r._attr);
	}
	
	 bool xml_attribute::operator<=(const xml_attribute& r) const
	{
		return (_attr <= r._attr);
	}
	
	 bool xml_attribute::operator>=(const xml_attribute& r) const
	{
		return (_attr >= r._attr);
	}

	 xml_attribute xml_attribute::next_attribute() const
	{
		return _attr ? xml_attribute(_attr->next_attribute) : xml_attribute();
	}

	 xml_attribute xml_attribute::previous_attribute() const
	{
		return _attr && _attr->prev_attribute_c->next_attribute ? xml_attribute(_attr->prev_attribute_c) : xml_attribute();
	}

	 const char_t* xml_attribute::as_string(const char_t* def) const
	{
		return (_attr && _attr->value) ? _attr->value : def;
	}

	 int xml_attribute::as_int(int def) const
	{
		return impl::get_value_int(_attr ? _attr->value : 0, def);
	}

	 unsigned int xml_attribute::as_uint(unsigned int def) const
	{
		return impl::get_value_uint(_attr ? _attr->value : 0, def);
	}

	 double xml_attribute::as_double(double def) const
	{
		return impl::get_value_double(_attr ? _attr->value : 0, def);
	}

	 float xml_attribute::as_float(float def) const
	{
		return impl::get_value_float(_attr ? _attr->value : 0, def);
	}

	 bool xml_attribute::as_bool(bool def) const
	{
		return impl::get_value_bool(_attr ? _attr->value : 0, def);
	}

	 bool xml_attribute::empty() const
	{
		return !_attr;
	}

	 const char_t* xml_attribute::name() const
	{
		return (_attr && _attr->name) ? _attr->name : "";
	}

	 const char_t* xml_attribute::value() const
	{
		return (_attr && _attr->value) ? _attr->value : "";
	}

	 size_t xml_attribute::hash_value() const
	{
		return static_cast<size_t>(reinterpret_cast<uintptr_t>(_attr) / sizeof(xml_attribute_struct));
	}

	 xml_attribute_struct* xml_attribute::internal_object() const
	{
		return _attr;
	}

	 xml_attribute& xml_attribute::operator=(const char_t* rhs)
	{
		set_value(rhs);
		return *this;
	}
	
	 xml_attribute& xml_attribute::operator=(int rhs)
	{
		set_value(rhs);
		return *this;
	}

	 xml_attribute& xml_attribute::operator=(unsigned int rhs)
	{
		set_value(rhs);
		return *this;
	}

	 xml_attribute& xml_attribute::operator=(double rhs)
	{
		set_value(rhs);
		return *this;
	}
	
	 xml_attribute& xml_attribute::operator=(bool rhs)
	{
		set_value(rhs);
		return *this;
	}

	 bool xml_attribute::set_name(const char_t* rhs)
	{
		if (!_attr) return false;
		
		return impl::strcpy_insitu(_attr->name, _attr->header, impl::xml_memory_page_name_allocated_mask, rhs);
	}
		
	 bool xml_attribute::set_value(const char_t* rhs)
	{
		if (!_attr) return false;

		return impl::strcpy_insitu(_attr->value, _attr->header, impl::xml_memory_page_value_allocated_mask, rhs);
	}

	 bool xml_attribute::set_value(int rhs)
	{
		if (!_attr) return false;

		return impl::set_value_convert(_attr->value, _attr->header, impl::xml_memory_page_value_allocated_mask, rhs);
	}

	 bool xml_attribute::set_value(unsigned int rhs)
	{
		if (!_attr) return false;

		return impl::set_value_convert(_attr->value, _attr->header, impl::xml_memory_page_value_allocated_mask, rhs);
	}

	 bool xml_attribute::set_value(double rhs)
	{
		if (!_attr) return false;

		return impl::set_value_convert(_attr->value, _attr->header, impl::xml_memory_page_value_allocated_mask, rhs);
	}
	
	 bool xml_attribute::set_value(bool rhs)
	{
		if (!_attr) return false;

		return impl::set_value_convert(_attr->value, _attr->header, impl::xml_memory_page_value_allocated_mask, rhs);
	}

                   
	                                                            
	 
		                        
	 

	                                                            
	 
		                        
	 
      

	 xml_node::xml_node(): _root(0)
	{
	}

	 xml_node::xml_node(xml_node_struct* p): _root(p)
	{
	}
	
	 static void unspecified_bool_xml_node(xml_node***)
	{
	}

	 xml_node::operator xml_node::unspecified_bool_type() const
	{
		return _root ? unspecified_bool_xml_node : 0;
	}

	 bool xml_node::operator!() const
	{
		return !_root;
	}

	 xml_node::iterator xml_node::begin() const
	{
		return iterator(_root ? _root->first_child : 0, _root);
	}

	 xml_node::iterator xml_node::end() const
	{
		return iterator(0, _root);
	}
	
	 xml_node::attribute_iterator xml_node::attributes_begin() const
	{
		return attribute_iterator(_root ? _root->first_attribute : 0, _root);
	}

	 xml_node::attribute_iterator xml_node::attributes_end() const
	{
		return attribute_iterator(0, _root);
	}
	
	 xml_object_range<xml_node_iterator> xml_node::children() const
	{
		return xml_object_range<xml_node_iterator>(begin(), end());
	}

	 xml_object_range<xml_named_node_iterator> xml_node::children(const char_t* name_) const
	{
		return xml_object_range<xml_named_node_iterator>(xml_named_node_iterator(child(name_), name_), xml_named_node_iterator());
	}

	 xml_object_range<xml_attribute_iterator> xml_node::attributes() const
	{
		return xml_object_range<xml_attribute_iterator>(attributes_begin(), attributes_end());
	}

	 bool xml_node::operator==(const xml_node& r) const
	{
		return (_root == r._root);
	}

	 bool xml_node::operator!=(const xml_node& r) const
	{
		return (_root != r._root);
	}

	 bool xml_node::operator<(const xml_node& r) const
	{
		return (_root < r._root);
	}
	
	 bool xml_node::operator>(const xml_node& r) const
	{
		return (_root > r._root);
	}
	
	 bool xml_node::operator<=(const xml_node& r) const
	{
		return (_root <= r._root);
	}
	
	 bool xml_node::operator>=(const xml_node& r) const
	{
		return (_root >= r._root);
	}

	 bool xml_node::empty() const
	{
		return !_root;
	}
	
	 const char_t* xml_node::name() const
	{
		return (_root && _root->name) ? _root->name : "";
	}

	 xml_node_type xml_node::type() const
	{
		return _root ? static_cast<xml_node_type>((_root->header & impl::xml_memory_page_type_mask) + 1) : node_null;
	}
	
	 const char_t* xml_node::value() const
	{
		return (_root && _root->value) ? _root->value : "";
	}
	
	 xml_node xml_node::child(const char_t* name_) const
	{
		if (!_root) return xml_node();

		for (xml_node_struct* i = _root->first_child; i; i = i->next_sibling)
			if (i->name && impl::strequal(name_, i->name)) return xml_node(i);

		return xml_node();
	}

	 xml_attribute xml_node::attribute(const char_t* name_) const
	{
		if (!_root) return xml_attribute();

		for (xml_attribute_struct* i = _root->first_attribute; i; i = i->next_attribute)
			if (i->name && impl::strequal(name_, i->name))
				return xml_attribute(i);
		
		return xml_attribute();
	}
	
	 xml_node xml_node::next_sibling(const char_t* name_) const
	{
		if (!_root) return xml_node();
		
		for (xml_node_struct* i = _root->next_sibling; i; i = i->next_sibling)
			if (i->name && impl::strequal(name_, i->name)) return xml_node(i);

		return xml_node();
	}

	 xml_node xml_node::next_sibling() const
	{
		if (!_root) return xml_node();
		
		if (_root->next_sibling) return xml_node(_root->next_sibling);
		else return xml_node();
	}

	 xml_node xml_node::previous_sibling(const char_t* name_) const
	{
		if (!_root) return xml_node();
		
		for (xml_node_struct* i = _root->prev_sibling_c; i->next_sibling; i = i->prev_sibling_c)
			if (i->name && impl::strequal(name_, i->name)) return xml_node(i);

		return xml_node();
	}

	 xml_node xml_node::previous_sibling() const
	{
		if (!_root) return xml_node();
		
		if (_root->prev_sibling_c->next_sibling) return xml_node(_root->prev_sibling_c);
		else return xml_node();
	}

	 xml_node xml_node::parent() const
	{
		return _root ? xml_node(_root->parent) : xml_node();
	}

	 xml_node xml_node::root() const
	{
		if (!_root) return xml_node();

		impl::xml_memory_page* page = reinterpret_cast<impl::xml_memory_page*>(_root->header & impl::xml_memory_page_pointer_mask);

		return xml_node(static_cast<impl::xml_document_struct*>(page->allocator));
	}

	 xml_text xml_node::text() const
	{
		return xml_text(_root);
	}

	 const char_t* xml_node::child_value() const
	{
		if (!_root) return "";
		
		for (xml_node_struct* i = _root->first_child; i; i = i->next_sibling)
			if (i->value && impl::is_text_node(i))
				return i->value;

		return "";
	}

	 const char_t* xml_node::child_value(const char_t* name_) const
	{
		return child(name_).child_value();
	}

	 xml_attribute xml_node::first_attribute() const
	{
		return _root ? xml_attribute(_root->first_attribute) : xml_attribute();
	}

	 xml_attribute xml_node::last_attribute() const
	{
		return _root && _root->first_attribute ? xml_attribute(_root->first_attribute->prev_attribute_c) : xml_attribute();
	}

	 xml_node xml_node::first_child() const
	{
		return _root ? xml_node(_root->first_child) : xml_node();
	}

	 xml_node xml_node::last_child() const
	{
		return _root && _root->first_child ? xml_node(_root->first_child->prev_sibling_c) : xml_node();
	}

	 bool xml_node::set_name(const char_t* rhs)
	{
		switch (type())
		{
		case node_pi:
		case node_declaration:
		case node_element:
			return impl::strcpy_insitu(_root->name, _root->header, impl::xml_memory_page_name_allocated_mask, rhs);

		default:
			return false;
		}
	}
		
	 bool xml_node::set_value(const char_t* rhs)
	{
		switch (type())
		{
		case node_pi:
		case node_cdata:
		case node_pcdata:
		case node_comment:
		case node_doctype:
			return impl::strcpy_insitu(_root->value, _root->header, impl::xml_memory_page_value_allocated_mask, rhs);

		default:
			return false;
		}
	}

	 xml_attribute xml_node::append_attribute(const char_t* name_)
	{
		if (type() != node_element && type() != node_declaration) return xml_attribute();
		
		xml_attribute a(impl::append_attribute_ll(_root, impl::get_allocator(_root)));
		a.set_name(name_);
		
		return a;
	}

	 xml_attribute xml_node::prepend_attribute(const char_t* name_)
	{
		if (type() != node_element && type() != node_declaration) return xml_attribute();
		
		xml_attribute a(impl::allocate_attribute(impl::get_allocator(_root)));
		if (!a) return xml_attribute();

		a.set_name(name_);
		
		xml_attribute_struct* head = _root->first_attribute;

		if (head)
		{
			a._attr->prev_attribute_c = head->prev_attribute_c;
			head->prev_attribute_c = a._attr;
		}
		else
			a._attr->prev_attribute_c = a._attr;
		
		a._attr->next_attribute = head;
		_root->first_attribute = a._attr;
				
		return a;
	}

	 xml_attribute xml_node::insert_attribute_before(const char_t* name_, const xml_attribute& attr)
	{
		if ((type() != node_element && type() != node_declaration) || attr.empty()) return xml_attribute();
		
		// check that attribute belongs to *this
		xml_attribute_struct* cur = attr._attr;

		while (cur->prev_attribute_c->next_attribute) cur = cur->prev_attribute_c;

		if (cur != _root->first_attribute) return xml_attribute();

		xml_attribute a(impl::allocate_attribute(impl::get_allocator(_root)));
		if (!a) return xml_attribute();

		a.set_name(name_);

		if (attr._attr->prev_attribute_c->next_attribute)
			attr._attr->prev_attribute_c->next_attribute = a._attr;
		else
			_root->first_attribute = a._attr;
		
		a._attr->prev_attribute_c = attr._attr->prev_attribute_c;
		a._attr->next_attribute = attr._attr;
		attr._attr->prev_attribute_c = a._attr;
				
		return a;
	}

	 xml_attribute xml_node::insert_attribute_after(const char_t* name_, const xml_attribute& attr)
	{
		if ((type() != node_element && type() != node_declaration) || attr.empty()) return xml_attribute();
		
		// check that attribute belongs to *this
		xml_attribute_struct* cur = attr._attr;

		while (cur->prev_attribute_c->next_attribute) cur = cur->prev_attribute_c;

		if (cur != _root->first_attribute) return xml_attribute();

		xml_attribute a(impl::allocate_attribute(impl::get_allocator(_root)));
		if (!a) return xml_attribute();

		a.set_name(name_);

		if (attr._attr->next_attribute)
			attr._attr->next_attribute->prev_attribute_c = a._attr;
		else
			_root->first_attribute->prev_attribute_c = a._attr;
		
		a._attr->next_attribute = attr._attr->next_attribute;
		a._attr->prev_attribute_c = attr._attr;
		attr._attr->next_attribute = a._attr;

		return a;
	}

	 xml_attribute xml_node::append_copy(const xml_attribute& proto)
	{
		if (!proto) return xml_attribute();

		xml_attribute result = append_attribute(proto.name());
		result.set_value(proto.value());

		return result;
	}

	 xml_attribute xml_node::prepend_copy(const xml_attribute& proto)
	{
		if (!proto) return xml_attribute();

		xml_attribute result = prepend_attribute(proto.name());
		result.set_value(proto.value());

		return result;
	}

	 xml_attribute xml_node::insert_copy_after(const xml_attribute& proto, const xml_attribute& attr)
	{
		if (!proto) return xml_attribute();

		xml_attribute result = insert_attribute_after(proto.name(), attr);
		result.set_value(proto.value());

		return result;
	}

	 xml_attribute xml_node::insert_copy_before(const xml_attribute& proto, const xml_attribute& attr)
	{
		if (!proto) return xml_attribute();

		xml_attribute result = insert_attribute_before(proto.name(), attr);
		result.set_value(proto.value());

		return result;
	}

	 xml_node xml_node::append_child(xml_node_type type_)
	{
		if (!impl::allow_insert_child(this->type(), type_)) return xml_node();
		
		xml_node n(impl::append_node(_root, impl::get_allocator(_root), type_));

		if (type_ == node_declaration) n.set_name("xml");

		return n;
	}

	 xml_node xml_node::prepend_child(xml_node_type type_)
	{
		if (!impl::allow_insert_child(this->type(), type_)) return xml_node();
		
		xml_node n(impl::allocate_node(impl::get_allocator(_root), type_));
		if (!n) return xml_node();

		n._root->parent = _root;

		xml_node_struct* head = _root->first_child;

		if (head)
		{
			n._root->prev_sibling_c = head->prev_sibling_c;
			head->prev_sibling_c = n._root;
		}
		else
			n._root->prev_sibling_c = n._root;
		
		n._root->next_sibling = head;
		_root->first_child = n._root;
				
		if (type_ == node_declaration) n.set_name("xml");

		return n;
	}

	 xml_node xml_node::insert_child_before(xml_node_type type_, const xml_node& node)
	{
		if (!impl::allow_insert_child(this->type(), type_)) return xml_node();
		if (!node._root || node._root->parent != _root) return xml_node();
	
		xml_node n(impl::allocate_node(impl::get_allocator(_root), type_));
		if (!n) return xml_node();

		n._root->parent = _root;
		
		if (node._root->prev_sibling_c->next_sibling)
			node._root->prev_sibling_c->next_sibling = n._root;
		else
			_root->first_child = n._root;
		
		n._root->prev_sibling_c = node._root->prev_sibling_c;
		n._root->next_sibling = node._root;
		node._root->prev_sibling_c = n._root;

		if (type_ == node_declaration) n.set_name("xml");

		return n;
	}

	 xml_node xml_node::insert_child_after(xml_node_type type_, const xml_node& node)
	{
		if (!impl::allow_insert_child(this->type(), type_)) return xml_node();
		if (!node._root || node._root->parent != _root) return xml_node();
	
		xml_node n(impl::allocate_node(impl::get_allocator(_root), type_));
		if (!n) return xml_node();

		n._root->parent = _root;
	
		if (node._root->next_sibling)
			node._root->next_sibling->prev_sibling_c = n._root;
		else
			_root->first_child->prev_sibling_c = n._root;
		
		n._root->next_sibling = node._root->next_sibling;
		n._root->prev_sibling_c = node._root;
		node._root->next_sibling = n._root;

		if (type_ == node_declaration) n.set_name("xml");

		return n;
	}

	 xml_node xml_node::append_child(const char_t* name_)
	{
		xml_node result = append_child(node_element);

		result.set_name(name_);

		return result;
	}

	 xml_node xml_node::prepend_child(const char_t* name_)
	{
		xml_node result = prepend_child(node_element);

		result.set_name(name_);

		return result;
	}

	 xml_node xml_node::insert_child_after(const char_t* name_, const xml_node& node)
	{
		xml_node result = insert_child_after(node_element, node);

		result.set_name(name_);

		return result;
	}

	 xml_node xml_node::insert_child_before(const char_t* name_, const xml_node& node)
	{
		xml_node result = insert_child_before(node_element, node);

		result.set_name(name_);

		return result;
	}

	 xml_node xml_node::append_copy(const xml_node& proto)
	{
		xml_node result = append_child(proto.type());

		if (result) impl::recursive_copy_skip(result, proto, result);

		return result;
	}

	 xml_node xml_node::prepend_copy(const xml_node& proto)
	{
		xml_node result = prepend_child(proto.type());

		if (result) impl::recursive_copy_skip(result, proto, result);

		return result;
	}

	 xml_node xml_node::insert_copy_after(const xml_node& proto, const xml_node& node)
	{
		xml_node result = insert_child_after(proto.type(), node);

		if (result) impl::recursive_copy_skip(result, proto, result);

		return result;
	}

	 xml_node xml_node::insert_copy_before(const xml_node& proto, const xml_node& node)
	{
		xml_node result = insert_child_before(proto.type(), node);

		if (result) impl::recursive_copy_skip(result, proto, result);

		return result;
	}

	 bool xml_node::remove_attribute(const char_t* name_)
	{
		return remove_attribute(attribute(name_));
	}

	 bool xml_node::remove_attribute(const xml_attribute& a)
	{
		if (!_root || !a._attr) return false;

		// check that attribute belongs to *this
		xml_attribute_struct* attr = a._attr;

		while (attr->prev_attribute_c->next_attribute) attr = attr->prev_attribute_c;

		if (attr != _root->first_attribute) return false;

		if (a._attr->next_attribute) a._attr->next_attribute->prev_attribute_c = a._attr->prev_attribute_c;
		else if (_root->first_attribute) _root->first_attribute->prev_attribute_c = a._attr->prev_attribute_c;
		
		if (a._attr->prev_attribute_c->next_attribute) a._attr->prev_attribute_c->next_attribute = a._attr->next_attribute;
		else _root->first_attribute = a._attr->next_attribute;

		impl::destroy_attribute(a._attr, impl::get_allocator(_root));

		return true;
	}

	 bool xml_node::remove_child(const char_t* name_)
	{
		return remove_child(child(name_));
	}

	 bool xml_node::remove_child(const xml_node& n)
	{
		if (!_root || !n._root || n._root->parent != _root) return false;

		if (n._root->next_sibling) n._root->next_sibling->prev_sibling_c = n._root->prev_sibling_c;
		else if (_root->first_child) _root->first_child->prev_sibling_c = n._root->prev_sibling_c;
		
		if (n._root->prev_sibling_c->next_sibling) n._root->prev_sibling_c->next_sibling = n._root->next_sibling;
		else _root->first_child = n._root->next_sibling;
		
		impl::destroy_node(n._root, impl::get_allocator(_root));

		return true;
	}

	 xml_node xml_node::find_child_by_attribute(const char_t* name_, const char_t* attr_name, const char_t* attr_value) const
	{
		if (!_root) return xml_node();
		
		for (xml_node_struct* i = _root->first_child; i; i = i->next_sibling)
			if (i->name && impl::strequal(name_, i->name))
			{
				for (xml_attribute_struct* a = i->first_attribute; a; a = a->next_attribute)
					if (impl::strequal(attr_name, a->name) && impl::strequal(attr_value, a->value))
						return xml_node(i);
			}

		return xml_node();
	}

	 xml_node xml_node::find_child_by_attribute(const char_t* attr_name, const char_t* attr_value) const
	{
		if (!_root) return xml_node();
		
		for (xml_node_struct* i = _root->first_child; i; i = i->next_sibling)
			for (xml_attribute_struct* a = i->first_attribute; a; a = a->next_attribute)
				if (impl::strequal(attr_name, a->name) && impl::strequal(attr_value, a->value))
					return xml_node(i);

		return xml_node();
	}

                      
	 string_t xml_node::path(char_t delimiter) const
	{
		xml_node cursor = *this; // Make a copy.
		
		string_t result = cursor.name();

		while (cursor.parent())
		{
			cursor = cursor.parent();
			
			string_t temp = cursor.name();
			temp += delimiter;
			temp += result;
			result.swap(temp);
		}

		return result;
	}
      

	 xml_node xml_node::first_element_by_path(const char_t* path_, char_t delimiter) const
	{
		xml_node found = *this; // Current search context.

		if (!_root || !path_ || !path_[0]) return found;

		if (path_[0] == delimiter)
		{
			// Absolute path; e.g. '/foo/bar'
			found = found.root();
			++path_;
		}

		const char_t* path_segment = path_;

		while (*path_segment == delimiter) ++path_segment;

		const char_t* path_segment_end = path_segment;

		while (*path_segment_end && *path_segment_end != delimiter) ++path_segment_end;

		if (path_segment == path_segment_end) return found;

		const char_t* next_segment = path_segment_end;

		while (*next_segment == delimiter) ++next_segment;

		if (*path_segment == '.' && path_segment + 1 == path_segment_end)
			return found.first_element_by_path(next_segment, delimiter);
		else if (*path_segment == '.' && *(path_segment+1) == '.' && path_segment + 2 == path_segment_end)
			return found.parent().first_element_by_path(next_segment, delimiter);
		else
		{
			for (xml_node_struct* j = found._root->first_child; j; j = j->next_sibling)
			{
				if (j->name && impl::strequalrange(j->name, path_segment, static_cast<size_t>(path_segment_end - path_segment)))
				{
					xml_node subsearch = xml_node(j).first_element_by_path(next_segment, delimiter);

					if (subsearch) return subsearch;
				}
			}

			return xml_node();
		}
	}

	 bool xml_node::traverse(xml_tree_walker& walker)
	{
		walker._depth = -1;
		
		xml_node arg_begin = *this;
		if (!walker.begin(arg_begin)) return false;

		xml_node cur = first_child();
				
		if (cur)
		{
			++walker._depth;

			do 
			{
				xml_node arg_for_each = cur;
				if (!walker.for_each(arg_for_each))
					return false;
						
				if (cur.first_child())
				{
					++walker._depth;
					cur = cur.first_child();
				}
				else if (cur.next_sibling())
					cur = cur.next_sibling();
				else
				{
					// Borland C++ workaround
					while (!cur.next_sibling() && cur != *this && !cur.parent().empty())
					{
						--walker._depth;
						cur = cur.parent();
					}
						
					if (cur != *this)
						cur = cur.next_sibling();
				}
			}
			while (cur && cur != *this);
		}

		assert(walker._depth == -1);

		xml_node arg_end = *this;
		return walker.end(arg_end);
	}

	 size_t xml_node::hash_value() const
	{
		return static_cast<size_t>(reinterpret_cast<uintptr_t>(_root) / sizeof(xml_node_struct));
	}

	 xml_node_struct* xml_node::internal_object() const
	{
		return _root;
	}

	 void xml_node::print(xml_writer& writer, const char_t* indent, unsigned int flags, xml_encoding encoding, unsigned int depth) const
	{
		if (!_root) return;

		impl::xml_buffered_writer buffered_writer(writer, encoding);

		impl::node_output(buffered_writer, *this, indent, flags, depth);
	}

                      
	 void xml_node::print(std::basic_ostream<char, std::char_traits<char> >& stream, const char_t* indent, unsigned int flags, xml_encoding encoding, unsigned int depth) const
	{
		xml_writer_stream writer(stream);

		print(writer, indent, flags, encoding, depth);
	}

	 void xml_node::print(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& stream, const char_t* indent, unsigned int flags, unsigned int depth) const
	{
		xml_writer_stream writer(stream);

		print(writer, indent, flags, encoding_wchar, depth);
	}
      

	 ptrdiff_t xml_node::offset_debug() const
	{
		xml_node_struct* r = root()._root;

		if (!r) return -1;

		const char_t* buffer = static_cast<impl::xml_document_struct*>(r)->buffer;

		if (!buffer) return -1;

		switch (type())
		{
		case node_document:
			return 0;

		case node_element:
		case node_declaration:
		case node_pi:
			return (_root->header & impl::xml_memory_page_name_allocated_mask) ? -1 : _root->name - buffer;

		case node_pcdata:
		case node_cdata:
		case node_comment:
		case node_doctype:
			return (_root->header & impl::xml_memory_page_value_allocated_mask) ? -1 : _root->value - buffer;

		default:
			return -1;
		}
	}

                   
	                                                       
	 
		                        
	 

	                                                       
	 
		                        
	 
      

	 xml_text::xml_text(xml_node_struct* root): _root(root)
	{
	}

	 xml_node_struct* xml_text::_data() const
	{
		if (!_root || impl::is_text_node(_root)) return _root;

		for (xml_node_struct* node = _root->first_child; node; node = node->next_sibling)
			if (impl::is_text_node(node))
				return node;

		return 0;
	}

	 xml_node_struct* xml_text::_data_new()
	{
		xml_node_struct* d = _data();
		if (d) return d;

		return xml_node(_root).append_child(node_pcdata).internal_object();
	}

	 xml_text::xml_text(): _root(0)
	{
	}

	 static void unspecified_bool_xml_text(xml_text***)
	{
	}

	 xml_text::operator xml_text::unspecified_bool_type() const
	{
		return _data() ? unspecified_bool_xml_text : 0;
	}

	 bool xml_text::operator!() const
	{
		return !_data();
	}

	 bool xml_text::empty() const
	{
		return _data() == 0;
	}

	 const char_t* xml_text::get() const
	{
		xml_node_struct* d = _data();

		return (d && d->value) ? d->value : "";
	}

	 const char_t* xml_text::as_string(const char_t* def) const
	{
		xml_node_struct* d = _data();

		return (d && d->value) ? d->value : def;
	}

	 int xml_text::as_int(int def) const
	{
		xml_node_struct* d = _data();

		return impl::get_value_int(d ? d->value : 0, def);
	}

	 unsigned int xml_text::as_uint(unsigned int def) const
	{
		xml_node_struct* d = _data();

		return impl::get_value_uint(d ? d->value : 0, def);
	}

	 double xml_text::as_double(double def) const
	{
		xml_node_struct* d = _data();

		return impl::get_value_double(d ? d->value : 0, def);
	}

	 float xml_text::as_float(float def) const
	{
		xml_node_struct* d = _data();

		return impl::get_value_float(d ? d->value : 0, def);
	}

	 bool xml_text::as_bool(bool def) const
	{
		xml_node_struct* d = _data();

		return impl::get_value_bool(d ? d->value : 0, def);
	}

	 bool xml_text::set(const char_t* rhs)
	{
		xml_node_struct* dn = _data_new();

		return dn ? impl::strcpy_insitu(dn->value, dn->header, impl::xml_memory_page_value_allocated_mask, rhs) : false;
	}

	 bool xml_text::set(int rhs)
	{
		xml_node_struct* dn = _data_new();

		return dn ? impl::set_value_convert(dn->value, dn->header, impl::xml_memory_page_value_allocated_mask, rhs) : false;
	}

	 bool xml_text::set(unsigned int rhs)
	{
		xml_node_struct* dn = _data_new();

		return dn ? impl::set_value_convert(dn->value, dn->header, impl::xml_memory_page_value_allocated_mask, rhs) : false;
	}

	 bool xml_text::set(double rhs)
	{
		xml_node_struct* dn = _data_new();

		return dn ? impl::set_value_convert(dn->value, dn->header, impl::xml_memory_page_value_allocated_mask, rhs) : false;
	}

	 bool xml_text::set(bool rhs)
	{
		xml_node_struct* dn = _data_new();

		return dn ? impl::set_value_convert(dn->value, dn->header, impl::xml_memory_page_value_allocated_mask, rhs) : false;
	}

	 xml_text& xml_text::operator=(const char_t* rhs)
	{
		set(rhs);
		return *this;
	}

	 xml_text& xml_text::operator=(int rhs)
	{
		set(rhs);
		return *this;
	}

	 xml_text& xml_text::operator=(unsigned int rhs)
	{
		set(rhs);
		return *this;
	}

	 xml_text& xml_text::operator=(double rhs)
	{
		set(rhs);
		return *this;
	}

	 xml_text& xml_text::operator=(bool rhs)
	{
		set(rhs);
		return *this;
	}

	 xml_node xml_text::data() const
	{
		return xml_node(_data());
	}

                   
	                                                       
	 
		                        
	 

	                                                       
	 
		                        
	 
      

	 xml_node_iterator::xml_node_iterator()
	{
	}

	 xml_node_iterator::xml_node_iterator(const xml_node& node): _wrap(node), _parent(node.parent())
	{
	}

	 xml_node_iterator::xml_node_iterator(xml_node_struct* ref, xml_node_struct* parent): _wrap(ref), _parent(parent)
	{
	}

	 bool xml_node_iterator::operator==(const xml_node_iterator& rhs) const
	{
		return _wrap._root == rhs._wrap._root && _parent._root == rhs._parent._root;
	}
	
	 bool xml_node_iterator::operator!=(const xml_node_iterator& rhs) const
	{
		return _wrap._root != rhs._wrap._root || _parent._root != rhs._parent._root;
	}

	 xml_node& xml_node_iterator::operator*() const
	{
		assert(_wrap._root);
		return _wrap;
	}

	 xml_node* xml_node_iterator::operator->() const
	{
		assert(_wrap._root);
		return const_cast<xml_node*>(&_wrap); // BCC32 workaround
	}

	 const xml_node_iterator& xml_node_iterator::operator++()
	{
		assert(_wrap._root);
		_wrap._root = _wrap._root->next_sibling;
		return *this;
	}

	 xml_node_iterator xml_node_iterator::operator++(int)
	{
		xml_node_iterator temp = *this;
		++*this;
		return temp;
	}

	 const xml_node_iterator& xml_node_iterator::operator--()
	{
		_wrap = _wrap._root ? _wrap.previous_sibling() : _parent.last_child();
		return *this;
	}

	 xml_node_iterator xml_node_iterator::operator--(int)
	{
		xml_node_iterator temp = *this;
		--*this;
		return temp;
	}

	 xml_attribute_iterator::xml_attribute_iterator()
	{
	}

	 xml_attribute_iterator::xml_attribute_iterator(const xml_attribute& attr, const xml_node& parent): _wrap(attr), _parent(parent)
	{
	}

	 xml_attribute_iterator::xml_attribute_iterator(xml_attribute_struct* ref, xml_node_struct* parent): _wrap(ref), _parent(parent)
	{
	}

	 bool xml_attribute_iterator::operator==(const xml_attribute_iterator& rhs) const
	{
		return _wrap._attr == rhs._wrap._attr && _parent._root == rhs._parent._root;
	}
	
	 bool xml_attribute_iterator::operator!=(const xml_attribute_iterator& rhs) const
	{
		return _wrap._attr != rhs._wrap._attr || _parent._root != rhs._parent._root;
	}

	 xml_attribute& xml_attribute_iterator::operator*() const
	{
		assert(_wrap._attr);
		return _wrap;
	}

	 xml_attribute* xml_attribute_iterator::operator->() const
	{
		assert(_wrap._attr);
		return const_cast<xml_attribute*>(&_wrap); // BCC32 workaround
	}

	 const xml_attribute_iterator& xml_attribute_iterator::operator++()
	{
		assert(_wrap._attr);
		_wrap._attr = _wrap._attr->next_attribute;
		return *this;
	}

	 xml_attribute_iterator xml_attribute_iterator::operator++(int)
	{
		xml_attribute_iterator temp = *this;
		++*this;
		return temp;
	}

	 const xml_attribute_iterator& xml_attribute_iterator::operator--()
	{
		_wrap = _wrap._attr ? _wrap.previous_attribute() : _parent.last_attribute();
		return *this;
	}

	 xml_attribute_iterator xml_attribute_iterator::operator--(int)
	{
		xml_attribute_iterator temp = *this;
		--*this;
		return temp;
	}

	 xml_named_node_iterator::xml_named_node_iterator(): _name(0)
	{
	}

	 xml_named_node_iterator::xml_named_node_iterator(const xml_node& node, const char_t* name): _node(node), _name(name)
	{
	}

	 bool xml_named_node_iterator::operator==(const xml_named_node_iterator& rhs) const
	{
		return _node == rhs._node;
	}

	 bool xml_named_node_iterator::operator!=(const xml_named_node_iterator& rhs) const
	{
		return _node != rhs._node;
	}

	 xml_node& xml_named_node_iterator::operator*() const
	{
		assert(_node._root);
		return _node;
	}

	 xml_node* xml_named_node_iterator::operator->() const
	{
		assert(_node._root);
		return const_cast<xml_node*>(&_node); // BCC32 workaround
	}

	 const xml_named_node_iterator& xml_named_node_iterator::operator++()
	{
		assert(_node._root);
		_node = _node.next_sibling(_name);
		return *this;
	}

	 xml_named_node_iterator xml_named_node_iterator::operator++(int)
	{
		xml_named_node_iterator temp = *this;
		++*this;
		return temp;
	}

	 xml_parse_result::xml_parse_result(): status(status_internal_error), offset(0), encoding(encoding_auto)
	{
	}

	 xml_parse_result::operator bool() const
	{
		return status == status_ok;
	}

	 const char* xml_parse_result::description() const
	{
		switch (status)
		{
		case status_ok: return "No error";

		case status_file_not_found: return "File was not found";
		case status_io_error: return "Error reading from file/stream";
		case status_out_of_memory: return "Could not allocate memory";
		case status_internal_error: return "Internal error occurred";

		case status_unrecognized_tag: return "Could not determine tag type";

		case status_bad_pi: return "Error parsing document declaration/processing instruction";
		case status_bad_comment: return "Error parsing comment";
		case status_bad_cdata: return "Error parsing CDATA section";
		case status_bad_doctype: return "Error parsing document type declaration";
		case status_bad_pcdata: return "Error parsing PCDATA section";
		case status_bad_start_element: return "Error parsing start element tag";
		case status_bad_attribute: return "Error parsing element attribute";
		case status_bad_end_element: return "Error parsing end element tag";
		case status_end_element_mismatch: return "Start-end tags mismatch";

		default: return "Unknown error";
		}
	}

	 xml_document::xml_document(): _buffer(0)
	{
		create();
	}

	 xml_document::~xml_document()
	{
		destroy();
	}

	 void xml_document::reset()
	{
		destroy();
		create();
	}

	 void xml_document::reset(const xml_document& proto)
	{
		reset();

		for (xml_node cur = proto.first_child(); cur; cur = cur.next_sibling())
			append_copy(cur);
	}

	 void xml_document::create()
	{
		// initialize sentinel page
		{ static const char condition_failed[(offsetof(impl::xml_memory_page, data) + sizeof(impl::xml_document_struct) + impl::xml_memory_page_alignment <= sizeof(_memory)) ? 1 : -1] = {0}; (void)condition_failed[0]; };

		// align upwards to page boundary
		void* page_memory = reinterpret_cast<void*>((reinterpret_cast<uintptr_t>(_memory) + (impl::xml_memory_page_alignment - 1)) & ~(impl::xml_memory_page_alignment - 1));

		// prepare page structure
		impl::xml_memory_page* page = impl::xml_memory_page::construct(page_memory);

		page->busy_size = impl::xml_memory_page_size;

		// allocate new root
		_root = new (page->data) impl::xml_document_struct(page);
		_root->prev_sibling_c = _root;

		// setup sentinel page
		page->allocator = static_cast<impl::xml_document_struct*>(_root);
	}

	 void xml_document::destroy()
	{
		// destroy static storage
		if (_buffer)
		{
			impl::xml_memory::deallocate(_buffer);
			_buffer = 0;
		}

		// destroy dynamic storage, leave sentinel page (it's in static memory)
		if (_root)
		{
			impl::xml_memory_page* root_page = reinterpret_cast<impl::xml_memory_page*>(_root->header & impl::xml_memory_page_pointer_mask);
			assert(root_page && !root_page->prev && !root_page->memory);

			// destroy all pages
			for (impl::xml_memory_page* page = root_page->next; page; )
			{
				impl::xml_memory_page* next = page->next;

				impl::xml_allocator::deallocate_page(page);

				page = next;
			}

			// cleanup root page
			root_page->allocator = 0;
			root_page->next = 0;
			root_page->busy_size = root_page->freed_size = 0;

			_root = 0;
		}
	}

                      
	 xml_parse_result xml_document::load(std::basic_istream<char, std::char_traits<char> >& stream, unsigned int options, xml_encoding encoding)
	{
		reset();

		return impl::load_stream_impl(*this, stream, options, encoding);
	}

	 xml_parse_result xml_document::load(std::basic_istream<wchar_t, std::char_traits<wchar_t> >& stream, unsigned int options)
	{
		reset();

		return impl::load_stream_impl(*this, stream, options, encoding_wchar);
	}
      

	 xml_parse_result xml_document::load(const char_t* contents, unsigned int options)
	{
		// Force native encoding (skip autodetection)
	                         
		                                       
	     
		xml_encoding encoding = encoding_utf8;
	      

		return load_buffer(contents, impl::strlength(contents) * sizeof(char_t), options, encoding);
	}

	 xml_parse_result xml_document::load_file(const char* path_, unsigned int options, xml_encoding encoding)
	{
		reset();

		FILE* file = fopen(path_, "rb");

		return impl::load_file_impl(*this, file, options, encoding);
	}

	 xml_parse_result xml_document::load_file(const wchar_t* path_, unsigned int options, xml_encoding encoding)
	{
		reset();

		FILE* file = impl::open_file_wide(path_, L"rb");

		return impl::load_file_impl(*this, file, options, encoding);
	}

	 xml_parse_result xml_document::load_buffer_impl(void* contents, size_t size, unsigned int options, xml_encoding encoding, bool is_mutable, bool own)
	{
		reset();

		// check input buffer
		assert(contents || size == 0);

		// get actual encoding
		xml_encoding buffer_encoding = impl::get_buffer_encoding(encoding, contents, size);

		// get private buffer
		char_t* buffer = 0;
		size_t length = 0;

		if (!impl::convert_buffer(buffer, length, buffer_encoding, contents, size, is_mutable)) return impl::make_parse_result(status_out_of_memory);
		
		// delete original buffer if we performed a conversion
		if (own && buffer != contents && contents) impl::xml_memory::deallocate(contents);

		// parse
		xml_parse_result res = impl::xml_parser::parse(buffer, length, _root, options);

		// remember encoding
		res.encoding = buffer_encoding;

		// grab onto buffer if it's our buffer, user is responsible for deallocating contens himself
		if (own || buffer != contents) _buffer = buffer;

		return res;
	}

	 xml_parse_result xml_document::load_buffer(const void* contents, size_t size, unsigned int options, xml_encoding encoding)
	{
		return load_buffer_impl(const_cast<void*>(contents), size, options, encoding, false, false);
	}

	 xml_parse_result xml_document::load_buffer_inplace(void* contents, size_t size, unsigned int options, xml_encoding encoding)
	{
		return load_buffer_impl(contents, size, options, encoding, true, false);
	}
		
	 xml_parse_result xml_document::load_buffer_inplace_own(void* contents, size_t size, unsigned int options, xml_encoding encoding)
	{
		return load_buffer_impl(contents, size, options, encoding, true, true);
	}

	 void xml_document::save(xml_writer& writer, const char_t* indent, unsigned int flags, xml_encoding encoding) const
	{
		impl::xml_buffered_writer buffered_writer(writer, encoding);

		if ((flags & format_write_bom) && encoding != encoding_latin1)
		{
			// BOM always represents the codepoint U+FEFF, so just write it in native encoding
		                         
			                          
			                                                 
		     
			buffered_writer.write('\xef', '\xbb', '\xbf');
		      
		}

		if (!(flags & format_no_declaration) && !impl::has_declaration(*this))
		{
			buffered_writer.write("<?xml version=\"1.0\"");
			if (encoding == encoding_latin1) buffered_writer.write(" encoding=\"ISO-8859-1\"");
			buffered_writer.write('?', '>');
			if (!(flags & format_raw)) buffered_writer.write('\n');
		}

		impl::node_output(buffered_writer, *this, indent, flags, 0);
	}

                      
	 void xml_document::save(std::basic_ostream<char, std::char_traits<char> >& stream, const char_t* indent, unsigned int flags, xml_encoding encoding) const
	{
		xml_writer_stream writer(stream);

		save(writer, indent, flags, encoding);
	}

	 void xml_document::save(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& stream, const char_t* indent, unsigned int flags) const
	{
		xml_writer_stream writer(stream);

		save(writer, indent, flags, encoding_wchar);
	}
      

	 bool xml_document::save_file(const char* path_, const char_t* indent, unsigned int flags, xml_encoding encoding) const
	{
		FILE* file = fopen(path_, (flags & format_save_file_text) ? "w" : "wb");
		return impl::save_file_impl(*this, file, indent, flags, encoding);
	}

	 bool xml_document::save_file(const wchar_t* path_, const char_t* indent, unsigned int flags, xml_encoding encoding) const
	{
		FILE* file = impl::open_file_wide(path_, (flags & format_save_file_text) ? L"w" : L"wb");
		return impl::save_file_impl(*this, file, indent, flags, encoding);
	}

	 xml_node xml_document::document_element() const
	{
		for (xml_node_struct* i = _root->first_child; i; i = i->next_sibling)
			if ((i->header & impl::xml_memory_page_type_mask) + 1 == node_element)
				return xml_node(i);

		return xml_node();
	}

                      
	 std::string  as_utf8(const wchar_t* str)
	{
		assert(str);

		return impl::as_utf8_impl(str, wcslen(str));
	}

	 std::string  as_utf8(const std::basic_string<wchar_t>& str)
	{
		return impl::as_utf8_impl(str.c_str(), str.size());
	}
	
	 std::basic_string<wchar_t>  as_wide(const char* str)
	{
		assert(str);

		return impl::as_wide_impl(str, strlen(str));
	}
	
	 std::basic_string<wchar_t>  as_wide(const std::string& str)
	{
		return impl::as_wide_impl(str.c_str(), str.size());
	}
      

	 void  set_memory_management_functions(allocation_function allocate, deallocation_function deallocate)
	{
		impl::xml_memory::allocate = allocate;
		impl::xml_memory::deallocate = deallocate;
	}

	 allocation_function  get_memory_allocation_function()
	{
		return impl::xml_memory::allocate;
	}

	 deallocation_function  get_memory_deallocation_function()
	{
		return impl::xml_memory::deallocate;
	}
}

                                                                     
             
 
	                                                                                                        
	                                                                                  
	 
		                                         
	 

	                                                                                       
	 
		                                         
	 

	                                                                                  
	 
		                                   
	 
 
      

                                                    
             
 
	                                                             
	                                                                                            
	 
		                                         
	 

	                                                                                                 
	 
		                                         
	 

	                                                                                            
	 
		                                   
	 
 
      

                        

                   
              
	               
	 
		                                                                       
		 
			                  
		 
	  

	                   
	 
		                                                                       
		 
			                  
		 
	  

	           
	 
		                                                                       
		 
			                 
		 
	  

	                 
	 
		                                                                       
		 
			                  
		 
	  

	                                               
	 
		             
		          
		           
	 

	                                                                                    
	 
		                 

		                                       
			                       
				            

		              
	 

	                                                  
	 
		                                               
	 

	                                              
	 
		                 
		                                                          

		                               

		                       
		                   

		                        
		                    
		 
			                     
				                    
			    
				        
		 

		                                              
		                 
	 

	                                                                   
	 
		                                        
	 

	                                                                                                          
	 
		                     

		                                       
		 
			            

			                      
			 
				                
				                                  
				             
			 
			    
			 
				            

				                      
				                              
				 
					                    
					       
				 

				                         
				            
			 
		 
	 

	                                   
	                                                                                                                           
	 
		                                     

		                     
		                                                         
		                                                 

		                         
		                               

		        
		 
			                                                                    
			                             
				                          
				 
					                                             
					           
				 

			                                                                    
			                               
				                                
				 
					                                                         
					           
				 

			                       
			                                   
			 
				                   
				                   
				       
			 

			                                              
			                 
			 
				                                             
				                       
			 
			                        
			 
				                                         
				        
				                         
			 
			                              
		 
	 

	                                                                                              
	 
		                                                 
		                                               
		                                                 
	 

	                                                                                             
	 
		                       
		 
			                                   
			                                   
		 
		    
		 
			                 
			                                     

			                                                     
			                                                    
			                                                  
			                                                 
		 
	 

	                                                                                
	 
		                    
		                        
		 
			                      
			                                     
			                                     

			                                    
			               
			                                                    

			                      
			                                
			 
				                       
				            
			 
			    
			 
				                         
				              
			 
		 

		                             
		                                                            
	 
            

                                               
              
	                         
	 	
		                         

		          
	                                     
			                              
	     
			    
	      
		  
	  
		
	                     
	 
		                          
		                  

	       
	                            
		                       
	      

		                                                                                                   
		 
		                            
			                  
		      
		 
		
		                                   
		 
			                                                  

			                                                                       
			                                                         

			                                        
			 
				                                     
				                   
				           
			 
			    
			 
				                                                                         
				                                                                         

				                                                                                               
				                     
				
				                    
				
				              
				                  
				
				                   
			 
		 

		                           
		 
			                                      

			            
			 
			                            
				                      
				                           
			     
				                       
			      
			 

			              
		 

		                                                             
		 
			                                                                       
			                                                                 
			                                                                 

			                                         
			                                                                                   

			                                                                   
			                                            

			                                

			                                                                            
			                                  
			               

			                      
			                         
			 
				                
				                            
				                              

				                                                    
				                
				 
					                              
					                    

					                                             

					         
					 
						                                                         
						                                    
						                   
					 
				 
			 

			              
		 

		                                         
		 
			                     
			                                

			                          
			 
				                                     

				                            

				           
			 

			                
			                    
			                              
		 

		              
		 
			                                
			            

			                 
			 
				                                     

				                            

				           
			 
		 
	  

	                              
	 
		                                                                               
		 
		 

		                          
		 
			                        
		 

		                         
		                       
	  

	                  
	 
		                        
		                      
	  

	                       
	 
		                             
		                       
		                     
		                  

	                            
		                      
	      

		                                                        
		 
			                                    

			                       
			                   

		                            
			                                                           
		      
		 

		                   
		 
			                 
			               
		 
	  
            

               
              
	                  
	 
		                      
		                

		                                                                                            
		 
			                                                                                      
			               

			                                                
			                   

			              
		 

		                                                                             
		 
			                                                          
		 

	       
		                                                            
		 
		 

		                                                                
		 
			                          

			                                                                   
			                     
		 

		                                                                                           
		 
		 

		                                                                            
		 
			                     

			                             

			                                                                                                       
			                     
		 

		                                                          
		 
			                     
			                        

			                                                            
			                                              
			 
				                    
			 
			    
			 
				                         
				                                          
				                                            
				                                                     

				                      
				                                                                                                                                                                                    
				               

				                                                                          
				                                                                         

				                                         
				                                                                          
				                          

				           
				                 
				                  
			 
		 

		                           
		 
			               
		 

		                     
		 
			                          
		 
		
		                                    
		 
			                         
			                
			 
				                                           
				                  
			 

			                                    
		 

		                  
		 
			                     
		 

		                                            
		 
			                                    
		 

		                                            
		 
			                                     
		 

		                      
		 
			                  
		 
	  

	                                                           
	 
		                                
	 
            

              
	                                                                      
	 
		                                       
		 
			         
			          
		 

		                     
	 

	                                                           
	 
	                         
		                    
	     
		                    
	      
	 

	                                                                       
	 
	                         
		                                                                  
		                                    
	     
		                    
	      
	 

	                                                       
	                                        
	 
		                                                                                     
	 

	                                                                                
	 
		                   
			                                                  
		    
		 
			                              

			                 
			 
			                 
			                
			                  
			             
				                                     
			
			                   
			                  
			 
				                    

				                               
				
				                       
				 
					                                                          
						                                                      

					                      
						                        
					                            
						                         
					    
					 
						                                       
							                   

						                                       
					 
				 
				
				              
			 
			
			        
				                      
			 
		 
	 
	
	                                             
	 
		                        
		
		         
		 
			         
			               
		 
		
		              
	 
	
	                                                                                        
	 
		                    
		                                                        
		                                                        
		
		                                        
		                             
		
		                       
		                                  
		 
			                 
			                 
		 

		                                                                                              
		                                 

		                          
		                                  
			             
				            
				
		             
	 

	                                                              
	 
		                                                    

		                                
	 

	                                                            
	 
		                                                       

		         
		 
			                                                                                               
			                                                                                                  
			         
		 

		                                                                 

		         
		 
			                                                                                 
			                                                                                   
			         
		 

		         
	 
	
	                                
	 
		                                                                   
		 
			                                       
			                                     
			                                     

			                             

			                  
			                                          

			                     
			                                       
			 
				                
				                                 
				 
					                          
					                                                                  
						                         
							            
					
					             
				 
				
				                            
				                  
				                  
			 
			                         
			 
				                                         
				                                             
				
				                  
			 
			                         
			 
				                                         
				                                            
				
				                  
			 

			                           
			
			                                  
			                                  
			
			                                      
		 
	  

	                           
	 
		                                                                   
		 
			                                                                                       
			                                                              
		 
	  
	
	                         
	 
	                                                                                                               
		                                                                             
		                    
		              
	     
		           
		                                 
		                   
	      
	 
	
	                                  
	 
	                                                            
		                       
	                                            
		                                   
	     
		           
		                                
		              
	      
	 
	
	                                                                     
	 
	                                                            
		                                                                
		                                              
		                                                                        
	                                                                                        
		                          
		 
		            
			                           

		                 
			                                                                        

		             
			                         

		        
			         
		 
	     
		           
		                                

		                                     
		                                       
		                                                                                        
		         
	      
	 
	
	                                                     
	 
		                                      
	 
	
	                                                    
	 
		                                             

		         
	 

	                                                                               
                                                                                             
	                                                                                                                                         
	 
		                  
		                   
		                                                                   

		                           
		                                                

		               
		                       
		                         
	 
     
	                                                                                                                                         
	 
		                                                             
		                                        
		                                     
		                   

		                                       
		                                            
		                        

		                                         

		                                     
		                                                        
		                                                 

		                                                  
		                          
		           
		           

		                                                           
		                                          

		               
		                         
		                         
	 
      

	                                                                                    
	 
		                                
		                                                                
		                                                

		                               
		                         

		               
		             
		                                                                                                           

		                   
		                   
		                   

		       
		                          

		               
		                  
		 
			           
		 
		    
		 
			                    
			 
				                                                                          
				                                     
				           
			 
		 

		                  
		              
		 
			                
			           

			                                      
			                    
			 
				           
				           
			 

			                        
			                 
			 
				                                                        
				                   
			 
		 

		                 
		                                                        
		       

		                                   
	 
	
	                                                                 
	 
		                           
		                                                      

		             
		                             

		                           

		                                                                                      
		                                                                                                                               

		                     
		                                                        

		                     
		                   
		 
			         

			                                                        
		 

		                            
		                                                      

		                    
	 

	                                                              
	 
		                      
		                                                             

		               
	                         
		                         
	     
		                    
	      
	 

	                                                                                                  
	 
		                  

		                                                 
		                         

		                                                 
		 
			                                  
			                                                                                    
			                           
		 

		                                                               
		                                                
		                    

		                                                

		                    
		                                                       

		            
	 
	
	                                           
	 
		                          
	 

	                                                 
	 
		                                                       
		                                                                                              
		                                                                        
	 
	
	                                                             
	 
		                                                                       
	 
	
	                                                         
	 
		                                          
		                                       
		
		                        
	 

	                              
	 
		                     
		                     

		                                           
		 
			                                         

			                        
			                                                          
		 

		                                             
		 
			                              

			                                                            

			                                                                                                
		 
	  

	                                                          
	 
		                                           
		
		                  
		
		         
		 
			                                         
			
			                        
			
			               
		 
		
		                        
	 

	                                                                                       
	 
		                                           
		
		                                                 
		                                          
		
		                    
		
		         
		 
			                                         
			
			                        
			
			               
		 
		
		                        
	 

	                                                            
	 
		                                                                                                      
	 

	                                             
	 
		                       

		                                
		 
			                  

			                                    
			 
				                                                
				                                              

				                       
				                                    
			 
			                   
		 

		                        
		                                                                       

		                 
		           
	 

	                                                                             
	 
		                                 

		                       

		               
		 
			                                         

			                                        

			         
				                                
			                                                     
				                                     
		 

		                 
		           
	 

	                                             
	 
		                                      
		 
		 

		           
		               
	  

	                                            
	 
		                                 
		 
		 

		             
		               
	  

	                                            
	 
		                                 
		 
		 

		                        
		 
			                                         
		 

		              
		               
	  

	                                              
	 
		                     
		               
	  

	                                           

	                                                    
	 
		                                                                                                
		                        

		            
		 
			                                            
			                       
			                      
		 
	
		                      
		                       
		                       
	
		              
	 

	                                                                        
	 
		                                
		                                                              

		                                                                                                           
		                                                                         
		                      

		                             

		                                                          

		              
	 

	                                                                                      
	 
		             
		 
		                         
			                                                         

		                       
			                                                       

		                       
			                                                       

		                        
			                                                        

		        
			         
		 
	 

	                                                                 
	 
		          
		                            
	 

	                                                                               
	 
		             
		 
		                         
			                                                                  
			      

		                       
			                                                                
			      

		                       
			                                                                
			      

		                        
			                                                                 
			      

		        
			                                 
		 
	 

	                                                                                                      
	 
		                  

		                                                 
		                         

		                                                 
		 
			                                  
			                                                                                    
			                       
		 

		                                                           
		                                                
		                    

		                                           

		                    
		                                                       

		              
	 
            

                          
              
	                                                                                                                     
	 
		                                                                                                       

		                                          
		 
			                                              

			                                   
		 
		
		                                       
			
		             
	 

	                                                                                                            
	 
		                                      

		             
		 
		                                 
			              

		                                         
			                  

		                                   
			                                                             

		        
			                                 
			                    
		 
	 

	                        
	 
		                             

		                   
		                 
		                 

	       
		                                                                                       
		 
		 

		                         
		 
			              
		 

		                       
		 
			            
		 

		                  
		 
			                      
		 

		                   
		 
			                                          
		 

		                        
		 
			                                        
		 

		                                                              
		 
			                 
			 
				                                                     

				                               
				                                                  

				                                                 
				                                                                                                                                         
				             

				           
				              
				                       
				                           
			 

			               
		 

		                                                                                     
		 
			                                                  
			                                                     
			                                                  

			                             
			 
				                                                 
				                                                                                                                                            
				             

				           
				              
				                    
				                            
			 

			                                                 
			              
		 

		              
		 
			                                               
		 

		                              
		 
			                                     

			           
		 

		                        
		 
			                                           
				                                           
		
			                            
		 

		                                   
		 
			             
		 

		                                           
		 
			              
		 
	  
            

              
	                    
	 
		             
		                      

		                                                                                                            
		 
		 
	  

	             
	 
		             
		          
		              
		         
		            
		                  
		                     
		         
		          
		             
		          
		            
		               
		                
		                  
		           
		          
		                 
		                      
		                       
		           
		          
		                   
		        
		               
		                 
		       
	  

	                         
	 
		                    
		                  

		                                      
		 
		 

		                                          
		 
			                                                 

			                                           
		 
	  

	                 
	 
		                   
		                              
		                                        

		                     

	       
		                                                      
		 
			       
		 
		
		                           
		 
			            
		 
		
		           
		 
			                         

			                                                

			                                           
			                      

			             
			 
			       
				                      
				      
			
			         
				                    
				 
					         
					                                   
				 
				    
				 
					         
					                          
				 
				      

			         
				                    
				 
					         
					                                
				 
				    
				 
					         
					                       
				 
				      

			         
				                    
				 
					         
					                            
				 
				    
				 
					                       
				 
				      

			         
				         
				                        

				      
			
			         
				         
				                       

				      

			         
				         
				                        

				      

			         
				         
				                           

				      

			         
				         
				                        

				      
			
			         
				         

				                                               
				 
					                                 

					                                                   

					                                                                     
					 
						           

						                                                   
					 

					                               
				
					                          
				 
				    
				 
					                       
				 

				      

			         
				         
				                             

				      

			         
				         
				                              

				      
			
			         
				         
				                                    

				      

			         
				         
				                                     

				      

			         
				         
				                        

				      

			         
				                    
				 
					         
					                               
				 
				    
				 
					         
					                        
				 
				      
		
			         
				                    
				 
					         
					                             
				 
				                                                 
				 
					                                      

					      

					                                                  

					                               
					
					                         
				 
				    
				 
					         
					                      
				 
				      

			         
				         
				                                 

				      

			         
			          
			 
				                         

				      

				                                 
				                                         
				                               
				
				          
					                       
				    
				 
					         
					                                
				 

				      
			 

			         
				                    
				 
					         
					                               
				 
				    
				 
					                       
				 
				      

			        
				                                        
				 
					                                 

					                                                  
				
					                
					 
						      

						                                                  
					 

					                               

					                         
				 
				                                                    
				 
					                                 

					                                                   

					                  
					 
						                                             
						 
							               
						 
						                                                                        
						 
							           

							                                                   
						 
					 

					                               
				
					                         
				 
				    
				 
					                       
				 
			 

			           
		 

		                        
		 
			                   
		 

		                                 
		 
			                       
		 

		                                          
		 
			                                                                                                                                 

			                            
		 
	  

	               
	 
		          						                
		           						                 
		             					               
		                 				                
		            					               
		               					               
		                     			                
		                        		                
		           						               
		                				               
		                				               
		              					               
		           						               
		              					               
		             					               
		              					                                                        
		           						                                 
		                  				                                                               
		                    			                  
		                    			                  
		             					           
		              					         
		                  				             
		               					              
		            					           
		                      			               
		                      			                   
		                         		                  
		                         		                      
		                				         
		                				             
		                  				           
		                  				               
		                				                                
		                     			                           
		                  				                        
		                          		                                
		                         		                               
		                     			                         
		                     			                                
		                         		                  
		                         		                      
		                           		                    
		                           		                        
		                   				                                
		                 				                
		             					            
		              					         
		               					          
		              					             
		                  				           
		                  				               
		             					            
		               					              
		                 				                
		               					              
		         						                             
		             					                   
	  

	           
	 
		              
		                      
		               
		           
		                
		                        
		               
		                       
		               
		            
		               
		                       
		         
	  
	
	               
	 
		              
		              
		                   
		                      
		                 
		                   
		            
		             
		                         
	  

	                                       
	 
		                         
	  

	                                                           
		
	                    
	 
	        
		            
		           
		              

		                               
		           
		           

		                      
		                      
		                       
		                      

		     
		 
			                                
			                     
			                                
			              
			                            
			                         
			                                                                   
			                       
		        

		                                      
		                                                 

		                                                                                                                                                          
		 
			                                                          

			                                                           
			 
				                                                         
					                                                                      
				                                                            
					                                                                    
				                                                            
				 
					                                         

					                                             
					                                             

					                    
				 
			 
			                                                                
			 
				                                         

				                                                     
				                                                     

				                                                             
					                                                             
					 
						                                          

						                                                                           
							            
					 

				             
			 
			    
			 
				                              
				 
					               
					             
				 

				                             
					                                                                      
				                                 
				 
					                                         

					                                      
					                                                     

					                                                             
					 
						                                          

						                                                                               
							            
					 

					             
				 
				                                 
				 
					                                         

					                                            
					                                                     

					                                                             
					 
						                                          

						                                             
							            
					 

					             
				 
			 

			                       
			             
		 

		                                                                                                                                                           
		 
			                                                          

			                                                           
				                                                                    
			                                                                
			 
				                                         

				                                                     
				                                                     

				                                                             
				 
					                                          

					                                                                             

					                                                             
					 
						                                           

						                                                                               
							            
					 
				 

				             
			 
			                                                                
			 
				                                         

				                                      
				                                                     

				                                                             
				 
					                                          

					                                                                               
						            
				 

				             
			 
			                                                                
			 
				                                         

				                                                     
				                                      

				                                                             
				 
					                                          

					                                                                               
						            
				 

				             
			 
			    
			 
				                       
				             
			 
		 

		                                                                                                          
		 
			                           

			             
			                                
				
			                                      
				
			                                
			                                                      
			 
				                              
			
				                                         
				 
					                                     
						              
				 
				                                      
					              
			 
			
			                  
		 

		                                                                                     
		 
			                               
			
			                                                             
			 
				                                               
			 
		 

		                                                                                                              
		 
			               

			                              

			                                                                                   
			                                  
			                                                                                         
			
			              
			 
			                   
				                                                                               
				      
				
			                        
			                  
				                                           
				      
				
			                               
				                                      
					                                           
				      
			
			        
				 
			 
		 
		
		                                                                                 
		 
			               

			              
			 
			                   
				                                                                                           
				      
				
			                        
				                       
				      
				
			                           
				                             
					                       
				      
				
			                        
				                                                      
					                       
				      
				
			                      
				                        
					                       
				      
									
			                 
				                                                              
					                       
				      
				
			                  
				                             
					                       
				      
				
			                               
				                                                                      
					                       
				      

			        
				                        
			  
		 

		                                                                                                       
		 
			                            

			             
			 
			                    
			 
				                                                                      
					                           
				
				      
			 
			
			                
			 
				                                                           
					                        
					
				      
			 
			
			                     
			                             
			 
				                                    
					                        
					
				                               
				
				                       
				 
					                          
					
					                      
						                        
					                            
						                         
					    
					 
						                                       
							                   
					
						                                       
					 
				 
				
				      
			 
			
			                            
			 
				                                                            
					                        
				
				      
			 
			
			                            
			 
				                                                                    
					                        
				
				      
			 
			
			                    
			 
				                 

				                                                           
				                                                      
				                         

				        
				 
					                          

					                      
						                        
					                            
						                         
					    
					 
						                                                      
						                         

						                
					 
				 

				      
			 

			                    
			 
				                 

				                                                          
				                             

				        
				 
					                     
						                       
					    
					 
						                               
						                          

						                           
							                             
						    
						 
							   
							 
								                   
								                

								                                                         
							 
							                                

							                             

							                
						 
					 
				 

				      
			 
			
			                   
			                           
			 
				                                  
					                        

				                          
				
				           
				 
					                          
					
					                   
				 
				
				      
			 

			               
			 
				                        

				      
			 

			                 
			 
				                                                 

				      
			 
				
			        
				                              
			 
		 
		
		                                                                                                                                 
		 
			                            

			             
			 
			                   
			                           
			 
				                                                                                                                        
					                           

				                 
				
				           
				 
					                          
					
					                   
				 
				
				      
			 

			                             
			               
			 
				                                                                                       
					                           

				      
			 

			                    
			 
				                 
				
				        
				 
					                      
						                        
					                            
						                         
					    
					 
						                                                      
						                         
						
						                
					 

					                          
				 

				      
			 

			                 
			 
				                        

				      
			 

			                    
			 
				                                                                                                                                                      
				                           
				      
			 
			
			        
				                              
			 
		 
		
		                                                                                                    
		 
			                            
			                                                                                                                                                                                                              

			                      
			                                                                                                                                                                                                      

			          
			 
				                                                      

				                                         
				                                             

				                                                           
				 
					                        

					                                                                                                                                
					                                                                               
					
					               
						                                           
					                    
						                                                              
						
					                                  
				 
			 
			    
			 
				               
					                                           
				                    
					                                                              
				
				                               
			 

			                                                                     
			                                                                                                                               
			                                                                                                                    
				                       

			          
		 
		
	       
		                                                                                
			                                                                                                                        
		 
			                                    
			                     
		 

		                                                                         
			                                                                                                                        
		 
			                                    
			                     
		 
		
		                                                                                  
			                                                                                                                        
		 
			                             
			                       
		 
		
		                                                                                                                
			                                                                                                                               
		 
		 

		                                                                                                            
			                                                                                                                                                               
		 
			                          
		 

		                                    
		 
			              
		 

		                                     
		 
			               
		 

		                                                                   
		 
			              
			 
			               
				                                                                       
				
			                
				                                                                       
				
			                  
				                                                       

			                      
				                                                           
	
			                 
				                                                    
			
			                    
				                                                    

			                          
				                                                          
			
			                             
				                                                          

			                          
			 
				                                         

				                                               
				                                                

				                                           
			 

			                       
			 
				                                         

				                                               
				                                                

				                                                   
			 

			                      
				                                     
				
			                  
				                                      
				
			                   
				            
				
			                    
				             

			                   
			 
				                                  
				
				                                         

				                                                 
				
				                                                
				 
					                                                        
					
					      
					 
						                                
						
						                                         
						                                                   
						 
							                                                               
							        
						 
						
						                                    
					 
				 
				
				             
			 

			                  
			 
				                                           

				                                   
					                                     

				                                 
			 

			        
			 
				                 
				 
				                       
					                                                        
					
				                       
				 
					                                         

					                                      
				 
					
				                         				
				 
					                                         

					                                        
				 

				        
					                                                    
					             
				 
			 
			 
		 

		                                                                    
		 
			              
			 
			                
				                                                                    
				
			                     
				                                                                    

			                     
				                                                                    

			                   
				                                                                    

			                
				                                                                         

			                   
				                                     

			                         
				                    

			                   
				                                   
			
			                       
				                                       

			                    
			 
				                                         

				                                                                  
			 
			
			                              
			 
				                                         

				                                                                     
			 
			
			                              
			 
				                                         

				                                                                  
			 
			
			                       
			 
				                                         

				                                                                         
			 
			
			                       
				                                    

			                  
			 
				                                         

				             
				
				                                                       
				
				                                                             
				 
					                                          

					                                                                       
				 
			
				         
			 

			                    
			 
				                                        
				
				                             
			 

			                      
			 
				                                        
				
				                            
			 

			                    
				                                                         
			
			                  
			 
				                                           

				                                  
					                                    

				                                 
			 

			        
			 
				                 
				 
				                        
					                                      
					
				                       
				 
					                                         

					                                                               
				 
					
				                         
				 
					                                         

					                                                               
				 
					
				        
					                                                   
					         
				 
				
			 
			 
		 
		
		                                                                                 
		 
			                                 

			                                       

			                          
			                 
			                                                              

			                     
			                              
			                                     

			                                     
			                                                             
			 
				                                                                                        
				               
			 

			                                          
			                                                       

			                                                 

			               
			                                                                                                        
			                     

			                   
			                  
			                                                                

			                      
			                                                                                             
			               

			                    

			                                  
				                                                     
					            

			        

			                                  
		 

		                                                                          
		 
			              
			 
			                         
				                                        
			
			                           
			 
				                    
				
				                                          
			 

			                           
			 
				                                         

				                                                       
				                           
				
				                                          
			 

			                     
			 
				                    
				
				                                              
			 

			                     
			 
				                                         

				                                                       
				                           
				
				                                              
			 

			                              
			 
				                    
				
				                                             
			 

			                              
			 
				                                         

				                                                       
				                           
				
				                                             
			 

			                       
				                                       

			                       
				                                    

			                     
				                                    

			                               
			 
				                                       

				                                                       

				                                                      
				                                                       

				                                                         
				
				                                                                         
			 
			
			                              
			 
				                                       

				                                                       

				                                                      
				                                                       
				
				                                                         
				                                

				                                        

				                                                                                       
			 

			                          
			 
				                                       

				                                                       

				                                                      
				                             

				                                                            
				
				                                                
				                                                      
				
				                                                        
				                                        

				                                             
				
				                                                                                       
			 
			
			                          
			 
				                                       

				                                                       

				                                                      
				                             

				                                                            
				                                                                          
				
				                                                         
				                                                      
				                                              
				                                         
				
				                                                        
				                                                                             

				                                                      
				                                             
				                                           

				                                                                                                                       
			 

			                                
			 
				                                                 

				                                      

				         
			 

			                                
			 
				                                              

				                                      
			
				         
			 

			                        
			 
				                                       

				                                                       

				                                              
				                                                          
				                                                               

				                                                          

				         
			 

			                  
			 
				                                           

				                                  
					                                                        

				                                 
			 

			        
			 
				                 
				 
				                        
					                                                                                                 
					
				                       
					                                                                     
					
				                         
				 
					                                       

					                                                       

					                                                        
					                                                                            
				 
				
				        
					                                                   
					                      
				 
			 
			 
		 

		                                                                                  
		 
			              
			 
			                  
			 
				                                       

				                                                       

				                                                               
				                                                        
				
				                                                                                              
				                                           

				                                              
				                       
				
				          
			 

			                
			                       
			 
				                                                        

				                                                                                       
				                                       

				                                       
			
				           
			 
			
			                 
				                            
			
			              
			 
				              
				 
				                   
					                                                        
					
				                           
					                                                                

				                    
					                                                         

				                
					                                                     
				
				                     
					                                                          

				                             
					                                                                  

				                    
					                                                         
				
				                            
					                                                                 
				
				                    
					                                   
					                            
				
				                 
					                                                      
				
				                    
					                                                         

				                            
					                                                                 
				
				               
					                                                    

				        
					                        
					                            
				 
			 

			                   
			 
				                                                       

				                      

				                                         

				                                                              
				                                                                          

				          
			 

			                  
			 
				                                           

				                                    
				 
					                                                         

					                      

					                      
					                                            

					          
				 

				                                 
			 

			        
				                                                     
				                            
			 
		 
		
		                
		 
			              
			 
			                       
				             

			                         
			                         
			                  
				            

			              
			                   
				            

			                   
			                
			                       
				            

			        
				                                               
				
				                                                 
					                                  
					
				            
			 
		 

		                                
		 
			                                               
		 
	  

	                   
	 
		                        
		                   

		                     
		                               

		                            

	                            
		                       
	      

		                                     
		 
			                         
			                                                

		                            
			                           
		     
			                                
		      
		 

		                      
		 
		                            
			                             
		     
			                       
		      
		 

		                  
		 
			                                                                

			                               

			              
		 

		                                                           
		 
			                
			 
				                                                             

				                                                                                          
				                          

				                                                
				              

				         
			 
			              
		 

		                                                                                                               
		 
			                  

			                                                                                                                  

			                                                                                                
		 

		                                                                                                    
		 
			                      
			 
			         
				                                                 
					                                                                                        
					
				      
			
			         
				                                               
				 
					                                                                                                     
					                                                                                     
				 
				                                                       
					                                                                                                 
				                                                     
					                                                                                               
				                                                      
					                                                                                       
					
				      
			
			         
				                                               
					                                                                             
				                                                    
					                                                                                     
					
				      
			
			         
				                                            
					                                                                                    
					
				      
			
			         
				                                              
					                                                                           
				                                                   
					                                                                                     
				                                                         
					                                                                                       
			
				      
			
			         
				                                              
					                                                                           
				                                                            
					                                                                                             
				                                                              
					                                                                                                                                                   
				                                                  
					                                                                                    
				                                                     
					                                                                                                                        
			
				      
			
			         
				                                                  
					                                                                               
				
				      
			
			         
				                                               
					                                                                                     

				      
			
			         
				                                                
					                                                                                                                        
				                                                            
					                                                                                                                                      
				                                                          
					                                                                                                     
				                                                               
					                                                                                                         
				                                                              
					                                                                                                        
				                                                                       
					                                                                                                                                       
				                                                  
				 
					                                                                                                     
					                                                                                   
				 

				      
			
			         
				                                                   
					                                                                                                  
				                                                   
					                                                                            
					
				      

			        
				      
			 

			                                                              

			         
		 

		                                                                       
		 
			                 

			                      
			 
			         
				                                     
					                     
				                                                  
					                             
				                                           
					                      
				
				      
			
			         
				                                  
					                  
				
				      
			
			         
				                                       
					                       
				                                                    
					                               
				
				      
			
			         
				                                      
					                      
				                                                   
					                              
				
				      
			
			         
				                                      
					                      
				
				      
			
			         
				                                   
					                   
				                                           
					                      
				                                                   
					                              
				
				      
			
			         
				                                 
					                 
				
				      

			        
				      
			 

			                  
			                  
		 

		                                                               
		 
			                      
			 
			         
				                                    
					                             

				      

			         
				                                 
					                          

				      

			         
				                                                   
					                        

				      

			         
				                                 
					                          

				      
			
			        
				      
			 

			                     
		 

		                                                                                     
		                                          
		 
			                         
			 
			                 
			 
				                                            

				                
					                                                              

				                                                                     

				         
					                                                                              

				              

				                                                                         
			 

			                    
			 
				              

				                                       

				                                        
					                                

				              

				         
			 

			                       
			 
				                                                      

				                                                                                                     
				              

				         
			 

			                
			 
				                 

				                                                                                      
					                  

				                                                                                                     
				              

				         
			 

			                
			 
				                              
				                
				
				                                                
				              
				
				                             
				
				                                       
					                                          
				              

				                                        
					                                  

				                                           
				 
					                                  
						                                                   
					              
					
					                                       
					
					                             
					                           

					       
					             
				 
				
				              

				                                            
			 

			        
				                                                 

				         
			 
		 
		
		                                                    
		                                      
		                         
		                                         
		 
			                                               

			                                                 
			 
				              

				                                          

				                                                                                                

				                                                                        

				                                                                                                             

				                                               
					                                      
			
				              
			 
			
			         
		 
		
		                                                               
		                                         
		                                                                                      
		                                            
		                                 
		                                               
		 
			                                                 
				                                                  

			                            
			                                               

			                                           
			 
				                      
				                      
				
				              
			 
			                                     
			 
				              
				
				                                                                                          
			 
			                                            
			 
				              
				
				                                                                                            
			 
		
			                                   
			                           
			
			                                   
			 
				                 
				                            
				              

				                       
				                                         
				 
					                  
					                                                                   

					                                                

					                                                 

					                        
					              

					                                     
					 
						                       
						                               
						              
					 
					                                        
					 
						                            
						              
					 
					                                           
				 
				
				                             
				 
					                                           
					                                       
					 
						              
						
						                                        
						 
							              

							                                        

							                                                                    
							
							                               
						 
						                                                           
						 
							                                          
								                                                                                  
						
							                      
							                            
							              
							
							                                        
								                                                             
							              
						 
						    
							                                                   

					 
					                    
					    
					 
						                                                                                                    
						 
							                         
							
							                                    
						 
						                             
					 
				 
			 
			                                          
			 
				                       
				              
			 
			                                           
			
			                                                                                                           
			
			                         
			
			                                                 
			 
				              
				
				                                          

				                                                                                                   
				
				                                               
					                                      
				              
				
				                               
				                        
				
				            
			 
			
			         
		 
		
		                                                                                                 
		                                                                 
		 
			                                    
			
			                                                                             
			 
				                              
				              

				                          
					                                                                                                   
				
				                  
			 
			
			         
		 
		
		                                                               
		                                                                                 
		                                     
		 
			                                  
			 
				              
				
				                                                                                          

				                                                                                                                                                  
				                              

				                                                                                                           
					                                       
				    
					         
			 
			                                              
			 
				              
				
				                                                                                          
				                                                                                                   
				
				                                       
			 

			                                                                                                                                   
			                                       
		 
		
		                            
		  				            
		  				                                     
		  				                                      
		                                       
		 
			                 
			                                                          
			                                     
			                                                                        
			                                                                            
			                 

			                                                                             
				                                                                          
				                               
			 
				                                   
				 
					                                                                                       
					                                     
					
					                                                    
					
					                                                

					                                                                                    
					                                                                                           
				 
				
				                                              

				                                                                          
				 
					                              
					              
					
					                          
					 
						                                                                                           

						                                                                                                   
					 
	
					                            
					                                       
				 

				         
			 
			                                  
		 

		                                                  
		                                        
		 
			                                            

			                                     
			 
				              

				                                                

				                                                                                  
					                                                             

				                                                                                  
			 

			         
		 

		                                          
		                                        
		 
			                                  
			 
				              

				                                                

				                                                                                 
			 
			                                     
		 
		
		                                   
		  						                                    
		  						                                      
		  						                                      
		                                                 
		 
			                                             

			                                                                             
				                                                                                           
			 
				                                                                    
					                                                               
				              

				                                                

				                                                                      
			 

			         
		 

		                                      
		  					                                     
		  					                                     
		                                           
		 
			                                                      

			                                                                     
			 
				                              

				              

				                                                         

				                                                                                                                
			 

			         
		 

		                                  
		  					                                   
		  					                                   
		  					                                    
		  					                                    
		                                             
		 
			                                                

			                                                                                
				                                                                               
			 
				                              
				              

				                                                   

				                                                                                                       
								                                                                                                      
			 

			         
		 
		
		                                  
		  					                                 
		  					                                  
		                                           
		 
			                                                  

			                                                                          
			 
				                              

				              

				                                                     

				                                                                                                                     
			 

			         
		 
		
		                                                        
		                                      
		 
			                                                

			                                                                                  
			 
				              

				                                                   

				                                                                               
			 

			         
		 

		                                           
		                                     
		 
			                                           

			                                                                                 
			 
				              

				                                              

				                                                                              
			 

			         
		 
		
		                  
		                                  
		 
			                             
		 

		                                                                                                                                                                                                         
		 
		 

		                       
		 
			                                            
			
			                                
			 
				                                              
				                               
			 
			
			              
		 

		                                                                                                                                    
		 
			                                                     

		                            
			                                          

			                                         
		     
			                      
		      
		 
	  

	                       
	 
		                                 
		 
			                                                              

			                                       
		 

		                              
		 
			                 
			
			                           
			                                                     

			                                              
			                            
		 

		                                          
		 
			               
		 

		                     
		                      
		                         
	  

	                                                                                                             
	 
		                                 

	                            
		                                                    
	      

		                         

		                                            
	 
            

              
 
                             
	                                                                                              
	 
		                      
	 
	
	                                                          
	 
		                     
	 

	                                                                  
	 
		               
	 
      
	
	                                 
	 
	 
		
	                                                                    
	 
	 
		
	                                                                                                                                                           
	 
	 

	                                          
	 
		                                       
	 
		
	                                                    
	 
		                  
	 
	
	                                            
	 
		                                           
	 

	                                                               
	 
	 

	                                                                       
	 
		                                                               
	 
	
	                                           
	 
		                              
	 

	                                                               
	 
		                                                      
	 
	
	                                                               
	 
		                                                      
	 

                   
	                                                         
	 
		                        
	 

	                                                         
	 
		                        
	 
      

	                                                                                 
	 
		                       

		                                                  

		               
		 
			                        
			                                                              

			                      
			                                       

			                   
			                         
		 
		    
		 
			                 
			                                                                                                       

			             
			 
			                            
				       
			     
				                       
			      
			 

			                                                    
			
			                        
			                                                              

			           
			                 
			                       
		 
	 

	                                                                                                   
	 
	 

	                                                                                                                                                   
	 
		                      
	 

	                                          
	 
		                                                              
	 
		
	                                                                                                                      
	 
		                            
	 
	
	                                                                            
	 
		                              
		
		                 
		                            

		             
	 

	                                                            
	 
		             
	 
		
	                                            
	 
		                     
	 
		
	                                           
	 
		                      
	 
		
	                                                                         
	 
		                       
		                     
	 

	                                                                     
	 
		              
	 
		
	                                                                   
	 
		            
	 
	
	                                                
	 
		                                                       
	 

	                                                 
	 
		                                              
	 

	                                                                                     
	 
	 

	                                                  
	 
		                  
	 

	                                                            
	 
		                                  
	 

	                                         
	 
	 

	                                                   
	 
		              
		 
		                         
			                                                                     

		                       
			                                                                   

		                       
			                                                                   

		                        
			                                                                    

		        
			                                 
			         
		 
	 

	                                                      
	 
		             
	 

	                                                 
	 
		                                                                                                             
	 

	                                                  
	 
		                                                                                                                     
	 

	                                                         
	 
		                                                                                                                      
		                                        
	 

	                                                                   
	 
		                                                                                                                              
	 

	                                             
	 
		                                              

		                                                                
		            
	 

	                                               
	 
		                                             

		                                                               
		            
	 

	                                                      
	 
		                                             

		                                                                                   

		                   
		                                                            

		                                                                      
		                        

		                          

		                     
		                                                         
		                  

		            
	 

	                                                              
	 
		                                               

		                                                                 
		            
	 

	                                                 
	 
		                                                                           
	 

	                                                  
	 
		                                                             
		 
			                               

			           
			 
				                                  

				                                             

				           
			 
		 
	 

	                                                                           
	 
		                                                          
		                                                  

		                             
		                                                              
			                                      
				           

		         
	 

	                                                                                           
	 
		                                                          
		                                                  

		                             
		                                                              
			                                      
				                                     

		                   
		                                                              

		           
		 
			                     
			                            

			                     
		 

		              
	 

	                                                                     
	 
		                                                    
		                                     
	 

	                                                                       
	 
		                                                   
		                                     
	 

	                                                                              
	 
		                                                   
		                                     
	 

	                                                                                      
	 
		                                                     
		                                     
	 

	                                                                    
	 
		                  
	 

	                                                                                
	 
		                  
	 

	                                                                                               
	 
		                                                                 

		           
		 
		                            
			                                
		     
			                       
		      
		 
		    
		 
			                                                                        

			                                                                                   

			                
			 
				                                                                    
				                  
			 
		 
	 

	                                    
	 
		                                       
	 

	                                                          
	 
		                                   

		                                                                    
	 

	                                                                      
	 
		                         
		
		                               
		                          

	                            
		                                           
	      
		
		                                                                                    
	 
	
	                                                                       
	 
		                                   
		
		                               
		                          

	                            
		                                                     
	      

		                                                                                   
	 

                      
	                                                                         
	 
		                          

		                                                                                              
	 
      

	                                                                                                        
	 
		                          

		                                                                                                      

		                                  
		
		                 
		 
			                                                            
			                 

			                                                       
			                     
		 
		
		                 
	 

	                                                                                 
	 
		                                    

		                                                                               

		                                           
		 
		                            
			                        
		     
			                       
			                                                       

			                           
		      
		 
		
		                               
		                          

	                            
		                                                      
	      

		                                                              

		                                                    
	 

	                                                              
	 
		               
	 

	                                                                 
	 
	 

	                                                                         
	 
		                                                
	 

	                                            
	 
		              
	 

	                                                                                                          
	 
		                                
		                             
	 

	                                                                                
	 
		                                                  
		                                            
	 

	                                                                                                        
	 
		                                
		                       
	 

	                                                                              
	 
		                                      
	 
 

      

                   
       
      

// Intel C++ does not properly keep warning state for function templates,
// so popping warning state at the end of translation unit leads to warnings in the middle.
                                                   
       
      

// Undefine all local macros (makes sure we're not leaking macros in header-only mode)
                      
                          
                         
                             
                     
                   
               
                         
                             
                        
                         
                   
                   
                     
                    
                    
                      
                   
                        
                        

      

/**
 * Copyright (c) 2006-2012 Arseny Kapoulkine
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */
