
#__FILE__ _"C:\Users\Billy\Dropbox\Thesis\Projects\pwsafe-3.32-src\src\os\windows\yubi\YkLib.cpp" 0
/*************************************************************************
**                                                                      **
**      Y K L I B  -  Unified Yubikey low-level interface library       **
**                                                                      **
**      Copyright 2011 - Yubico AB                                      **
**                                                                      **
**      Date   / Sig / Rev  / History                                   **
**      110329 / J E / 0.00 / Main                                      **
**      111011 / J E / 0.00 / Fixed memory leak flushPortNames			**
**		111111 / J E / 0.90 / Added HOTP helper functions + release		**
**		111121 / J E / 0.91 / Fixed bug with helper functions           **
**		130205 / J E / 0.92 / Added support for NEO                     **
**                                                                      **
*************************************************************************/

                  
#__FILE__ _"C:\Users\Billy\Dropbox\Thesis\Projects\pwsafe-3.32-src\src\os\windows\yubi\StdAfx.h" 0
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

       

                     
#__FILE__ _"C:\Users\Billy\Dropbox\Thesis\Projects\pwsafe-3.32-src\src\os\windows\yubi\targetver.h" 0
       

// The following macros define the minimum required platform.  The minimum required platform
// is the earliest version of Windows, Internet Explorer etc. that has the necessary features to run 
// your application.  The macros work by enabling all features available on platform versions up to and 
// including the version specified.

// Modify the following defines if you have to target a platform prior to the ones specified below.
// Refer to MSDN for the latest info on corresponding values for different platforms.
                    
                                                                                                            
      


#__FILE__ _"C:\Users\Billy\Dropbox\Thesis\Projects\pwsafe-3.32-src\src\os\windows\yubi\StdAfx.h" 12

                                                                                         



// TODO: reference additional headers your program requires here

#__FILE__ _"C:\Users\Billy\Dropbox\Thesis\Projects\pwsafe-3.32-src\src\os\windows\yubi\YkLib.cpp" 16
                 
#__FILE__ _"C:\Users\Billy\Dropbox\Thesis\Projects\pwsafe-3.32-src\src\os\windows\yubi\YkLib.h" 0
/*************************************************************************
**                                                                      **
**      Y K L I B  -  Unified Yubikey low-level interface library       **
**                                                                      **
**      Copyright 2011 - Yubico AB                                      **
**                                                                      **
**      Date   / Sig / Rev  / History                                   **
**      110329 / J E / 0.00 / Main                                      **
**		111111 / J E / 0.90 / Added HOTP helper functions + release		**
**                                                                      **
*************************************************************************/

       

       
                 
#__FILE__ _"C:\Users\Billy\Dropbox\Thesis\Projects\pwsafe-3.32-src\src\os\windows\yubi\ykdef.h" 0
/*****************************************************************************************
**																						**
**		Y K D E F  -  Common Yubikey project header										**
**																						**
**		Date		/ Rev		/ Sign	/ Remark										**
**		06-06-03	/ 0.9.0		/ J E	/ Main											**
**		06-08-25	/ 1.0.0		/ J E	/ Rewritten for final spec						**
**		08-06-03	/ 1.3.0		/ J E	/ Added static OTP feature						**
**		09-06-02	/ 2.0.0		/ J E	/ Added version 2 flags                         **
**		09-09-23	/ 2.1.0		/ J E	/ Added version 2.1 flags (OATH-HOTP)           **
**      10-05-01    / 2.2.0     / J E   / Added support for 2.2 extensions + frame      **
**      11-04-15    / 2.3.0     / J E   / Added support for 2.3 extensions              **
**      11-12-05    / 2.4.0     / J E   / Added support for NFC and NDEF                **
**      12-10-28    / 3.0.0     / J E   / NEO changes                                   **
**      13-03-05    / 3.1.0     / J E   / Added EXTFLAG_LED_INV flag                    **         
**      13-03-06    / 3.1.0     / J E   / Added NEO startup busy flag                   **
**																						**
*****************************************************************************************/

                            
       	                    

// Slot entries

       	           					                                             
                                                                        

                                                            
                                                            
                                                                

                                                                
                                                                           

                                                                   
                                                                                 
                                                                 

                                                                                                        
                                                                                                        

                                                                                                        
                                                                                                        

                                                                                 

                                                                        
                                                                                                           
                                                                    
                                                                                          

                                                                                            
                                                                                     

                                                                           
                                                                             

                                                                           

// Frame structure

       	              				  

typedef struct {
    unsigned char payload[64]; // Frame payload
    unsigned char slot;                 // Slot # field
    unsigned short crc;                 // CRC field
    unsigned char filler[3];            // Filler
} YKFRAME;

// Ticket structure

       	        					 	                          

typedef struct {
	unsigned char uid[6];		// Unique (secret) ID
	unsigned short useCtr;				// Use counter (incremented by 1 at first use after power up) + usage flag in msb
	unsigned short tstpl;				// Timestamp incremented by approx 8Hz (low part)
	unsigned char tstph;				// Timestamp (high part)
	unsigned char sessionCtr;			// Number of times used within session. 0 for first use. After it wraps from 0xff to 1
	unsigned short rnd;					// Pseudo-random value
	unsigned short crc;					// CRC16 value of all fields
} TICKET;

// Activation modifier of sessionUse field (bitfields not uses as they are not portable)

       	                 		      	                                                               
       	               			      	                                          

// Configuration structure

       	          				  		                          
       	        				  		                  
                                                                                                   
       	             			 		                                           

typedef struct {
	unsigned char fixed[16];	// Fixed data in binary format
	unsigned char uid[6];		// Fixed UID part of ticket
	unsigned char key[16];		// AES key
	unsigned char accCode[6]; // Access code to re-program device
	unsigned char fixedSize;			// Number of bytes in fixed field (0 if not used)
	unsigned char extFlags;				// Extended flags
	unsigned char tktFlags;				// Ticket configuration flags
	unsigned char cfgFlags;				// General configuration flags
	unsigned char rfu[2];				// Reserved for future use
	unsigned short crc;					// CRC16 value of all fields
} CONFIG;

// Ticket flags

       	                 			    		                             
       	                   			    		                            
       	                   			    		                             
       	                     		    		                                  
       	                     		    		                                   
       	                 			    		                               
       	                    		    		                                                                              

// Configuration flags

                        			    		                                           
                           			    		                            
                           			    		                            
                             		    		                           

// V1 flags only

       	                    		    		                                            
                             		    		                                     

// V2 flags only

       	                    		    		                                      
                                                                                              
                                                                                                            
                                                                                            

// V2.1 flags only

       	                 			    		                 
                                        	                                                  
                                                                                          
                                                                                               
                                                                            
                                                                              

// V2.2 flags only

                                                                                                
                                                                                               
                                                                                 
                                                                                         
                                                                                              
                                                                                                     

                                                                                                  
                                                                                             
                                                                                     

// V2.3 flags only

                                                                                
                                                                                 
                                                                                                                        
                                                                                                                                  

// V2.4/3.1 flags only

                                                                                       

// Flags valid for update

                                                                                                                                                                       
                                                                               
                                                                                                                                                                                                                                       

// NDEF structure

       	              		          

typedef struct {
    unsigned char len;                          // Payload length
    unsigned char type;                         // NDEF type specifier
    unsigned char data[54];         // Payload size
    unsigned char curAccCode[6];    // Access code
} YKNDEF;
        
// Device configuration block (version 3.0)

typedef struct {
    unsigned char mode;                         // Device mode
    unsigned char crTimeout;                    // Challenge-response timeout in seconds
    unsigned short autoEjectTime;               // Auto eject time in seconds    
} DEVICE_CONFIG;

                                                           
                                                                          
                                                                        
                                                                     

                                                                                                                 

                                                                                       

// Scancode mapping (version 3.0)

                                                                    
                                                                              

// Status block

typedef struct {
	unsigned char versionMajor;				    // Firmware version information
	unsigned char versionMinor;
	unsigned char versionBuild;
	unsigned char pgmSeq;					    // Programming sequence number. 0 if no valid configuration
	unsigned short touchLevel;				    // Level from touch detector
} STATUS;

                                                                                                                                 
                                                                                                                                 
                                                                                                                                       
                                                                                                                                       
                                                                                                                                      
                                                                       

// Modified hex string mapping

       	          					                  

// USB vendor ID (VID) and product ID (PID) mapping

       	          	                                               
       	           		                                                    
       	                                                                 
       	                                                                     
       	                                                                  

      		// __YKDEF_H_INCLUDED__
#__FILE__ _"C:\Users\Billy\Dropbox\Thesis\Projects\pwsafe-3.32-src\src\os\windows\yubi\YkLib.h" 18
       

                           
                   

// waitForCompletion time constants (milliseconds)

       	             	         
                                  
                                   
                                   

// Target slot constants

       	                	     
       	                 	     

typedef enum { YKLIB_CHAL_OTP, YKLIB_CHAL_HMAC } YKLIB_CHAL_MODE;

typedef enum { 
	YKLIB_OK,
    YKLIB_FAILURE,
	YKLIB_NOT_OPENED,
	YKLIB_INVALID_PARAMETER,
	YKLIB_NO_DEVICE,
	YKLIB_MORE_THAN_ONE,
	YKLIB_WRITE_ERROR,
	YKLIB_INVALID_RESPONSE,
	YKLIB_NOT_COMPLETED,
	YKLIB_NOT_CONFIGURED,
    YKLIB_NOT_READY,
    YKLIB_PROCESSING,
    YKLIB_TIMER_WAIT,
	YKLIB_UNSUPPORTED_FEATURE	
} YKLIB_RC;

class CYkLib
{
private:
	HANDLE m_handle;
    void flushPortNames(void);
    struct tagPORT_LIST {
        wchar_t *name;
        struct tagPORT_LIST *next;
    } *m_portList;
    unsigned char m_lastCmd;
    unsigned char m_seq;

    YKLIB_RC rawWrite(BYTE slot, BYTE *dt = 0, size_t bcnt = 0);
    unsigned short getCrc(unsigned char *bp, size_t bcnt);

public:
    CYkLib(void);
    virtual ~CYkLib(void);

    unsigned short enumPorts(void);
    wchar_t *getPortName(unsigned short portIndex);
    bool getPortName(unsigned short portIndex, wchar_t *dst, size_t dstSize);

    YKLIB_RC openKey(wchar_t *portName = 0);
    YKLIB_RC openKey(unsigned short portIndex);
    YKLIB_RC closeKey(void);

    YKLIB_RC readStatus(STATUS *sp);
    YKLIB_RC isSlotConfigured(unsigned char slot, STATUS *sp); 

    static YKLIB_RC setKey160(CONFIG *cfg, const unsigned char *key);
    YKLIB_RC setMovingFactor(CONFIG *cfg, unsigned long seed);

    YKLIB_RC writeConfigBegin(unsigned char slot, CONFIG *cfg = 0, unsigned char *curPasswd = 0);

    YKLIB_RC readSerialBegin(void);

    YKLIB_RC writeChallengeBegin(unsigned char slot, YKLIB_CHAL_MODE mode, unsigned char *chal, size_t chalLen);

    YKLIB_RC abortPendingRequest(void);

    YKLIB_RC waitForCompletion(unsigned short maxWait = 0, unsigned char *respBuffer = 0, unsigned char respLen = 0, unsigned short *timerVal = 0);
};

#__FILE__ _"C:\Users\Billy\Dropbox\Thesis\Projects\pwsafe-3.32-src\src\os\windows\yubi\YkLib.cpp" 17
                  
                  

extern "C" {
                    
                    
                  
                   
};

       	                	     
                                 

                                      

CYkLib::CYkLib(void)
{
	m_handle = INVALID_HANDLE_VALUE;
    m_portList = 0;
    m_lastCmd = 0;
}

CYkLib::~CYkLib(void)
{
    closeKey();
    flushPortNames();
}

/*************************************************************************
**  private function flushPortNames                                     **
**  Flushes internal list of ports                                      **
**                                                                      **
**  void flushPortNames(void)                                           **
**                                                                      **
*************************************************************************/

void CYkLib::flushPortNames(void)
{
    struct tagPORT_LIST *tmp;

    while (m_portList) {
        tmp = m_portList->next;
        delete [] m_portList->name;
		delete m_portList;
        m_portList = tmp;
    }
}

/*************************************************************************
**  private function rawWrite                                           **
**  Send a raw packet to device without waiting for completion          **
**                                                                      **
**  YKLIB_RC rawWrite(BYTE cmd, BYTE *dt, size_t bcnt)                  **
**                                                                      **
**  Where:                                                              **
**  "cmd" is command byte                                               **
**  "dt" is pointer to command data                                     **
**  "bcnt" is number of bytes in command                                **
**                                                                      **
**  Returns: Status return code                                         **
**                                                                      **
*************************************************************************/

YKLIB_RC CYkLib::rawWrite(BYTE cmd, BYTE *dt, size_t bcnt)
{
	if (m_handle == INVALID_HANDLE_VALUE) return YKLIB_NOT_OPENED;
    if (bcnt > 64) return YKLIB_INVALID_PARAMETER;        

	BYTE rptBuf[9];
    YKFRAME frame;
	int i, j;
    YKLIB_RC rc;
    STATUS status;

    // Read status at start

    if ((rc = readStatus(&status)) != YKLIB_OK) return rc;

    // Check that command is supported by current firmware

    if (cmd > 3)
        if (status.versionMajor < 2 || (status.versionMajor == 2 && status.versionMinor < 2)) return YKLIB_UNSUPPORTED_FEATURE;

    // Keep last sent command and sequence number 

    m_lastCmd = cmd;
    m_seq = status.pgmSeq;

	// Ensure non used bytes are cleared

	memset(&frame, 0, sizeof(frame));

	// Copy in data to be written

	if (bcnt && dt) memcpy(frame.payload, dt, bcnt);

	// Insert slot/cmd #

	frame.slot = cmd;

	// Insert CRC

    frame.crc = getCrc(frame.payload, sizeof(frame.payload));

	// Write the reports

    for (i = 0; ; i++) {

		// Copy appropriate slice of the frame

		memcpy(rptBuf + 1, ((BYTE *) &frame) + i * 7, 7);

		// Empty slices in the middle of the frame can be discarded

        if (i && (i < ((sizeof(frame) / 7) - 1))) {
			for (j = 0; j < 7; j++) if (rptBuf[1 + j]) break;
			if (j >= 7) continue;
		}

		// Insert Win32 report #

		rptBuf[0] = 0;
		rptBuf[8] = (BYTE) i | 0x80;

		// Write report

        Sleep(2);
		if (!HidD_SetFeature(m_handle, rptBuf, 9)) return YKLIB_FAILURE;

        // Return if last report written without checking completion status

        if (i >= ((sizeof(frame) / 7) - 1)) return YKLIB_OK;

        // Check that slice has been stored before sending next. This operation shall be instant

        memset(rptBuf, 0, sizeof(rptBuf));
        if (!HidD_GetFeature(m_handle, rptBuf, sizeof(rptBuf))) return YKLIB_FAILURE;
	}
}


/*************************************************************************
**  function getCrc                                                     **
**  Calculate ISO13239 checksum of buffer                               **
**                                                                      **
**  unsigned short getCrc(unsigned char *bp, size_t bcnt)               **
**                                                                      **
**  Where:                                                              **
**  "bp" is pointer to data                                             **
**  "bcnt" is number of bytes in buffer                                 **
**                                                                      **
**  Returns: CRC                                                        **
**                                                                      **
*************************************************************************/

unsigned short CYkLib::getCrc(unsigned char *bp, size_t bcnt)
{
    unsigned short crc = 0xffff;
	int i, j;

    while (bcnt--) {
	    crc ^= *bp++;
	    for (i = 0; i < 8; i++) {
            j = crc & 1;
            crc >>= 1;
            if (j) crc ^= 0x8408;
	    }
    }

    return crc;
}

/*************************************************************************
**  function enumPorts                                                  **
**  Scans all present ports for attached Yubikeys and keeps the list    **
**                                                                      **
**  unsigned short enumPorts(void)                                      **
**                                                                      **
**  Returns: Number of ports with Yubikeys found                        **
**                                                                      **
*************************************************************************/

unsigned short CYkLib::enumPorts(void)
{
    flushPortNames();

    // Find all currently available Yubikeys

    HDEVINFO hi;
    SP_DEVICE_INTERFACE_DATA di;
    PSP_DEVICE_INTERFACE_DETAIL_DATA_W pi;
    HIDD_ATTRIBUTES devInfo;
    int i;
    DWORD len, rc;
    struct tagPORT_LIST *tmp;
    unsigned short cnt = 0;

    flushPortNames();

	// Get the collection of present Yubikey devices

	hi = SetupDiGetClassDevs(&GUID_DEVINTERFACE_KEYBOARD, 0, 0, DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);
	if (hi == INVALID_HANDLE_VALUE) return -1;

	di.cbSize = sizeof (SP_DEVICE_INTERFACE_DATA);

	// Traverse the list (put a cap if something for some reason would go wrong - just feels good to do that...)

	for (i = 0; i < 1000; i++) {
         if (!SetupDiEnumDeviceInterfaces(hi, 0, &GUID_DEVINTERFACE_KEYBOARD, i, &di)) break;

		// Get size required (the call shall fail as there is no buffer - but the len member shall be filled in)

		SetupDiGetDeviceInterfaceDetail(hi, &di, 0, 0, &len, 0);

		if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) break;

		// Allocate a buffer of appropriate size

		pi = (PSP_DEVICE_INTERFACE_DETAIL_DATA_W) new BYTE[len];
		pi->cbSize = sizeof (SP_DEVICE_INTERFACE_DETAIL_DATA);

		// Make the "real" call and get the path to the device

		rc = SetupDiGetDeviceInterfaceDetailW(hi, &di, pi, len, &len, 0);

		// Success ?

		if (rc) {

			// Try to open device

			m_handle = CreateFileW(pi->DevicePath, GENERIC_WRITE,
                  FILE_SHARE_READ | FILE_SHARE_WRITE, 0, OPEN_EXISTING, 0, 0);	

			// Success

			if (m_handle != INVALID_HANDLE_VALUE) {

				// Get HID attributes

				if (HidD_GetAttributes(m_handle, &devInfo)) {
					if (devInfo.VendorID == 0x1050 && (devInfo.ProductID == 0x0010 || 
                        devInfo.ProductID == 0x0110 || devInfo.ProductID == 0x0111)) {

                        // Keep full path of device found

                        tmp = new tagPORT_LIST;

                        tmp->name = new wchar_t[lstrlenW(pi->DevicePath) + 1];
                        lstrcpyW(tmp->name, pi->DevicePath);
                        tmp->next = m_portList;
                        m_portList = tmp;

                        cnt++;
					}
				}

				CloseHandle(m_handle);
				m_handle = INVALID_HANDLE_VALUE;
			}
		} 

		// Free allocated buffer

		delete pi;

		// If failed, bail out

		if (!rc) break;
	}

	// Free list

	SetupDiDestroyDeviceInfoList(hi);

    return cnt;
}

/*************************************************************************
**  function getPortName                                                **
**  Returns port name from a prior enumPorts call                       **
**                                                                      **
**  wchar_t *getPortName(unsigned short index)                          **
**                                                                      **
**  Where:                                                              **
**  "portIndex" is index in list 0..                                    **
**                                                                      **
**  Returns: Pointer to port name if found, NULL otherwise              **
**                                                                      **
*************************************************************************/

wchar_t *CYkLib::getPortName(unsigned short portIndex)
{
    struct tagPORT_LIST *tmp = m_portList;

    while (tmp) {
        if (!portIndex) return tmp->name;
        tmp = tmp->next;
        portIndex--;
    }
 
    return 0;
}

/*************************************************************************
**  function getPortName                                                **
**  Returns port name from a prior enumPorts call                       **
**                                                                      **
**  bool getPortName(unsigned short index, wchar_t *dst,                **
**                           size_t dstSize)                            **
**                                                                      **
**  Where:                                                              **
**  "portIndex" is index in list 0..                                    **
**  "dst" is pointer to destination buffer                              **
**  "dstSize" is size of destination buffer                             **
**                                                                      **
**  Returns: TRUE if valid port name returned, FALSE otherwise          **
**                                                                      **
*************************************************************************/

bool CYkLib::getPortName(unsigned short portIndex, wchar_t *dst, size_t dstSize)
{
    wchar_t *tmp = getPortName(portIndex);

    if (tmp) {
        lstrcpynW(dst, tmp, (int) dstSize);
        return true;
    }

    return false;
}

/*************************************************************************
**  function openKey                                                    **
**  Opens a present Yubikey                                             **
**                                                                      **
**  YKLIB_RC openKey(wchar_ t *portName)                                **
**                                                                      **
**  Where:                                                              **
**  "portName" is name of specfic port. NULL for all ports              **
**                                                                      **
**  Returns: Status return code                                         **
**                                                                      **
*************************************************************************/

YKLIB_RC CYkLib::openKey(wchar_t *portName)
{
    int i;

    // Make sure previous is closed first

    closeKey();

    // If no port name specified, search all ports

    if (!portName) {
        i = enumPorts();
        if (!i) return YKLIB_NO_DEVICE;
        if (i != 1) return YKLIB_MORE_THAN_ONE;
        portName = m_portList->name;
    }

    // Open port

	m_handle = CreateFileW(portName, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, 0, OPEN_EXISTING, 0, 0);	

    return (m_handle == INVALID_HANDLE_VALUE) ? YKLIB_FAILURE : YKLIB_OK;
}

/*************************************************************************
**  function openKey                                                    **
**  Opens a present Yubikey                                             **
**                                                                      **
**  YKLIB_RC openKey(unsigned short portIndex)                          **
**                                                                      **
**  Where:                                                              **
**  "portIndex" is index from a previous enumPorts call                 **
**                                                                      **
**  Returns: Status return code                                         **
**                                                                      **
*************************************************************************/

YKLIB_RC CYkLib::openKey(unsigned short portIndex)
{
    wchar_t buf[_MAX_PATH];

    if (!getPortName(portIndex, buf, sizeof(buf) / sizeof(buf[0]))) return YKLIB_INVALID_PARAMETER;

    closeKey();

    return openKey(buf);
}

/*************************************************************************
**  function closeKey                                                   **
**  Closes an instance of a previously opened key                       **
**                                                                      **
**  YKLIB_RC closeKey(void)                                             **
**                                                                      **
**  Returns: Status return code                                         **
**                                                                      **
*************************************************************************/

YKLIB_RC CYkLib::closeKey(void)
{
    CloseHandle(m_handle);

    m_handle = INVALID_HANDLE_VALUE;
    m_lastCmd = 0;

    return YKLIB_OK;
}

/*************************************************************************
**  function readStatus                                                 **
**  Reads status from a present opened Yubikey                          **
**                                                                      **
**  YKLIB_RC readStatus(STATUS *status)                                 **
**                                                                      **
**  Where:                                                              **
**  "status" is pointer to receiving STATUS structure                   **
**                                                                      **
**  Returns: Status return code                                         **
**                                                                      **
*************************************************************************/

YKLIB_RC CYkLib::readStatus(STATUS *status)
{
    if (m_handle == INVALID_HANDLE_VALUE) return YKLIB_NOT_OPENED;

    // Read status record

	BYTE buf[9];

	memset(buf, 0, sizeof(buf));

	if (!HidD_GetFeature(m_handle, buf, 9)) return YKLIB_FAILURE;

	status->versionMajor = buf[2];
	status->versionMinor = buf[3];
	status->versionBuild = buf[4];
	status->pgmSeq = buf[5];
	status->touchLevel = buf[6] + ((WORD) buf[7] << 8U);;

    return (buf[9 - 1]) ? YKLIB_NOT_READY : YKLIB_OK;
}

/*************************************************************************
**  function isSlotConfigured                                           **
**  Checks if a specified slot is configured or not                     **
**                                                                      **
**  YKLIB_RC isSlotConfigured(unsigned char slot, STATUS *status)       **
**                                                                      **
**  Where:                                                              **
**  "slot" is slot number 0..                                           **
**  "status" is pointer to receiving STATUS structure                   **
**                                                                      **
**  Returns: Status return code                                         **
**                                                                      **
*************************************************************************/

YKLIB_RC CYkLib::isSlotConfigured(unsigned char slot, STATUS *status)
{
    if (m_handle == INVALID_HANDLE_VALUE) return YKLIB_NOT_OPENED;

    // Feature available from version 2.1

    if (status->versionMajor < 2 || (status->versionMajor == 2 && status->versionMinor < 1)) return YKLIB_UNSUPPORTED_FEATURE;

    return (status->touchLevel & ((slot == 0) ? 1 : 2)) ? YKLIB_OK : YKLIB_NOT_CONFIGURED;
}

/*************************************************************************
**  function writeConfigBegin                                           **
**  Start a configuration slot write                                    **
**                                                                      **
**  YKLIB_RC writeConfigBegin(unsigned char slot, CONFIG *cfg,          **
**                            bool kill, unsigned char *curPasswd)      **
**                                                                      **
**  Where:                                                              **
**  "slot" is slot number 0..                                           **
**  "cfg" is pointer Yubikey CONFIG structure. NULL kills config        **
**  "curAccCode" is pointer to current access password (if any)         **
**                                                                      **
**  Returns: Status return code                                         **
**                                                                      **
*************************************************************************/

YKLIB_RC CYkLib::writeConfigBegin(unsigned char slot, CONFIG *cfg, unsigned char *curAccCode)
{
    YKLIB_RC rc;
           
    struct {
        CONFIG cfg;
        BYTE accCode[6];
    } blk;
           

    // Setup configuration block + CRC if valid. Zap otherwise

    memset(&blk, 0, sizeof(blk));

    if (cfg) {
        memcpy(&blk.cfg, cfg, sizeof(blk.cfg));
        blk.cfg.crc = ~getCrc((BYTE *) &blk.cfg, sizeof(blk.cfg) - sizeof(blk.cfg.crc));
    }

    // Insert access code if present

    if (curAccCode) memcpy(blk.accCode, curAccCode, sizeof(blk.accCode));

    // Start write request

    rc = rawWrite(slot ? 3 : 1, (BYTE *) &blk, sizeof(blk));

    // Setup expected sequence # for completion

    m_seq = cfg ? (m_seq + 1) : 0;

    return rc;
}

/*************************************************************************
**  function readSerialBegin                                            **
**  Start a serial number read                                          **
**                                                                      **
**  YKLIB_RC readSerialBegin(void)                                      **
**                                                                      **
**  Returns: Status return code                                         **
**                                                                      **
*************************************************************************/

YKLIB_RC CYkLib::readSerialBegin(void)
{
    return rawWrite(0x10);
}

/*************************************************************************
**  function writeChallengeBegin                                        **
**  Start a serial number read                                          **
**                                                                      **
**  YKLIB_RC writeChallengeBegin(unsigned char slot,                    **
**                      YKLIB_CHAL_MODE mode,                           **
**                      unsigned char *chal, size_t chalLen)            **
**                                                                      **
**  Where:                                                              **
**  "slot" is slot number 0..                                           **
**  "mode" is challenge mode YKLIB_OTP or YKLIB_HMAC                    **
**  "chal" is pointer to challenge                                      **
**  "chalLen" is number of bytes in challenge                           **
**                                                                      **
**  Returns: Status return code                                         **
**                                                                      **
*************************************************************************/

YKLIB_RC CYkLib::writeChallengeBegin(unsigned char slot, YKLIB_CHAL_MODE mode, unsigned char *chal, size_t chalLen)
{
    if (mode == YKLIB_CHAL_OTP)
        slot = (slot == 0) ? 0x20 : 0x28;
    else if (mode == YKLIB_CHAL_HMAC)
        slot = (slot == 0) ? 0x30 : 0x38;
    else 
        return YKLIB_INVALID_PARAMETER;

    // Send challenge. 

    return rawWrite(slot, chal, chalLen);
}

/*************************************************************************
**  function abortPendingRequest                                        **
**  Abort a pending request (if any)                                    **
**                                                                      **
**  YKLIB_RC abortPendingRequest(void)                                  **
**                                                                      **
**  Returns: Status return code                                         **
**                                                                      **
*************************************************************************/

YKLIB_RC CYkLib::abortPendingRequest(void)
{
    STATUS status;
    YKLIB_RC rc;

    // Check startus first

    if ((rc = readStatus(&status)) != YKLIB_NOT_READY) return rc;

    // Send abort request

	BYTE rptBuf[9];
    
    memset(rptBuf, 0, sizeof(rptBuf));
    rptBuf[9 - 1] = 0x8f;

    if (!HidD_SetFeature(m_handle, rptBuf, 9)) return YKLIB_FAILURE;

    // Check status again

    return readStatus(&status);
}

/*************************************************************************
**  function waitForCompletion                                          **
**  Wait for an asynchronous call to complete                           **
**                                                                      **
**  YKLIB_RC waitForCompletion(unsigned short maxWait,                  **
**                  unsigned char *respBuffer, unsigned char respLen,   **
**                  unsigned short *timerVal)                           **
**                                                                      **
**  Where:                                                              **
**  "maxWait" is max number of milliseconds to wait. Zero if none       **
**  "respBuffer" is pointer to response buffer (if applicable)          **
**  "respLen" is exact number of bytes expected                         **
**  "timerVal" is a pointer to field receiving timer val (if applicable)**
**                                                                      **
**  Returns: Status return code                                         **
**                                                                      **
*************************************************************************/

YKLIB_RC CYkLib::waitForCompletion(unsigned short maxWait, unsigned char *respBuffer, unsigned char respLen, unsigned short *timerVal)
{
	BYTE rptBuf[9];
    DWORD tend = GetTickCount() + maxWait;

    for (;;) {

        // Query status

        memset(rptBuf, 0, sizeof(rptBuf));
        if (!HidD_GetFeature(m_handle, rptBuf, sizeof(rptBuf))) return YKLIB_FAILURE;

        // Return with ok if completed

        if (!rptBuf[9 - 1]) {

            // No response found, return with error if response requested

            if (respLen) return YKLIB_INVALID_RESPONSE;

            // If a write is pending, verify that the sequence number is correct

            if (m_lastCmd == 1 || m_lastCmd == 3)
            	if (m_seq != rptBuf[5]) return YKLIB_WRITE_ERROR;

            return YKLIB_OK;
        }

        // If first response pending, read in all response bytes

        if (rptBuf[9 - 1] & 0x40) {

            // Continue to read until response flag is reset

            BYTE tempBuf[0x07 * 7 + sizeof(WORD)], slices = 0, bail = 0;

            for (;;) {

                // Safeguard to prevent hang (shall never happen)

                if (++bail > (2 * 0x07)) {
                    memset(rptBuf, 0, sizeof(rptBuf));
                    rptBuf[9 - 1] = 0x8f;
                    if (!HidD_SetFeature(m_handle, rptBuf, 9)) return YKLIB_FAILURE;

                    return YKLIB_INVALID_RESPONSE;
                }

                // Store at the right place

                memcpy(tempBuf + (rptBuf[9 - 1] & 0x07) * 7, rptBuf + 1, 7);

                // Indicate that a particular slice has been stored

                slices |= (1 << (rptBuf[9 - 1] & 0x07));
                   
                // Read again/next

                memset(rptBuf, 0, sizeof(rptBuf));
                if (!HidD_GetFeature(m_handle, rptBuf, sizeof(rptBuf))) return YKLIB_FAILURE;

                // Check if completed

                if (!rptBuf[9 - 1]) break;

                // Return with error if invalid response

                if (!(rptBuf[9 - 1] & 0x40)) return YKLIB_INVALID_RESPONSE;
            } 

            // Check that parameters are ok

            if (!respLen || (respLen > sizeof(tempBuf))) return YKLIB_INVALID_RESPONSE;
            if (slices != ((1 << (respLen + sizeof(WORD) + 7 - 1) / 7) - 1)) return YKLIB_INVALID_RESPONSE;

            // Verify checksum

            if (getCrc(tempBuf, respLen + sizeof(unsigned short)) != 0xf0b8) return YKLIB_INVALID_RESPONSE;
                
            memcpy(respBuffer, tempBuf, respLen);

            return YKLIB_OK;
        }

        // Timer/timeout pending ?

        if (rptBuf[9 - 1] & 0x20) {
            if (timerVal) *timerVal = rptBuf[9 - 1] & 0x1f;
            return YKLIB_TIMER_WAIT;
        }

        // Still processing, or... ?

        if (!(rptBuf[9 - 1] & 0x80)) return YKLIB_FAILURE;

        // Timeout ?

        if (GetTickCount() >= tend) return YKLIB_PROCESSING;

        // Short wait

        Sleep(10);
    }
} 

/*************************************************************************
**  function setKey160													**
**  Assigns a 160-bit HOTP/HMAC-SHA1 key into a configuration structure	**
**                                                                      **
**  YKLIB_RC setKey160(CONFIG *cfg, const unsigned char *key)           **
**                                                                      **
**  Where:                                                              **
**  "cfg" is pointer to destination configuration structure				**
**  "key" is pointer to 160-bit (20 bytes) key							**
**                                                                      **
**  Returns: Status return code                                         **
**                                                                      **
*************************************************************************/

YKLIB_RC CYkLib::setKey160(CONFIG *cfg, const unsigned char *key)
{
    memcpy(cfg->key, key, sizeof(cfg->key));
    memcpy(cfg->uid, key + sizeof(cfg->key), 20 - 16);

	return YKLIB_OK;
}

/*************************************************************************
**  function setMovingFactor											**
**  Assigns a HOTP moving factor into a configuration structure         **
**                                                                      **
**  YKLIB_RC setMovingFactor(CONFIG *cfg, unsigned long seed)           **
**                                                                      **
**  Where:                                                              **
**  "cfg" is pointer to destination configuration structure				**
**  "seed" is moving factor. Must be even divisable by 16               **
**                                                                      **
**  Returns: Status return code                                         **
**                                                                      **
*************************************************************************/

YKLIB_RC CYkLib::setMovingFactor(CONFIG *cfg, unsigned long seed)
{
    if (seed & 0xf) return YKLIB_INVALID_PARAMETER;

    cfg->uid[4] = (BYTE) (seed >> 12);
    cfg->uid[5] = (BYTE) (seed >> 4);

    return YKLIB_OK;
}
